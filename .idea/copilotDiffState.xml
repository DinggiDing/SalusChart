<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/ScatterPlotDraw.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/ScatterPlotDraw.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.unit.Dp&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;&#10;object ScatterPlotDraw {&#10;&#10;    /**&#10;     * 각 데이터 포인트를 원으로 표시합니다 (시각적 표시용, 비상호작용).&#10;     *&#10;     * @param points 포인트 중심 좌표 목록&#10;     * @param values 표시할 값 목록&#10;     * @param pointRadius 포인트 외부 반지름&#10;     * @param innerRadius 포인트 내부 반지름&#10;     * @param selectedPointIndex 현재 선택된 포인트 인덱스 (null이면 모든 포인트 선택됨)&#10;     * @param onPointClick 포인트 클릭 시 호출되는 콜백 (포인트 인덱스)&#10;     * @param interactive true이면 클릭 가능하고 툴팁 표시, false이면 순수 시각적 렌더링 (기본값: true)&#10;     * @param chartType 차트 타입 (툴팁 위치 결정용)&#10;     */&#10;    @Composable&#10;    fun PointMarker(&#10;        points: List&lt;Offset&gt;,&#10;        values: List&lt;String&gt;,&#10;        pointRadius: Dp = 8.dp,&#10;        innerRadius: Dp = 4.dp,&#10;        selectedPointIndex: Int? = null,&#10;        onPointClick: ((Int) -&gt; Unit)? = null,&#10;        interactive: Boolean = true,&#10;        chartType: ChartType&#10;    ) {&#10;        val density = LocalDensity.current&#10;&#10;        points.forEachIndexed { index, center -&gt;&#10;            // 각 포인트의 툴팁 표시 상태&#10;            var showTooltip by remember { mutableStateOf(false) }&#10;&#10;            // Float 좌표를 Dp로 변환&#10;            val xDp = with(density) { center.x.toDp() }&#10;            val yDp = with(density) { center.y.toDp() }&#10;&#10;            // 선택 상태 결정: selectedPointIndex가 null이면 모든 포인트 선택됨&#10;            val isSelected = selectedPointIndex == null || selectedPointIndex == index&#10;            val outerColor = if (isSelected) Color.Blue else Color.Gray&#10;&#10;            Box(&#10;                modifier = Modifier&#10;                    .offset(x = xDp - pointRadius, y = yDp - pointRadius)&#10;                    .size(pointRadius * 2)&#10;                    .border(1.dp, Color.Red)&#10;                    .clickable {&#10;                        // 툴팁 표시 상태 토글&#10;                        showTooltip = !showTooltip&#10;                        // 외부 클릭 이벤트 처리&#10;                        onPointClick?.invoke(index)&#10;                    },&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                // 바깥쪽 원 - 선택 상태에 따라 색상 변경&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(pointRadius * 2)&#10;                        .background(color = outerColor, shape = CircleShape)&#10;                )&#10;                // 안쪽 흰색 원&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(innerRadius * 2)&#10;                        .background(color = Color.White, shape = CircleShape)&#10;                )&#10;                // 툴팁 표시&#10;                if (showTooltip) {&#10;                    val labelOffset = when (chartType) {&#10;                        ChartType.LINE -&gt; {&#10;                            // 라인 차트의 경우 calculateLabelPosition 사용&#10;                            val optimalPosition = ChartMath.Line.calculateLabelPosition(index, points)&#10;&#10;                            // 각 포인트마다 relative 위치를 계산&#10;                            val relativeDx = with(density) {&#10;                                (optimalPosition.x - center.x).toDp()&#10;                            }&#10;                            val relativeDy = with(density) {&#10;                                (optimalPosition.y - center.y).toDp()&#10;                            }&#10;&#10;                            // 포인트 반지름을 고려하여 위치 조정&#10;                            val adjustedDx = if (relativeDx &gt; 0.dp) relativeDx + pointRadius&#10;                            else if (relativeDx == 0.dp) relativeDx&#10;                            else relativeDx - pointRadius&#10;                            val adjustedDy = if (relativeDy &gt; 0.dp) relativeDy + pointRadius&#10;                            else if (relativeDy == 0.dp) relativeDy&#10;                            else relativeDy - pointRadius&#10;&#10;                            Modifier.offset(x = adjustedDx, y = adjustedDy)&#10;                        }&#10;                        else -&gt; {&#10;                            // 스캐터 차트의 경우 기본 위치 (포인트 위쪽)&#10;                            Modifier.offset(x = 0.dp, y = -(pointRadius * 4))&#10;                        }&#10;                    }&#10;&#10;                    Box(&#10;                        modifier = labelOffset&#10;                            .width(IntrinsicSize.Min)&#10;                            .background(&#10;                                color = Color.Black.copy(alpha = 0.8f),&#10;                                shape = RoundedCornerShape(4.dp)&#10;                            )&#10;                            .border(1.dp, Color.Gray, RoundedCornerShape(4.dp))&#10;                            .padding(horizontal = 8.dp, vertical = 4.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = values.getOrElse(index) { &quot;N/A&quot; },&#10;                            color = Color.White,&#10;                            fontSize = 12.sp,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier.align(Alignment.Center)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.unit.Dp&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;&#10;object ScatterPlotDraw {&#10;&#10;    /**&#10;     * 각 데이터 포인트를 원으로 표시합니다 (시각적 표시용, 비상호작용).&#10;     *&#10;     * @param points 포인트 중심 좌표 목록&#10;     * @param values 표시할 값 목록&#10;     * @param pointRadius 포인트 외부 반지름&#10;     * @param innerRadius 포인트 내부 반지름&#10;     * @param selectedPointIndex 현재 선택된 포인트 인덱스 (null이면 모든 포인트 선택됨)&#10;     * @param onPointClick 포인트 클릭 시 호출되는 콜백 (포인트 인덱스)&#10;     * @param interactive true이면 클릭 가능하고 툴팁 표시, false이면 순수 시각적 렌더링 (기본값: true)&#10;     * @param chartType 차트 타입 (툴팁 위치 결정용)&#10;     */&#10;    @Composable&#10;    fun PointMarker(&#10;        points: List&lt;Offset&gt;,&#10;        values: List&lt;String&gt;,&#10;        pointRadius: Dp = 8.dp,&#10;        innerRadius: Dp = 4.dp,&#10;        selectedPointIndex: Int? = null,&#10;        onPointClick: ((Int) -&gt; Unit)? = null,&#10;        interactive: Boolean = true,&#10;        chartType: ChartType&#10;    ) {&#10;        val density = LocalDensity.current&#10;&#10;        points.forEachIndexed { index, center -&gt;&#10;            // 각 포인트의 툴팁 표시 상태&#10;            var showTooltip by remember { mutableStateOf(false) }&#10;&#10;            // Float 좌표를 Dp로 변환&#10;            val xDp = with(density) { center.x.toDp() }&#10;            val yDp = with(density) { center.y.toDp() }&#10;&#10;            // 선택 상태 결정: selectedPointIndex가 null이면 모든 포인트 선택됨&#10;            val isSelected = selectedPointIndex == null || selectedPointIndex == index&#10;            val outerColor = if (isSelected) Color.Blue else Color.Gray&#10;&#10;            if (interactive) {&#10;                // 상호작용 모드: 클릭 가능하고 툴팁 표시&#10;                Box(&#10;                    modifier = Modifier&#10;                        .offset(x = xDp - pointRadius, y = yDp - pointRadius)&#10;                        .size(pointRadius * 2)&#10;                        .clickable {&#10;                            // 툴팁 표시 상태 토글&#10;                            showTooltip = !showTooltip&#10;                            // 외부 클릭 이벤트 처리&#10;                            onPointClick?.invoke(index)&#10;                        },&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    // 바깥쪽 원 - 선택 상태에 따라 색상 변경&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(pointRadius * 2)&#10;                            .background(color = outerColor, shape = CircleShape)&#10;                    )&#10;                    // 안쪽 흰색 원&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(innerRadius * 2)&#10;                            .background(color = Color.White, shape = CircleShape)&#10;                    )&#10;&#10;                    // 툴팁 표시&#10;                    if (showTooltip) {&#10;                        val labelOffset = when (chartType) {&#10;                            ChartType.LINE -&gt; {&#10;                                // 라인 차트의 경우 calculateLabelPosition 사용&#10;                                val optimalPosition = ChartMath.Line.calculateLabelPosition(index, points)&#10;&#10;                                // 각 포인트마다 relative 위치를 계산&#10;                                val relativeDx = with(density) {&#10;                                    (optimalPosition.x - center.x).toDp()&#10;                                }&#10;                                val relativeDy = with(density) {&#10;                                    (optimalPosition.y - center.y).toDp()&#10;                                }&#10;&#10;                                // 포인트 반지름을 고려하여 위치 조정&#10;                                val adjustedDx = if (relativeDx &gt; 0.dp) relativeDx + pointRadius&#10;                                else if (relativeDx == 0.dp) relativeDx&#10;                                else relativeDx - pointRadius&#10;                                val adjustedDy = if (relativeDy &gt; 0.dp) relativeDy + pointRadius&#10;                                else if (relativeDy == 0.dp) relativeDy&#10;                                else relativeDy - pointRadius&#10;&#10;                                Modifier.offset(x = adjustedDx, y = adjustedDy)&#10;                            }&#10;                            else -&gt; {&#10;                                // 스캐터 차트의 경우 기본 위치 (포인트 위쪽)&#10;                                Modifier.offset(x = 0.dp, y = -(pointRadius * 4))&#10;                            }&#10;                        }&#10;&#10;                        Box(&#10;                            modifier = labelOffset&#10;                                .width(IntrinsicSize.Min)&#10;                                .background(&#10;                                    color = Color.Black.copy(alpha = 0.8f),&#10;                                    shape = RoundedCornerShape(4.dp)&#10;                                )&#10;                                .border(1.dp, Color.Gray, RoundedCornerShape(4.dp))&#10;                                .padding(horizontal = 8.dp, vertical = 4.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = values.getOrElse(index) { &quot;N/A&quot; },&#10;                                color = Color.White,&#10;                                fontSize = 12.sp,&#10;                                textAlign = TextAlign.Center,&#10;                                modifier = Modifier.align(Alignment.Center)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // 비상호작용 모드: 순수 시각적 렌더링만 (클릭 불가, 툴팁 없음)&#10;                Box(&#10;                    modifier = Modifier&#10;                        .offset(x = xDp - pointRadius, y = yDp - pointRadius)&#10;                        .size(pointRadius * 2),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    // 바깥쪽 원 - 선택 상태에 따라 색상 변경&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(pointRadius * 2)&#10;                            .background(color = outerColor, shape = CircleShape)&#10;                    )&#10;                    // 안쪽 흰색 원&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(innerRadius * 2)&#10;                            .background(color = Color.White, shape = CircleShape)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/CalendarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/CalendarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.pager.HorizontalPager&#10;import androidx.compose.foundation.pager.rememberPagerState&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import java.time.DayOfWeek&#10;import java.time.LocalDate&#10;import java.time.YearMonth&#10;import java.time.format.TextStyle&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import kotlinx.coroutines.launch&#10;import java.util.*&#10;&#10;/**&#10; * 캘린더 차트에 표시할 데이터 모델&#10; */&#10;data class CalendarEntry(&#10;    val date: LocalDate,&#10;    val value: Float,&#10;    val color: Color? = null&#10;)&#10;&#10;/**&#10; * 캘린더 차트를 표시하는 Composable 함수&#10; * 만약 entries의 날짜가 2달 이상이면 자동으로 MultiMonthCalendarChart로 전환됩니다.&#10; */&#10;@Composable&#10;fun CalendarChart(&#10;    modifier: Modifier = Modifier,&#10;    entries: List&lt;CalendarEntry&gt;,&#10;    yearMonth: YearMonth = YearMonth.now(),&#10;    maxBubbleSize: Float = 24f,&#10;    minBubbleSize: Float = 6f,&#10;    defaultColor: Color = MaterialTheme.colorScheme.primary,&#10;    showGrid: Boolean = true,&#10;    width: Dp = Dp.Unspecified,  // 너비 파라미터 추가&#10;    height: Dp = 350.dp,         // height 파라미터 타입을 Dp로 변경&#10;    onMonthChanged: ((YearMonth) -&gt; Unit)? = null,&#10;    chartType: ChartType = ChartType.CALENDAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    // 2달 이상의 데이터가 있는지 확인&#10;    val distinctMonths = entries.map { YearMonth.of(it.date.year, it.date.month) }.distinct()&#10;    val hasMultipleMonths = distinctMonths.size &gt; 1&#10;&#10;    if (hasMultipleMonths) {&#10;        // 2달 이상의 데이터가 있으면 MultiMonthCalendarChart 사용&#10;        val startMonth = distinctMonths.minOrNull() ?: yearMonth&#10;        val months = distinctMonths.size&#10;&#10;        MultiMonthCalendarChart(&#10;            modifier = modifier,&#10;            entries = entries,&#10;            startYearMonth = startMonth,&#10;            months = months,&#10;            maxBubbleSize = maxBubbleSize,&#10;            minBubbleSize = minBubbleSize,&#10;            defaultColor = defaultColor,&#10;            showGrid = showGrid,&#10;            width = width,           // 추가된 width 파라미터 전달&#10;            height = height,         // 변경된 height 파라미터 타입 적용&#10;            onMonthChanged = onMonthChanged&#10;        )&#10;    } else {&#10;        // 단일 월 데이터만 있으면 기존 CalendarChart 로직 사용&#10;        SingleMonthCalendarChart(&#10;            modifier = modifier,&#10;            entries = entries,&#10;            yearMonth = yearMonth,&#10;            maxBubbleSize = maxBubbleSize,&#10;            minBubbleSize = minBubbleSize,&#10;            defaultColor = defaultColor,&#10;            showGrid = showGrid,&#10;            width = width,           // 추가된 width 파라미터 전달&#10;            height = height          // 변경된 height 파라미터 타입 적용&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 단일 월을 표시하는 캘린더 차트 (기존 CalendarChart 로직)&#10; */&#10;@Composable&#10;private fun SingleMonthCalendarChart(&#10;    modifier: Modifier = Modifier,&#10;    entries: List&lt;CalendarEntry&gt;,&#10;    yearMonth: YearMonth = YearMonth.now(),&#10;    maxBubbleSize: Float = 24f,&#10;    minBubbleSize: Float = 6f,&#10;    defaultColor: Color = MaterialTheme.colorScheme.primary,&#10;    showGrid: Boolean = true,&#10;    width: Dp = Dp.Unspecified,&#10;    height: Dp = 350.dp&#10;) {&#10;    val maxValue = entries.maxOfOrNull { it.value } ?: 1f&#10;    val entriesByDate = entries.associateBy { it.date }&#10;&#10;    // 요일 배열 생성&#10;    val dayOfWeeks = DayOfWeek.values()&#10;&#10;    // 캘린더 정보 계산&#10;    val (firstDayOfWeek, totalDays, weeks) = ChartMath.Calendar.computeCalendarMetrics(yearMonth)&#10;&#10;    // width가 지정된 경우 적용하고, 없으면 fillMaxWidth 사용&#10;    val columnModifier = if (width != Dp.Unspecified) {&#10;        modifier.width(width).height(height)&#10;    } else {&#10;        modifier.fillMaxWidth().height(height)&#10;    }&#10;&#10;    Column(modifier = columnModifier) {&#10;        // Compose UI 부분은 그대로 유지하고 Canvas 그리기 로직만 분리&#10;        Text(&#10;            text = yearMonth.month.getDisplayName(TextStyle.FULL_STANDALONE, Locale.getDefault()) + &quot; &quot; + yearMonth.year,&#10;            style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold),&#10;            modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        // 요일 헤더&#10;        Row(modifier = Modifier.fillMaxWidth()) {&#10;            dayOfWeeks.forEach { dayOfWeek -&gt;&#10;                Text(&#10;                    text = dayOfWeek.getDisplayName(TextStyle.SHORT, Locale.getDefault()),&#10;                    modifier = Modifier.weight(1f),&#10;                    textAlign = TextAlign.Center,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {&#10;                        MaterialTheme.colorScheme.secondary&#10;                    } else {&#10;                        MaterialTheme.colorScheme.onBackground&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // 캘린더 그리드&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Canvas로 달력 그리드와 데이터 표시&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val cellWidth = size.width / 7f&#10;                val cellHeight = size.height / weeks&#10;&#10;                // 그리드 그리기&#10;                if (showGrid) {&#10;                    ChartDraw.Calendar.drawCalendarGrid(&#10;                        drawScope = this,&#10;                        cellWidth = cellWidth,&#10;                        cellHeight = cellHeight,&#10;                        rows = weeks,&#10;                        startX = 0f,&#10;                        startY = 0f&#10;                    )&#10;                }&#10;&#10;                // 날짜와 데이터 포인트 그리기&#10;                for (week in 0 until weeks) {&#10;                    for (day in 0 until 7) {&#10;                        val dayOfMonth = week * 7 + day - firstDayOfWeek + 1&#10;&#10;                        if (dayOfMonth in 1..totalDays) {&#10;                            val currentDate = yearMonth.atDay(dayOfMonth)&#10;                            val isWeekend = day == 0 || day == 6&#10;&#10;                            // 날짜 텍스트 위치&#10;                            val x = cellWidth * (day + 0.5f)&#10;                            val y = cellHeight * week + 20f&#10;&#10;                            // 날짜 텍스트 그리기&#10;                            ChartDraw.Calendar.drawCalendarDay(&#10;                                ctx = drawContext,&#10;                                day = dayOfMonth,&#10;                                x = x,&#10;                                y = y,&#10;                                isWeekend = isWeekend,&#10;                                textColor = Color.Black.toArgb(),&#10;                            )&#10;&#10;                            // 데이터가 있으면 원 그리기&#10;                            val entry = entriesByDate[currentDate]&#10;                            entry?.let { dataEntry -&gt;&#10;                                // 원 크기 계산&#10;                                val bubbleRadius = ChartMath.Calendar.calculateBubbleSize(&#10;                                    value = dataEntry.value,&#10;                                    maxValue = maxValue,&#10;                                    minSize = minBubbleSize,&#10;                                    maxSize = maxBubbleSize&#10;                                )&#10;&#10;                                // 원 위치 (날짜 아래)&#10;                                val bubbleX = x&#10;                                val bubbleY = y + 25f&#10;&#10;                                // 원 그리기&#10;                                ChartDraw.Calendar.drawCalendarDataPoint(&#10;                                    drawScope = this,&#10;                                    x = bubbleX,&#10;                                    y = bubbleY,&#10;                                    radius = bubbleRadius,&#10;                                    color = dataEntry.color ?: defaultColor&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 여러 월을 표시하는 캘린더 차트&#10; *&#10; * @param modifier 커스텀 modifier&#10; * @param entries 표시할 데이터 리스트&#10; * @param startYearMonth 시작 년월 (기본값: 현재 년월)&#10; * @param months 표시할 월 수&#10; * @param maxBubbleSize 최대 원 크기&#10; * @param minBubbleSize 최소 원 크기&#10; * @param defaultColor 기본 색상&#10; * @param showGrid 그리드 표시 여부&#10; * @param width 캘린더 너비&#10; * @param height 캘린더 높이&#10; * @param showMonthIndicator 월 인디케이터 표시 여부&#10; * @param onMonthChanged 월 변경 이벤트 콜백&#10; */&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun MultiMonthCalendarChart(&#10;    modifier: Modifier = Modifier,&#10;    entries: List&lt;CalendarEntry&gt;,&#10;    startYearMonth: YearMonth = YearMonth.now(),&#10;    months: Int = 12,&#10;    maxBubbleSize: Float = 24f,&#10;    minBubbleSize: Float = 6f,&#10;    defaultColor: Color = MaterialTheme.colorScheme.primary,&#10;    showGrid: Boolean = true,&#10;    width: Dp = Dp.Unspecified,&#10;    height: Dp = 350.dp,&#10;    showMonthIndicator: Boolean = true,&#10;    onMonthChanged: ((YearMonth) -&gt; Unit)? = null&#10;) {&#10;    require(months &gt; 0) { &quot;표시할 월 수는 최소 1 이상이어야 합니다.&quot; }&#10;&#10;    // 모든 월 생성&#10;    val yearMonths = remember(startYearMonth, months) {&#10;        (0 until months).map { startYearMonth.plusMonths(it.toLong()) }&#10;    }&#10;&#10;    // 페이저 상태 관리&#10;    val pagerState = rememberPagerState(pageCount = { months })&#10;&#10;    // 코루틴 스코프를 상위 컴포저블에서 선언&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // 현재 월 변경 감지하여 콜백 호출&#10;    val currentYearMonth = yearMonths[pagerState.currentPage]&#10;    LaunchedEffect(pagerState.currentPage) {&#10;        onMonthChanged?.invoke(currentYearMonth)&#10;    }&#10;&#10;    // width가 지정된 경우 적용하고, 없으면 fillMaxWidth 사용&#10;    val columnModifier = if (width != Dp.Unspecified) {&#10;        modifier.width(width)&#10;    } else {&#10;        modifier&#10;    }&#10;&#10;    Column(modifier = columnModifier) {&#10;        // 월 인디케이터 표시 (상단에 배치)&#10;        if (showMonthIndicator &amp;&amp; months &gt; 1) {&#10;            MonthIndicator(&#10;                yearMonths = yearMonths,&#10;                currentIndex = pagerState.currentPage,&#10;                onSelectMonth = { index -&gt;&#10;                    // 미리 선언된 코루틴 스코프 사용&#10;                    coroutineScope.launch {&#10;                        pagerState.animateScrollToPage(index)&#10;                    }&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;        }&#10;&#10;        // 수평 페이저로 스와이프 가능한 캘린더 구현&#10;        val pagerHeight = height - if (showMonthIndicator &amp;&amp; months &gt; 1) 50.dp else 0.dp&#10;&#10;        HorizontalPager(&#10;            state = pagerState,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(pagerHeight)&#10;        ) { page -&gt;&#10;            val yearMonth = yearMonths[page]&#10;            val monthEntries = entries.filter {&#10;                it.date.year == yearMonth.year &amp;&amp; it.date.monthValue == yearMonth.monthValue&#10;            }&#10;&#10;            // 개별 월 캘린더 표시&#10;            SingleMonthCalendarChart(&#10;                entries = monthEntries,&#10;                yearMonth = yearMonth,&#10;                maxBubbleSize = maxBubbleSize,&#10;                minBubbleSize = minBubbleSize,&#10;                defaultColor = defaultColor,&#10;                showGrid = showGrid,&#10;                width = width,&#10;                height = pagerHeight&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 월별 인디케이터 (현재 월 표시)&#10; */&#10;@Composable&#10;private fun MonthIndicator(&#10;    yearMonths: List&lt;YearMonth&gt;,&#10;    currentIndex: Int,&#10;    onSelectMonth: (Int) -&gt; Unit&#10;) {&#10;    LazyRow(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 8.dp),&#10;        horizontalArrangement = Arrangement.Center&#10;    ) {&#10;        items(yearMonths.size) { index -&gt;&#10;            val yearMonth = yearMonths[index]&#10;            val isSelected = index == currentIndex&#10;&#10;            Text(&#10;                text = &quot;${yearMonth.month.getDisplayName(TextStyle.SHORT, Locale.getDefault())} ${yearMonth.year}&quot;,&#10;                modifier = Modifier&#10;                    .padding(horizontal = 8.dp)&#10;                    .clickable { onSelectMonth(index) },&#10;                color = if (isSelected)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f),&#10;                fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.pager.HorizontalPager&#10;import androidx.compose.foundation.pager.rememberPagerState&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import java.time.DayOfWeek&#10;import java.time.LocalDate&#10;import java.time.YearMonth&#10;import java.time.format.TextStyle&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import kotlinx.coroutines.launch&#10;import java.util.*&#10;&#10;/**&#10; * 캘린더 차트에 표시할 데이터 모델&#10; */&#10;data class CalendarEntry(&#10;    val date: LocalDate,&#10;    val value: Float,&#10;    val color: Color? = null&#10;)&#10;&#10;/**&#10; * 캘린더 차트를 표시하는 Composable 함수&#10; * 만약 entries의 날짜가 2달 이상이면 자동으로 MultiMonthCalendarChart로 전환됩니다.&#10; */&#10;@Composable&#10;fun CalendarChart(&#10;    modifier: Modifier = Modifier,&#10;    entries: List&lt;CalendarEntry&gt;,&#10;    yearMonth: YearMonth = YearMonth.now(),&#10;    maxBubbleSize: Float = 24f,&#10;    minBubbleSize: Float = 6f,&#10;    defaultColor: Color = MaterialTheme.colorScheme.primary,&#10;    showGrid: Boolean = true,&#10;    width: Dp = Dp.Unspecified,  // 너비 파라미터 추가&#10;    height: Dp = 350.dp,         // height 파라미터 타입을 Dp로 변경&#10;    onMonthChanged: ((YearMonth) -&gt; Unit)? = null,&#10;    chartType: ChartType = ChartType.CALENDAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    // 2달 이상의 데이터가 있는지 확인&#10;    val distinctMonths = entries.map { YearMonth.of(it.date.year, it.date.month) }.distinct()&#10;    val hasMultipleMonths = distinctMonths.size &gt; 1&#10;&#10;    if (hasMultipleMonths) {&#10;        // 2달 이상의 데이터가 있으면 MultiMonthCalendarChart 사용&#10;        val startMonth = distinctMonths.minOrNull() ?: yearMonth&#10;        val months = distinctMonths.size&#10;&#10;        MultiMonthCalendarChart(&#10;            modifier = modifier,&#10;            entries = entries,&#10;            startYearMonth = startMonth,&#10;            months = months,&#10;            maxBubbleSize = maxBubbleSize,&#10;            minBubbleSize = minBubbleSize,&#10;            defaultColor = defaultColor,&#10;            showGrid = showGrid,&#10;            width = width,           // 추가된 width 파라미터 전달&#10;            height = height,         // 변경된 height 파라미터 타입 적용&#10;            onMonthChanged = onMonthChanged&#10;        )&#10;    } else {&#10;        // 단일 월 데이터만 있으면 기존 CalendarChart 로직 사용&#10;        SingleMonthCalendarChart(&#10;            modifier = modifier,&#10;            entries = entries,&#10;            yearMonth = yearMonth,&#10;            maxBubbleSize = maxBubbleSize,&#10;            minBubbleSize = minBubbleSize,&#10;            defaultColor = defaultColor,&#10;            showGrid = showGrid,&#10;            width = width,           // 추가된 width 파라미터 전달&#10;            height = height          // 변경된 height 파라미터 타입 적용&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 단일 월을 표시하는 캘린더 차트 (기존 CalendarChart 로직)&#10; */&#10;@Composable&#10;private fun SingleMonthCalendarChart(&#10;    modifier: Modifier = Modifier,&#10;    entries: List&lt;CalendarEntry&gt;,&#10;    yearMonth: YearMonth = YearMonth.now(),&#10;    maxBubbleSize: Float = 24f,&#10;    minBubbleSize: Float = 6f,&#10;    defaultColor: Color = MaterialTheme.colorScheme.primary,&#10;    showGrid: Boolean = true,&#10;    width: Dp = Dp.Unspecified,&#10;    height: Dp = 350.dp&#10;) {&#10;    val maxValue = entries.maxOfOrNull { it.value } ?: 1f&#10;    val entriesByDate = entries.associateBy { it.date }&#10;&#10;    // 요일 배열 생성&#10;    val dayOfWeeks = DayOfWeek.values()&#10;&#10;    // 캘린더 정보 계산&#10;    val (firstDayOfWeek, totalDays, weeks) = ChartMath.Calendar.computeCalendarMetrics(yearMonth)&#10;&#10;    // width가 지정된 경우 적용하고, 없으면 fillMaxWidth 사용&#10;    val columnModifier = if (width != Dp.Unspecified) {&#10;        modifier.width(width).height(height)&#10;    } else {&#10;        modifier.fillMaxWidth().height(height)&#10;    }&#10;&#10;    Column(modifier = columnModifier) {&#10;        // Compose UI 부분은 그대로 유지하고 Canvas 그리기 로직만 분리&#10;        Text(&#10;            text = yearMonth.month.getDisplayName(TextStyle.FULL_STANDALONE, Locale.getDefault()) + &quot; &quot; + yearMonth.year,&#10;            style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold),&#10;            modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        // 요일 헤더&#10;        Row(modifier = Modifier.fillMaxWidth()) {&#10;            dayOfWeeks.forEach { dayOfWeek -&gt;&#10;                Text(&#10;                    text = dayOfWeek.getDisplayName(TextStyle.SHORT, Locale.getDefault()),&#10;                    modifier = Modifier.weight(1f),&#10;                    textAlign = TextAlign.Center,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {&#10;                        MaterialTheme.colorScheme.secondary&#10;                    } else {&#10;                        MaterialTheme.colorScheme.onBackground&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // 캘린더 그리드&#10;        Box(modifier = Modifier.fillMaxSize()) {&#10;            // Canvas로 달력 그리드와 데이터 표시&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val cellWidth = size.width / 7f&#10;                val cellHeight = size.height / weeks&#10;&#10;                // 그리드 그리기&#10;                if (showGrid) {&#10;                    ChartDraw.Calendar.drawCalendarGrid(&#10;                        drawScope = this,&#10;                        cellWidth = cellWidth,&#10;                        cellHeight = cellHeight,&#10;                        rows = weeks,&#10;                        startX = 0f,&#10;                        startY = 0f&#10;                    )&#10;                }&#10;&#10;                // 날짜와 데이터 포인트 그리기&#10;                for (week in 0 until weeks) {&#10;                    for (day in 0 until 7) {&#10;                        val dayOfMonth = week * 7 + day - firstDayOfWeek + 1&#10;&#10;                        if (dayOfMonth in 1..totalDays) {&#10;                            val currentDate = yearMonth.atDay(dayOfMonth)&#10;                            val isWeekend = day == 0 || day == 6&#10;&#10;                            // 날짜 텍스트 위치&#10;                            val x = cellWidth * (day + 0.5f)&#10;                            val y = cellHeight * week + 20f&#10;&#10;                            // 날짜 텍스트 그리기&#10;                            ChartDraw.Calendar.drawCalendarDay(&#10;                                ctx = drawContext,&#10;                                day = dayOfMonth,&#10;                                x = x,&#10;                                y = y,&#10;                                isWeekend = isWeekend,&#10;                                textColor = Color.Black.toArgb(),&#10;                            )&#10;&#10;                            // 데이터가 있으면 원 그리기&#10;                            val entry = entriesByDate[currentDate]&#10;                            entry?.let { dataEntry -&gt;&#10;                                // 원 크기 계산&#10;                                val bubbleRadius = ChartMath.Calendar.calculateBubbleSize(&#10;                                    value = dataEntry.value,&#10;                                    maxValue = maxValue,&#10;                                    minSize = minBubbleSize,&#10;                                    maxSize = maxBubbleSize&#10;                                )&#10;&#10;                                // 원 위치 (날짜 아래)&#10;                                val bubbleX = x&#10;                                val bubbleY = y + 25f&#10;&#10;                                // 원 그리기&#10;                                ChartDraw.Calendar.drawCalendarDataPoint(&#10;                                    drawScope = this,&#10;                                    x = bubbleX,&#10;                                    y = bubbleY,&#10;                                    radius = bubbleRadius,&#10;                                    color = dataEntry.color ?: defaultColor&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 여러 월을 표시하는 캘린더 차트&#10; *&#10; * @param modifier 커스텀 modifier&#10; * @param entries 표시할 데이터 리스트&#10; * @param startYearMonth 시작 년월 (기본값: 현재 년월)&#10; * @param months 표시할 월 수&#10; * @param maxBubbleSize 최대 원 크기&#10; * @param minBubbleSize 최소 원 크기&#10; * @param defaultColor 기본 색상&#10; * @param showGrid 그리드 표시 여부&#10; * @param width 캘린더 너비&#10; * @param height 캘린더 높이&#10; * @param showMonthIndicator 월 인디케이터 표시 여부&#10; * @param onMonthChanged 월 변경 이벤트 콜백&#10; */&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun MultiMonthCalendarChart(&#10;    modifier: Modifier = Modifier,&#10;    entries: List&lt;CalendarEntry&gt;,&#10;    startYearMonth: YearMonth = YearMonth.now(),&#10;    months: Int = 12,&#10;    maxBubbleSize: Float = 24f,&#10;    minBubbleSize: Float = 6f,&#10;    defaultColor: Color = MaterialTheme.colorScheme.primary,&#10;    showGrid: Boolean = true,&#10;    width: Dp = Dp.Unspecified,&#10;    height: Dp = 350.dp,&#10;    showMonthIndicator: Boolean = true,&#10;    onMonthChanged: ((YearMonth) -&gt; Unit)? = null&#10;) {&#10;    require(months &gt; 0) { &quot;표시할 월 수는 최소 1 이상이어야 합니다.&quot; }&#10;&#10;    // 모든 월 생성&#10;    val yearMonths = remember(startYearMonth, months) {&#10;        (0 until months).map { startYearMonth.plusMonths(it.toLong()) }&#10;    }&#10;&#10;    // 페이저 상태 관리&#10;    val pagerState = rememberPagerState(pageCount = { months })&#10;&#10;    // 코루틴 스코프를 상위 컴포저블에서 선언&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // 현재 월 변경 감지하여 콜백 호출&#10;    val currentYearMonth = yearMonths[pagerState.currentPage]&#10;    LaunchedEffect(pagerState.currentPage) {&#10;        onMonthChanged?.invoke(currentYearMonth)&#10;    }&#10;&#10;    // width가 지정된 경우 적용하고, 없으면 fillMaxWidth 사용&#10;    val columnModifier = if (width != Dp.Unspecified) {&#10;        modifier.width(width)&#10;    } else {&#10;        modifier&#10;    }&#10;&#10;    Column(modifier = columnModifier) {&#10;        // 월 인디케이터 표시 (상단에 배치)&#10;        if (showMonthIndicator &amp;&amp; months &gt; 1) {&#10;            MonthIndicator(&#10;                yearMonths = yearMonths,&#10;                currentIndex = pagerState.currentPage,&#10;                onSelectMonth = { index -&gt;&#10;                    // 미리 선언된 코루틴 스코프 사용&#10;                    coroutineScope.launch {&#10;                        pagerState.animateScrollToPage(index)&#10;                    }&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;        }&#10;&#10;        // 수평 페이저로 스와이프 가능한 캘린더 구현&#10;        val pagerHeight = height - if (showMonthIndicator &amp;&amp; months &gt; 1) 50.dp else 0.dp&#10;&#10;        HorizontalPager(&#10;            state = pagerState,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(pagerHeight)&#10;        ) { page -&gt;&#10;            val yearMonth = yearMonths[page]&#10;            val monthEntries = entries.filter {&#10;                it.date.year == yearMonth.year &amp;&amp; it.date.monthValue == yearMonth.monthValue&#10;            }&#10;&#10;            // 개별 월 캘린더 표시&#10;            SingleMonthCalendarChart(&#10;                entries = monthEntries,&#10;                yearMonth = yearMonth,&#10;                maxBubbleSize = maxBubbleSize,&#10;                minBubbleSize = minBubbleSize,&#10;                defaultColor = defaultColor,&#10;                showGrid = showGrid,&#10;                width = width,&#10;                height = pagerHeight&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 월별 인디케이터 (현재 월 표시)&#10; */&#10;@Composable&#10;private fun MonthIndicator(&#10;    yearMonths: List&lt;YearMonth&gt;,&#10;    currentIndex: Int,&#10;    onSelectMonth: (Int) -&gt; Unit&#10;) {&#10;    LazyRow(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 8.dp),&#10;        horizontalArrangement = Arrangement.Center&#10;    ) {&#10;        items(yearMonths.size) { index -&gt;&#10;            val yearMonth = yearMonths[index]&#10;            val isSelected = index == currentIndex&#10;&#10;            Text(&#10;                text = &quot;${yearMonth.month.getDisplayName(TextStyle.SHORT, Locale.getDefault())} ${yearMonth.year}&quot;,&#10;                modifier = Modifier&#10;                    .padding(horizontal = 8.dp)&#10;                    .clickable { onSelectMonth(index) },&#10;                color = if (isSelected)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f),&#10;                fontWeight = if (isSelected) FontWeight.Bold else FontWeight.Normal&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/LineChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/LineChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun LineChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,      // ChartPoint 기반&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Line Chart Example&quot;,&#10;    lineColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    width: Dp = 250.dp,&#10;    height: Dp = 250.dp,&#10;    strokeWidth: Float = 4f,&#10;    labelTextSize: Float = 28f,&#10;    tooltipTextSize: Float = 32f,&#10;    interactionType: InteractionType = InteractionType.POINT,&#10;    chartType : ChartType = ChartType.LINE // 차트 타입 (툴팁 위치 결정용&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.x }&#10;    val yValues = data.map { it.y }&#10;&#10;    var canvasPoints by remember { mutableStateOf(listOf&lt;androidx.compose.ui.geometry.Offset&gt;()) }&#10;    var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;&#10;    var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height)&#10;        ) {&#10;            Canvas(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;&#10;                val metrics = ChartMath.computeMetrics(size, yValues)&#10;                val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;                // 포인트 위치와 캔버스 크기를 상태 변수에 저장&#10;                canvasPoints = points&#10;                canvasSize = size&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.Line.drawLine(this, points, lineColor, strokeWidth)&#10;                ChartDraw.Line.drawXAxisLabels(&#10;                    ctx = drawContext,&#10;                    labels = xLabels.map { it.toString() },&#10;                    metrics = metrics,&#10;                    textSize = labelTextSize&#10;                )&#10;            }&#10;&#10;            // Conditional interaction based on interactionType parameter&#10;            when (interactionType) {&#10;                InteractionType.NEAR_X_AXIS -&gt; {&#10;                    // BarMarker interactions (invisible bars for easier touching)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            values = yValues,&#10;                            metrics = metrics,&#10;                            color = Color.Transparent,&#10;                            barWidthRatio = 1.0f,&#10;                            useFullHeight = true,&#10;                            interactive = true,&#10;                            useLineChartPositioning = true,&#10;                            onBarClick = { index, value -&gt;&#10;                                // Handle bar click - same logic as point click&#10;                                selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                            },&#10;                            chartType = chartType&#10;                        )&#10;                    }&#10;                }&#10;                InteractionType.POINT -&gt; {&#10;                    // PointMarker interactions&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        points = canvasPoints,&#10;                        values = yValues.map { it.toInt().toString() },&#10;                        selectedPointIndex = selectedPointIndex,&#10;                        onPointClick = { index -&gt;&#10;                            // 이미 선택된 포인트를 다시 클릭하면 선택 해제(null로 설정)&#10;                            selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                        },&#10;                        chartType = chartType&#10;                    )&#10;                }&#10;                else -&gt; {&#10;                    // 기본적으로 포인트 마커 사용&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        points = canvasPoints,&#10;                        values = yValues.map { it.toInt().toString() },&#10;                        selectedPointIndex = selectedPointIndex,&#10;                        onPointClick = { index -&gt;&#10;                            // 이미 선택된 포인트를 다시 클릭하면 선택 해제(null로 설정)&#10;                            selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                        },&#10;                        chartType = chartType&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun LineChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,      // ChartPoint 기반&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Line Chart Example&quot;,&#10;    lineColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    width: Dp = 250.dp,&#10;    height: Dp = 250.dp,&#10;    strokeWidth: Float = 4f,&#10;    labelTextSize: Float = 28f,&#10;    tooltipTextSize: Float = 32f,&#10;    interactionType: InteractionType = InteractionType.POINT,&#10;    chartType : ChartType = ChartType.LINE // 차트 타입 (툴팁 위치 결정용&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.x }&#10;    val yValues = data.map { it.y }&#10;&#10;    var canvasPoints by remember { mutableStateOf(listOf&lt;androidx.compose.ui.geometry.Offset&gt;()) }&#10;    var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;&#10;    var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height)&#10;        ) {&#10;            Canvas(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;&#10;                val metrics = ChartMath.computeMetrics(size, yValues)&#10;                val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;                // 포인트 위치와 캔버스 크기를 상태 변수에 저장&#10;                canvasPoints = points&#10;                canvasSize = size&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.Line.drawLine(this, points, lineColor, strokeWidth)&#10;                ChartDraw.Line.drawXAxisLabels(&#10;                    ctx = drawContext,&#10;                    labels = xLabels.map { it.toString() },&#10;                    metrics = metrics,&#10;                    textSize = labelTextSize&#10;                )&#10;            }&#10;&#10;            // Conditional interaction based on interactionType parameter&#10;            when (interactionType) {&#10;                InteractionType.NEAR_X_AXIS -&gt; {&#10;                    // BarMarker interactions (invisible bars for easier touching)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            values = yValues,&#10;                            metrics = metrics,&#10;                            color = Color.Transparent,&#10;                            barWidthRatio = 1.0f,&#10;                            useFullHeight = true,&#10;                            interactive = true,&#10;                            useLineChartPositioning = true,&#10;                            onBarClick = { index, value -&gt;&#10;                                // Handle bar click - same logic as point click&#10;                                selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                            },&#10;                            chartType = chartType&#10;                        )&#10;                    }&#10;                    &#10;                    // Always show PointMarker for visual data points (non-interactive)&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        points = canvasPoints,&#10;                        values = yValues.map { it.toInt().toString() },&#10;                        selectedPointIndex = selectedPointIndex,&#10;                        onPointClick = null, // No point interaction in this mode&#10;                        interactive = false, // Visual only, no interactions&#10;                        chartType = chartType&#10;                    )&#10;                }&#10;                InteractionType.POINT -&gt; {&#10;                    // PointMarker interactions (interactive data points)&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        points = canvasPoints,&#10;                        values = yValues.map { it.toInt().toString() },&#10;                        selectedPointIndex = selectedPointIndex,&#10;                        onPointClick = { index -&gt;&#10;                            // 이미 선택된 포인트를 다시 클릭하면 선택 해제(null로 설정)&#10;                            selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                        },&#10;                        interactive = true, // Full interaction enabled&#10;                        chartType = chartType&#10;                    )&#10;                }&#10;                else -&gt; {&#10;                    // 기본적으로 포인트 마커 사용 (interactive)&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        points = canvasPoints,&#10;                        values = yValues.map { it.toInt().toString() },&#10;                        selectedPointIndex = selectedPointIndex,&#10;                        onPointClick = { index -&gt;&#10;                            // 이미 선택된 포인트를 다시 클릭하면 선택 해제(null로 설정)&#10;                            selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                        },&#10;                        interactive = true, // Full interaction enabled&#10;                        chartType = chartType&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/MinimalLineChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/MinimalLineChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.chartDraw.LineChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;/**&#10; * 미니멀 라인 차트 (스파크라인) - 위젯이나 스마트워치 등 작은 화면용&#10; * 축, 그리드, 레이블 없이 순수 라인만 표시&#10; * &#10; * @param modifier 모디파이어&#10; * @param data 라인 차트 데이터 포인트들&#10; * @param color 라인 색상&#10; * @param width 차트 너비&#10; * @param height 차트 높이&#10; * @param strokeWidth 라인 두께&#10; * @param padding 차트 주변 패딩&#10; * @param showPoints 끝점을 원으로 표시할지 여부&#10; * @param chartType 차트 타입 (툴팁 위치 결정용)&#10; */&#10;@Composable&#10;fun MinimalLineChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    color: Color = Color.Blue,&#10;    width: Dp = 100.dp,&#10;    height: Dp = 40.dp,&#10;    strokeWidth: Float = 2f,&#10;    padding: Float = 4f,&#10;    showPoints: Boolean = false,&#10;    chartType: ChartType = ChartType.MINIMAL_LINE // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .then(&#10;                if (width != Dp.Unspecified &amp;&amp; height != Dp.Unspecified) {&#10;                    Modifier.size(width, height)&#10;                } else {&#10;                    Modifier.fillMaxSize()&#10;                }&#10;            )&#10;    ) {&#10;        Canvas(modifier = Modifier.fillMaxSize()) {&#10;            // 미니멀 차트 메트릭 계산&#10;            val metrics = ChartMath.computeMetrics(&#10;                size = size,&#10;                values = data.map { it.y },&#10;                isMinimal = true,&#10;                paddingX = padding,&#10;                paddingY = padding&#10;            )&#10;            val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;            // 라인 그리기 (포인트 표시 포함)&#10;            LineChartDraw.drawLine(this, points, color, strokeWidth)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.chartDraw.LineChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;/**&#10; * 미니멀 라인 차트 (스파크라인) - 위젯이나 스마트워치 등 작은 화면용&#10; * 축, 그리드, 레이블 없이 순수 라인만 표시&#10; * &#10; * @param modifier 모디파이어&#10; * @param data 라인 차트 데이터 포인트들&#10; * @param color 라인 색상&#10; * @param width 차트 너비&#10; * @param height 차트 높이&#10; * @param strokeWidth 라인 두께&#10; * @param padding 차트 주변 패딩&#10; * @param showPoints 끝점을 원으로 표시할지 여부&#10; * @param chartType 차트 타입 (툴팁 위치 결정용)&#10; */&#10;@Composable&#10;fun MinimalLineChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    color: Color = Color.Blue,&#10;    width: Dp = 100.dp,&#10;    height: Dp = 40.dp,&#10;    strokeWidth: Float = 2f,&#10;    padding: Float = 4f,&#10;    showPoints: Boolean = false,&#10;    chartType: ChartType = ChartType.MINIMAL_LINE // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .then(&#10;                if (width != Dp.Unspecified &amp;&amp; height != Dp.Unspecified) {&#10;                    Modifier.size(width, height)&#10;                } else {&#10;                    Modifier.fillMaxSize()&#10;                }&#10;            )&#10;    ) {&#10;        Canvas(modifier = Modifier.fillMaxSize()) {&#10;            // 미니멀 차트 메트릭 계산&#10;            val metrics = ChartMath.computeMetrics(&#10;                size = size,&#10;                values = data.map { it.y },&#10;                isMinimal = true,&#10;                paddingX = padding,&#10;                paddingY = padding&#10;            )&#10;            val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;            // 라인 그리기 (포인트 표시 포함)&#10;            LineChartDraw.drawLine(this, points, color, strokeWidth)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/MinimalRangeBarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/MinimalRangeBarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;/**&#10; * 미니멀 범위 바 차트 - 위젯이나 스마트워치 등 작은 화면용&#10; * 범위 데이터를 컨테이너 범위 내에서 표시하며, 상단에 범위 텍스트 표시&#10; * &#10; * @param modifier 모디파이어&#10; * @param data 범위 차트 데이터 (yMin, yMax 포함)&#10; * @param containerMin 컨테이너의 최소값 (전체 범위 시작)&#10; * @param containerMax 컨테이너의 최대값 (전체 범위 끝)&#10; * @param containerColor 컨테이너(배경) 바 색상&#10; * @param rangeColor 범위 바 색상&#10; * @param textColor 범위 텍스트 색상&#10; * @param width 차트 너비&#10; * @param height 차트 높이&#10; * @param padding 차트 주변 패딩&#10; * @param showRangeText 범위 텍스트를 표시할지 여부&#10; * @param cornerRadius 바의 모서리 둥글기&#10; */&#10;@Composable&#10;fun MinimalRangeBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: RangeChartPoint,&#10;    containerMin: Float,&#10;    containerMax: Float,&#10;    containerColor: Color = Color.LightGray,&#10;    rangeColor: Color = Color(0xFFFF9500),&#10;    textColor: Color = Color.Black,&#10;    width: Dp = 120.dp,&#10;    height: Dp = 50.dp,&#10;    padding: Float = 8f,&#10;    showRangeText: Boolean = true,&#10;    cornerRadius: Float = 8f,&#10;    chartType: ChartType = ChartType.MINIMAL_RANGE_BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .then(&#10;                if (width != Dp.Unspecified &amp;&amp; height != Dp.Unspecified) {&#10;                    Modifier.size(width, height)&#10;                } else {&#10;                    Modifier.fillMaxSize()&#10;                }&#10;            )&#10;    ) {&#10;        Canvas(modifier = Modifier.fillMaxSize()) {&#10;            // 범위 바 위치 계산&#10;            val result = ChartMath.Min.computeMinimalRangeBarPosition(&#10;                size = size,&#10;                rangePoint = data,&#10;                containerMin = containerMin,&#10;                containerMax = containerMax,&#10;                padding = padding&#10;            )&#10;            val (containerOffset, containerSize) = result.first&#10;            val (rangeBarOffset, rangeBarSize) = result.second&#10;            &#10;            // 범위 바 그리기&#10;            ChartDraw.Min.drawMinimalRangeBar(&#10;                drawScope = this,&#10;                containerOffset = containerOffset,&#10;                containerSize = containerSize,&#10;                rangeBarOffset = rangeBarOffset,&#10;                rangeBarSize = rangeBarSize,&#10;                containerColor = containerColor,&#10;                rangeColor = rangeColor,&#10;                cornerRadius = cornerRadius&#10;            )&#10;            &#10;            // 범위 텍스트 표시&#10;            if (showRangeText) {&#10;                val rangeText = &quot;${data.yMin.toInt()}-${data.yMax.toInt()}&quot;&#10;                &#10;                // Use the actual available text space from the math calculation&#10;                val textY = padding + 16f // Position text in the reserved space at the top&#10;                val textX = rangeBarOffset.x + (rangeBarSize.width / 2f)&#10;                &#10;                ChartDraw.Min.drawMinimalText(&#10;                    drawScope = this,&#10;                    text = rangeText,&#10;                    position = textPosition,&#10;                    color = textColor,&#10;                    textSize = 16f,&#10;                    alignment = android.graphics.Paint.Align.CENTER&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;/**&#10; * 미니멀 범위 바 차트 - 위젯이나 스마트워치 등 작은 화면용&#10; * 범위 데이터를 컨테이너 범위 내에서 표시하며, 상단에 범위 텍스트 표시&#10; * &#10; * @param modifier 모디파이어&#10; * @param data 범위 차트 데이터 (yMin, yMax 포함)&#10; * @param containerMin 컨테이너의 최소값 (전체 범위 시작)&#10; * @param containerMax 컨테이너의 최대값 (전체 범위 끝)&#10; * @param containerColor 컨테이너(배경) 바 색상&#10; * @param rangeColor 범위 바 색상&#10; * @param textColor 범위 텍스트 색상&#10; * @param width 차트 너비&#10; * @param height 차트 높이&#10; * @param padding 차트 주변 패딩&#10; * @param showRangeText 범위 텍스트를 표시할지 여부&#10; * @param cornerRadius 바의 모서리 둥글기&#10; */&#10;@Composable&#10;fun MinimalRangeBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: RangeChartPoint,&#10;    containerMin: Float,&#10;    containerMax: Float,&#10;    containerColor: Color = Color.LightGray,&#10;    rangeColor: Color = Color(0xFFFF9500),&#10;    textColor: Color = Color.Black,&#10;    width: Dp = 120.dp,&#10;    height: Dp = 50.dp,&#10;    padding: Float = 8f,&#10;    showRangeText: Boolean = true,&#10;    cornerRadius: Float = 8f,&#10;    chartType: ChartType = ChartType.MINIMAL_RANGE_BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .then(&#10;                if (width != Dp.Unspecified &amp;&amp; height != Dp.Unspecified) {&#10;                    Modifier.size(width, height)&#10;                } else {&#10;                    Modifier.fillMaxSize()&#10;                }&#10;            )&#10;    ) {&#10;        Canvas(modifier = Modifier.fillMaxSize()) {&#10;            // 범위 바 위치 계산&#10;            val result = ChartMath.Min.computeMinimalRangeBarPosition(&#10;                size = size,&#10;                rangePoint = data,&#10;                containerMin = containerMin,&#10;                containerMax = containerMax,&#10;                padding = padding&#10;            )&#10;            val (containerOffset, containerSize) = result.first&#10;            val (rangeBarOffset, rangeBarSize) = result.second&#10;            &#10;            // 범위 바 그리기&#10;            ChartDraw.Min.drawMinimalRangeBar(&#10;                drawScope = this,&#10;                containerOffset = containerOffset,&#10;                containerSize = containerSize,&#10;                rangeBarOffset = rangeBarOffset,&#10;                rangeBarSize = rangeBarSize,&#10;                containerColor = containerColor,&#10;                rangeColor = rangeColor,&#10;                cornerRadius = cornerRadius&#10;            )&#10;            &#10;            // 범위 텍스트 표시&#10;            if (showRangeText) {&#10;                val rangeText = &quot;${data.yMin.toInt()}-${data.yMax.toInt()}&quot;&#10;                &#10;                // Use the actual available text space from the math calculation&#10;                val textY = padding + 16f // Position text in the reserved space at the top&#10;                val textX = rangeBarOffset.x + (rangeBarSize.width / 2f)&#10;                &#10;                // Use Compose's native text drawing instead of Android Paint&#10;                drawContext.canvas.nativeCanvas.apply {&#10;                    val paint = android.graphics.Paint().apply {&#10;                        color = textColor.value.toInt()&#10;                        textSize = 16f&#10;                        textAlign = android.graphics.Paint.Align.CENTER&#10;                        isAntiAlias = true&#10;                    }&#10;                    &#10;                    // Calculate text bounds to ensure it's within canvas&#10;                    val textBounds = android.graphics.Rect()&#10;                    paint.getTextBounds(rangeText, 0, rangeText.length, textBounds)&#10;                    &#10;                    // Ensure text doesn't go outside canvas bounds&#10;                    val adjustedY = maxOf(textBounds.height().toFloat() + padding, textY)&#10;                    val adjustedX = textX.coerceIn(textBounds.width() / 2f, size.width - textBounds.width() / 2f)&#10;                    &#10;                    drawText(rangeText, adjustedX, adjustedY, paint)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/PieChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/PieChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.ui.theme.ColorUtils&#10;&#10;/**&#10; * 파이 차트를 표시하는 컴포저블 함수입니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param data 파이 차트에 표시할 데이터 포인트 목록&#10; * @param title 차트 제목&#10; * @param isDonut 도넛 차트로 표시할지 여부 (기본값: true)&#10; * @param colors 각 조각에 사용할 색상 목록&#10; * @param showLegend 범례를 표시할지 여부&#10; * @param width 차트의 너비&#10; * @param height 차트의 높이&#10; */&#10;@Composable&#10;fun PieChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    title: String = &quot;Pie Chart Example&quot;,&#10;    isDonut: Boolean = true,&#10;    colors: List&lt;androidx.compose.ui.graphics.Color&gt; = ColorUtils.ColorUtils(data.size.coerceAtLeast(1)),&#10;    showLegend: Boolean = false,&#10;    width: Dp = 250.dp,&#10;    height: Dp = 250.dp,&#10;    chartType: ChartType = ChartType.PIE // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                // 파이 차트의 핵심 요소 그리기 (섹션 및 레이블)&#10;                val (center, radius) = ChartMath.Pie.computePieMetrics(size)&#10;                val sections = ChartMath.Pie.computePieAngles(data)&#10;&#10;                if (sections.isNotEmpty()) {&#10;                    // 각 섹션 그리기&#10;                    sections.forEachIndexed { i, (startAngle, sweepAngle, _) -&gt;&#10;                        val colorIndex = i % colors.size&#10;                        ChartDraw.Pie.drawPieSection(&#10;                            drawScope = this,&#10;                            center = center,&#10;                            radius = radius,&#10;                            startAngle = startAngle,&#10;                            sweepAngle = sweepAngle,&#10;                            color = colors[colorIndex],&#10;                            isDonut = isDonut,&#10;                            strokeWidth = 60f&#10;                        )&#10;                    }&#10;&#10;                    // 레이블 그리기&#10;                    ChartDraw.Pie.drawPieLabels(&#10;                        drawScope = this,&#10;                        center = center,&#10;                        radius = radius,&#10;                        data = data,&#10;                        sections = sections&#10;                    )&#10;&#10;                    // 범례 그리기&#10;                    if (showLegend) {&#10;                        val legendPosition = Offset(size.width, 20f)&#10;                        ChartDraw.drawChartLegend(&#10;                            drawScope = this,&#10;                            chartData = data,&#10;                            colors = colors,&#10;                            position = legendPosition,&#10;                            chartSize = size,&#10;                            itemHeight = 40f&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.ui.theme.ColorUtils&#10;&#10;/**&#10; * 파이 차트를 표시하는 컴포저블 함수입니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param data 파이 차트에 표시할 데이터 포인트 목록&#10; * @param title 차트 제목&#10; * @param isDonut 도넛 차트로 표시할지 여부 (기본값: true)&#10; * @param colors 각 조각에 사용할 색상 목록&#10; * @param showLegend 범례를 표시할지 여부&#10; * @param width 차트의 너비&#10; * @param height 차트의 높이&#10; */&#10;@Composable&#10;fun PieChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    title: String = &quot;Pie Chart Example&quot;,&#10;    isDonut: Boolean = true,&#10;    colors: List&lt;androidx.compose.ui.graphics.Color&gt; = ColorUtils.ColorUtils(data.size.coerceAtLeast(1)),&#10;    showLegend: Boolean = false,&#10;    width: Dp = 250.dp,&#10;    height: Dp = 250.dp,&#10;    chartType: ChartType = ChartType.PIE // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                // 파이 차트의 핵심 요소 그리기 (섹션 및 레이블)&#10;                val (center, radius) = ChartMath.Pie.computePieMetrics(size)&#10;                val sections = ChartMath.Pie.computePieAngles(data)&#10;&#10;                if (sections.isNotEmpty()) {&#10;                    // 각 섹션 그리기&#10;                    sections.forEachIndexed { i, (startAngle, sweepAngle, _) -&gt;&#10;                        val colorIndex = i % colors.size&#10;                        ChartDraw.Pie.drawPieSection(&#10;                            drawScope = this,&#10;                            center = center,&#10;                            radius = radius,&#10;                            startAngle = startAngle,&#10;                            sweepAngle = sweepAngle,&#10;                            color = colors[colorIndex],&#10;                            isDonut = isDonut,&#10;                            strokeWidth = 60f&#10;                        )&#10;                    }&#10;&#10;                    // 레이블 그리기&#10;                    ChartDraw.Pie.drawPieLabels(&#10;                        drawScope = this,&#10;                        center = center,&#10;                        radius = radius,&#10;                        data = data,&#10;                        sections = sections&#10;                    )&#10;&#10;                    // 범례 그리기&#10;                    if (showLegend) {&#10;                        val legendPosition = Offset(size.width, 20f)&#10;                        ChartDraw.drawChartLegend(&#10;                            drawScope = this,&#10;                            chartData = data,&#10;                            colors = colors,&#10;                            position = legendPosition,&#10;                            chartSize = size,&#10;                            itemHeight = 40f&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/ProgressChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/ProgressChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.ProgressChartPoint&#10;import com.hdil.saluschart.ui.theme.ColorUtils&#10;&#10;/**&#10; * 프로그레스 차트를 표시하는 컴포저블 함수입니다.&#10; * &#10; * @param modifier 모디파이어&#10; * @param data 프로그레스 차트에 표시할 데이터 리스트&#10; * @param title 차트 제목&#10; * @param isDonut 도넛 차트로 표시할지 여부 (true: 도넛, false: 바)&#10; * @param colors 각 프로그레스 인스턴스에 사용할 색상 목록&#10; * @param width 차트의 너비&#10; * @param height 차트의 높이&#10; * @param strokeWidth 도넛 차트의 링 두께 (도넛 모드일 때만)&#10; * @param barHeight 바 차트의 각 바 높이 (바 모드일 때만)&#10; * @param showLabels 라벨을 표시할지 여부&#10; * @param showValues 값을 표시할지 여부&#10; * @param showCenterInfo 중앙 정보를 표시할지 여부 (도넛 모드일 때만)&#10; * @param centerTitle 중앙 제목 텍스트 (도넛 모드일 때만)&#10; * @param centerSubtitle 중앙 부제목 텍스트 (도넛 모드일 때만)&#10; * @param chartType 차트 타입 (툴팁 위치 결정용)&#10; */&#10;@Composable&#10;fun ProgressChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ProgressChartPoint&gt;,&#10;    title: String = &quot;Progress Chart&quot;,&#10;    isDonut: Boolean = true,&#10;    isPercentage: Boolean = true,&#10;    colors: List&lt;Color&gt; = ColorUtils.ColorUtils(data.size.coerceAtLeast(1)),&#10;    width: Dp = 300.dp,&#10;    height: Dp = 300.dp,&#10;    strokeWidth: Float = 40f,&#10;    barHeight: Float = 30f,&#10;    showLabels: Boolean = true,&#10;    showValues: Boolean = true,&#10;    showCenterInfo: Boolean = true,&#10;    centerTitle: String = &quot;Activity&quot;,&#10;    centerSubtitle: String = &quot;Progress&quot;&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                // 프로그레스 마크 그리기 (도넛 또는 바)&#10;                ChartDraw.Progress.drawProgressMarks(&#10;                    drawScope = this,&#10;                    data = data,&#10;                    size = size,&#10;                    colors = colors,&#10;                    isDonut = isDonut,&#10;                    strokeWidth = strokeWidth,&#10;                    barHeight = barHeight&#10;                )&#10;                &#10;                // 중앙 정보 표시 (도넛 모드일 때만)&#10;                if (isDonut &amp;&amp; showCenterInfo) {&#10;                    val center = androidx.compose.ui.geometry.Offset(size.width / 2f, size.height / 2f)&#10;                    ChartDraw.Progress.drawProgressCenterInfo(&#10;                        drawScope = this,&#10;                        center = center,&#10;                        title = centerTitle,&#10;                        subtitle = centerSubtitle&#10;                    )&#10;                }&#10;                &#10;                // 라벨 표시&#10;                if (showLabels) {&#10;                    ChartDraw.Progress.drawProgressLabels(&#10;                        drawScope = this,&#10;                        data = data,&#10;                        size = size,&#10;                        isDonut = isDonut,&#10;                        strokeWidth = strokeWidth,&#10;                        barHeight = barHeight&#10;                    )&#10;                }&#10;                &#10;                // 값 표시&#10;                if (showValues) {&#10;                    ChartDraw.Progress.drawProgressValues(&#10;                        drawScope = this,&#10;                        data = data,&#10;                        size = size,&#10;                        isDonut = isDonut,&#10;                        strokeWidth = strokeWidth,&#10;                        barHeight = barHeight,&#10;                        isPercentage = isPercentage&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.ProgressChartPoint&#10;import com.hdil.saluschart.ui.theme.ColorUtils&#10;&#10;/**&#10; * 프로그레스 차트를 표시하는 컴포저블 함수입니다.&#10; * &#10; * @param modifier 모디파이어&#10; * @param data 프로그레스 차트에 표시할 데이터 리스트&#10; * @param title 차트 제목&#10; * @param isDonut 도넛 차트로 표시할지 여부 (true: 도넛, false: 바)&#10; * @param colors 각 프로그레스 인스턴스에 사용할 색상 목록&#10; * @param width 차트의 너비&#10; * @param height 차트의 높이&#10; * @param strokeWidth 도넛 차트의 링 두께 (도넛 모드일 때만)&#10; * @param barHeight 바 차트의 각 바 높이 (바 모드일 때만)&#10; * @param showLabels 라벨을 표시할지 여부&#10; * @param showValues 값을 표시할지 여부&#10; * @param showCenterInfo 중앙 정보를 표시할지 여부 (도넛 모드일 때만)&#10; * @param centerTitle 중앙 제목 텍스트 (도넛 모드일 때만)&#10; * @param centerSubtitle 중앙 부제목 텍스트 (도넛 모드일 때만)&#10; * @param chartType 차트 타입 (툴팁 위치 결정용)&#10; */&#10;@Composable&#10;fun ProgressChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ProgressChartPoint&gt;,&#10;    title: String = &quot;Progress Chart&quot;,&#10;    isDonut: Boolean = true,&#10;    isPercentage: Boolean = true,&#10;    colors: List&lt;Color&gt; = ColorUtils.ColorUtils(data.size.coerceAtLeast(1)),&#10;    width: Dp = 300.dp,&#10;    height: Dp = 300.dp,&#10;    strokeWidth: Float = 40f,&#10;    barHeight: Float = 30f,&#10;    showLabels: Boolean = true,&#10;    showValues: Boolean = true,&#10;    showCenterInfo: Boolean = true,&#10;    centerTitle: String = &quot;Activity&quot;,&#10;    centerSubtitle: String = &quot;Progress&quot;&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                // 프로그레스 마크 그리기 (도넛 또는 바)&#10;                ChartDraw.Progress.drawProgressMarks(&#10;                    drawScope = this,&#10;                    data = data,&#10;                    size = size,&#10;                    colors = colors,&#10;                    isDonut = isDonut,&#10;                    strokeWidth = strokeWidth,&#10;                    barHeight = barHeight&#10;                )&#10;                &#10;                // 중앙 정보 표시 (도넛 모드일 때만)&#10;                if (isDonut &amp;&amp; showCenterInfo) {&#10;                    val center = androidx.compose.ui.geometry.Offset(size.width / 2f, size.height / 2f)&#10;                    ChartDraw.Progress.drawProgressCenterInfo(&#10;                        drawScope = this,&#10;                        center = center,&#10;                        title = centerTitle,&#10;                        subtitle = centerSubtitle&#10;                    )&#10;                }&#10;                &#10;                // 라벨 표시&#10;                if (showLabels) {&#10;                    ChartDraw.Progress.drawProgressLabels(&#10;                        drawScope = this,&#10;                        data = data,&#10;                        size = size,&#10;                        isDonut = isDonut,&#10;                        strokeWidth = strokeWidth,&#10;                        barHeight = barHeight&#10;                    )&#10;                }&#10;                &#10;                // 값 표시&#10;                if (showValues) {&#10;                    ChartDraw.Progress.drawProgressValues(&#10;                        drawScope = this,&#10;                        data = data,&#10;                        size = size,&#10;                        isDonut = isDonut,&#10;                        strokeWidth = strokeWidth,&#10;                        barHeight = barHeight,&#10;                        isPercentage = isPercentage&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/RangeBarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/RangeBarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun RangeBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;RangeChartPoint&gt;,&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;, &#10;    title: String = &quot;Range Bar Chart&quot;,&#10;    barColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    width: Dp = 250.dp,&#10;    height: Dp = 250.dp,&#10;    barWidthRatio: Float = 0.6f,&#10;    chartType: ChartType = ChartType.RANGE_BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;    &#10;    val labels = data.map { it.label ?: it.x.toString() }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height)&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val metrics = ChartMath.RangeBar.computeRangeMetrics(size, data)&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.drawYAxis(this, metrics)&#10;                ChartDraw.RangeBar.drawRangeBars(this, data, metrics, barColor, barWidthRatio)&#10;                ChartDraw.Bar.drawBarXAxisLabels(drawContext, labels, metrics)&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun RangeBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;RangeChartPoint&gt;,&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;, &#10;    title: String = &quot;Range Bar Chart&quot;,&#10;    barColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    width: Dp = 250.dp,&#10;    height: Dp = 250.dp,&#10;    barWidthRatio: Float = 0.6f,&#10;    chartType: ChartType = ChartType.RANGE_BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;    &#10;    val labels = data.map { it.label ?: it.x.toString() }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height)&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val metrics = ChartMath.RangeBar.computeRangeMetrics(size, data)&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.drawYAxis(this, metrics)&#10;                ChartDraw.RangeBar.drawRangeBars(this, data, metrics, barColor, barWidthRatio)&#10;                ChartDraw.Bar.drawBarXAxisLabels(drawContext, labels, metrics)&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/StackedBarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/StackedBarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;&#10;/**&#10; * 스택 바 차트 컴포저블 (건강 데이터 시각화에 최적화)&#10; * &#10; * 영양소 섭취량, 운동 시간 등 여러 구성 요소를 가진 데이터를 시각화할 때 사용합니다.&#10; * 예: 일별 영양소 섭취량 (단백질, 지방, 탄수화물)&#10; * &#10; * @param modifier 커스텀 modifier&#10; * @param data 스택 차트 데이터 포인트 목록&#10; * @param segmentLabels 각 세그먼트의 레이블들 (예: [&quot;단백질&quot;, &quot;지방&quot;, &quot;탄수화물&quot;])&#10; * @param xLabel X축 레이블 (예: &quot;날짜&quot;)&#10; * @param yLabel Y축 레이블 (예: &quot;영양소 (g)&quot;)&#10; * @param title 차트 제목&#10; * @param colors 각 세그먼트의 색상 팔레트 (건강 데이터에 적합한 기본 색상 제공)&#10; * @param width 차트 너비&#10; * @param height 차트 높이&#10; * @param barWidthRatio 바 너비 비율 (0.0 ~ 1.0)&#10; * @param showLegend 범례 표시 여부&#10; */&#10;@Composable&#10;fun StackedBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;StackedChartPoint&gt;,&#10;    segmentLabels: List&lt;String&gt; = emptyList(),&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Stacked Bar Chart&quot;,&#10;    colors: List&lt;Color&gt; = listOf(&#10;        Color(0xFF2196F3), // 파랑 (단백질)&#10;        Color(0xFFFF9800), // 주황 (지방)&#10;        Color(0xFF4CAF50), // 초록 (탄수화물)&#10;        Color(0xFF9C27B0), // 보라 (기타)&#10;        Color(0xFFE91E63), // 분홍&#10;        Color(0xFFFFEB3B), // 노랑&#10;    ),&#10;    width: Dp = 300.dp,&#10;    height: Dp = 300.dp,&#10;    barWidthRatio: Float = 0.6f,&#10;    showLegend: Boolean = true,&#10;    chartType: ChartType = ChartType.STACKED_BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.label ?: it.x.toString() }&#10;    &#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height)&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val totalValues = data.map { it.total }&#10;                val metrics = ChartMath.computeMetrics(size, totalValues, chartType = ChartType.STACKED_BAR)&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.Bar.drawStackedBars(this, data, metrics, colors, barWidthRatio)&#10;                ChartDraw.drawXAxis(this, metrics)&#10;                ChartDraw.drawYAxis(this, metrics)&#10;                ChartDraw.Bar.drawBarXAxisLabels(drawContext, xLabels, metrics)&#10;                &#10;                // 범례 그리기 (통합된 범례 시스템 사용)&#10;                if (showLegend &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    val legendPosition = Offset(size.width, 20f)&#10;                    ChartDraw.drawChartLegend(&#10;                        drawScope = this,&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = legendPosition,&#10;                        chartSize = size,&#10;                        title = null, &#10;                        itemHeight = 18f&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;&#10;/**&#10; * 스택 바 차트 컴포저블 (건강 데이터 시각화에 최적화)&#10; * &#10; * 영양소 섭취량, 운동 시간 등 여러 구성 요소를 가진 데이터를 시각화할 때 사용합니다.&#10; * 예: 일별 영양소 섭취량 (단백질, 지방, 탄수화물)&#10; * &#10; * @param modifier 커스텀 modifier&#10; * @param data 스택 차트 데이터 포인트 목록&#10; * @param segmentLabels 각 세그먼트의 레이블들 (예: [&quot;단백질&quot;, &quot;지방&quot;, &quot;탄수화물&quot;])&#10; * @param xLabel X축 레이블 (예: &quot;날짜&quot;)&#10; * @param yLabel Y축 레이블 (예: &quot;영양소 (g)&quot;)&#10; * @param title 차트 제목&#10; * @param colors 각 세그먼트의 색상 팔레트 (건강 데이터에 적합한 기본 색상 제공)&#10; * @param width 차트 너비&#10; * @param height 차트 높이&#10; * @param barWidthRatio 바 너비 비율 (0.0 ~ 1.0)&#10; * @param showLegend 범례 표시 여부&#10; */&#10;@Composable&#10;fun StackedBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;StackedChartPoint&gt;,&#10;    segmentLabels: List&lt;String&gt; = emptyList(),&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Stacked Bar Chart&quot;,&#10;    colors: List&lt;Color&gt; = listOf(&#10;        Color(0xFF2196F3), // 파랑 (단백질)&#10;        Color(0xFFFF9800), // 주황 (지방)&#10;        Color(0xFF4CAF50), // 초록 (탄수화물)&#10;        Color(0xFF9C27B0), // 보라 (기타)&#10;        Color(0xFFE91E63), // 분홍&#10;        Color(0xFFFFEB3B), // 노랑&#10;    ),&#10;    width: Dp = 300.dp,&#10;    height: Dp = 300.dp,&#10;    barWidthRatio: Float = 0.6f,&#10;    showLegend: Boolean = true,&#10;    chartType: ChartType = ChartType.STACKED_BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.label ?: it.x.toString() }&#10;    &#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height)&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val totalValues = data.map { it.total }&#10;                val metrics = ChartMath.computeMetrics(size, totalValues, chartType = ChartType.STACKED_BAR)&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.Bar.drawStackedBars(this, data, metrics, colors, barWidthRatio)&#10;                ChartDraw.drawXAxis(this, metrics)&#10;                ChartDraw.drawYAxis(this, metrics)&#10;                ChartDraw.Bar.drawBarXAxisLabels(drawContext, xLabels, metrics)&#10;                &#10;                // 범례 그리기 (통합된 범례 시스템 사용)&#10;                if (showLegend &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    val legendPosition = Offset(size.width, 20f)&#10;                    ChartDraw.drawChartLegend(&#10;                        drawScope = this,&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = legendPosition,&#10;                        chartSize = size,&#10;                        title = null, &#10;                        itemHeight = 18f&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>