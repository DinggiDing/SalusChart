<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartMath/ChartMath.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartMath/ChartMath.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartMath&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import java.time.YearMonth&#10;import kotlin.math.abs&#10;import kotlin.math.ceil&#10;import kotlin.math.floor&#10;import kotlin.math.log10&#10;import kotlin.math.pow&#10;import kotlin.math.round&#10;import kotlin.math.sqrt&#10;&#10;object ChartMath {&#10;&#10;    var Pie = PieChartMath&#10;    var Calendar = CalendarChartMath&#10;    val RangeBar = RangeBarChartMath&#10;    val Line = LineChartMath&#10;    val Progress = ProgressChartMath&#10;    val Min = MinimalChartMath&#10;&#10;    /**&#10;     * 차트 그리기에 필요한 메트릭 정보를 담는 데이터 클래스&#10;     *&#10;     * @param paddingX X축 패딩 값&#10;     * @param paddingY Y축 패딩 값&#10;     * @param chartWidth 차트의 실제 너비&#10;     * @param chartHeight 차트의 실제 높이&#10;     * @param minY Y축의 최소값&#10;     * @param maxY Y축의 최대값&#10;     * @param yTicks Y축에 표시할 눈금 값들&#10;     */&#10;    data class ChartMetrics(&#10;        val paddingX: Float,&#10;        val paddingY: Float,&#10;        val chartWidth: Float,&#10;        val chartHeight: Float,&#10;        val minY: Float,&#10;        val maxY: Float,&#10;        val yTicks: List&lt;Float&gt;&#10;    )&#10;&#10;    /**&#10;     * y-axis 눈금 값들을 계산합니다.&#10;     * 1, 2, 5의 배수를 사용하여 시각적으로 깔끔한 눈금을 생성합니다.&#10;     *&#10;     * @param min 데이터의 최소값&#10;     * @param max 데이터의 최대값&#10;     * @param tickCount 원하는 눈금 개수 (기본값: 5)&#10;     * @param chartType 차트 타입 (BAR/STACKED_BAR/MINIMAL_BAR일 경우 최소값을 0으로 강제)&#10;     * @param actualMin 사용자 지정 최소 Y값 (지정시 데이터 범위를 확장)&#10;     * @param actualMax 사용자 지정 최대 Y값 (지정시 데이터 범위를 확장)&#10;     * @return 계산된 눈금 값들의 리스트&#10;     */&#10;    fun computeNiceTicks(&#10;        min: Float, &#10;        max: Float, &#10;        tickCount: Int = 5, &#10;        chartType: ChartType? = null,&#10;        actualMin: Float? = null,&#10;        actualMax: Float? = null&#10;    ): List&lt;Float&gt; {&#10;        if (min &gt;= max) {&#10;            return listOf(0f, 1f)&#10;        }&#10;        &#10;        // 바 차트의 경우 최소값을 0으로 강제 설정&#10;        var min = if (chartType == ChartType.BAR || &#10;                             chartType == ChartType.STACKED_BAR || &#10;                             chartType == ChartType.MINIMAL_BAR) {&#10;            0f&#10;        } else {&#10;            min&#10;        }&#10;        &#10;        val rawStep = (max - min) / tickCount.toDouble()&#10;        val power = 10.0.pow(floor(log10(rawStep)))&#10;        val candidates = listOf(1.0, 2.0, 5.0).map { it * power }&#10;        val step = candidates.minByOrNull { abs(it - rawStep) } ?: power&#10;&#10;        val niceMin = floor(min / step) * step&#10;        val niceMax = ceil(max / step) * step&#10;&#10;        // 사용자 지정 범위가 있으면 항상 우선 사용 (확장 또는 축소 모두 허용)&#10;        val finalMin = actualMin?.toDouble() ?: niceMin&#10;        val finalMax = actualMax?.toDouble() ?: niceMax&#10;&#10;        // 최종 범위에 대해 ticks 생성&#10;        val ticks = mutableListOf&lt;Float&gt;()&#10;        &#10;        // 사용자 지정 최소값이 있으면 먼저 추가&#10;        actualMin?.let { userMin -&gt;&#10;            ticks.add(userMin)&#10;        }&#10;        &#10;        // step에 따른 nice ticks 추가&#10;        var t = if (actualMin != null) {&#10;            // 사용자 최소값 다음부터 step 단위로 시작&#10;            ceil(finalMin / step) * step&#10;        } else {&#10;            finalMin&#10;        }&#10;        &#10;        while (t &lt;= finalMax + 1e-6) {&#10;            val roundedTick = round(t * 1000000) / 1000000&#10;            val tickValue = roundedTick.toFloat()&#10;            &#10;            // 사용자 지정 값과 중복되지 않는 경우만 추가&#10;            if (actualMin == null || abs(tickValue - actualMin) &gt; 1e-6) {&#10;                if (actualMax == null || abs(tickValue - actualMax) &gt; 1e-6) {&#10;                    ticks.add(tickValue)&#10;                }&#10;            }&#10;            t += step&#10;        }&#10;        &#10;        // 사용자 지정 최대값이 있으면 마지막에 추가&#10;        actualMax?.let { userMax -&gt;&#10;            ticks.add(userMax)&#10;        }&#10;&#10;        return ticks.distinct().sorted()&#10;    }&#10;&#10;    /**&#10;     * 차트 그리기에 필요한 메트릭 값을 계산합니다.&#10;     *&#10;     * @param size Canvas의 전체 크기&#10;     * @param values 차트에 표시할 Y축 데이터 값 목록&#10;     * @param tickCount 원하는 Y축 눈금 개수 (기본값: 5)&#10;     * @param chartType 차트 타입 (BAR/STACKED_BAR 타입일 경우 기본적으로 minY를 0으로 설정)&#10;     * @param isMinimal 미니멀 차트 모드인지 여부 (기본값: false)&#10;     * @param paddingX X축 패딩 값 (기본값: normal=60f, minimal=8f)&#10;     * @param paddingY Y축 패딩 값 (기본값: normal=40f, minimal=8f)&#10;     * @param minY 사용자 지정 최소 Y값 (지정시 바 차트의 기본 동작을 오버라이드)&#10;     * @param maxY 사용자 지정 최대 Y값 (지정시 nice ticks보다 우선적용)&#10;     * @return 차트 메트릭 객체&#10;     */&#10;    fun computeMetrics(&#10;        size: Size, &#10;        values: List&lt;Float&gt;, &#10;        tickCount: Int = 5, &#10;        chartType: ChartType? = null,&#10;        isMinimal: Boolean = false,&#10;        paddingX: Float = if (isMinimal) 8f else 60f,&#10;        paddingY: Float = if (isMinimal) 8f else 40f,&#10;        minY: Float? = null,&#10;        maxY: Float? = null&#10;    ): ChartMetrics {&#10;        val chartWidth = size.width - paddingX&#10;        val chartHeight = size.height - paddingY&#10;&#10;        val dataMax = values.maxOrNull() ?: 1f&#10;        val dataMin = values.minOrNull() ?: 0f&#10;&#10;        val yTicks = computeNiceTicks(dataMin, dataMax, tickCount, chartType, actualMin = minY, actualMax = maxY)&#10;&#10;        // Y축 범위 계산: 사용자 지정 값이 있으면 우선 사용, 없으면 nice ticks 또는 데이터 범위 사용&#10;        val actualMinY = if (isMinimal) {&#10;            minY ?: dataMin&#10;        } else {&#10;            minY ?: (yTicks.minOrNull() ?: dataMin)&#10;        }&#10;        &#10;        val actualMaxY = if (isMinimal) {&#10;            maxY ?: dataMax&#10;        } else {&#10;            maxY ?: (yTicks.maxOrNull() ?: dataMax)&#10;        }&#10;&#10;        return ChartMetrics(paddingX, paddingY, chartWidth, chartHeight, actualMinY, actualMaxY, yTicks)&#10;    }&#10;&#10;    /**&#10;     * 데이터 포인트를 화면 좌표로 변환합니다.&#10;     *&#10;     * @param data 차트 데이터 포인트 목록&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @return 화면 좌표로 변환된 Offset 목록&#10;     */&#10;    fun mapToCanvasPoints(data: List&lt;ChartPoint&gt;, size: Size, metrics: ChartMetrics): List&lt;Offset&gt; {&#10;        val spacing = metrics.chartWidth / (data.size - 1)&#10;        return data.mapIndexed { i, point -&gt;&#10;            val x = metrics.paddingX + i * spacing&#10;            val y = metrics.chartHeight - ((point.y - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;            Offset(x, y)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartMath&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import java.time.YearMonth&#10;import kotlin.math.abs&#10;import kotlin.math.ceil&#10;import kotlin.math.floor&#10;import kotlin.math.log10&#10;import kotlin.math.pow&#10;import kotlin.math.round&#10;import kotlin.math.sqrt&#10;&#10;object ChartMath {&#10;&#10;    var Pie = PieChartMath&#10;    var Calendar = CalendarChartMath&#10;    val RangeBar = RangeBarChartMath&#10;    val Line = LineChartMath&#10;    val Progress = ProgressChartMath&#10;    val Min = MinimalChartMath&#10;&#10;    /**&#10;     * 차트 그리기에 필요한 메트릭 정보를 담는 데이터 클래스&#10;     *&#10;     * @param paddingX X축 패딩 값&#10;     * @param paddingY Y축 패딩 값&#10;     * @param chartWidth 차트의 실제 너비&#10;     * @param chartHeight 차트의 실제 높이&#10;     * @param minY Y축의 최소값&#10;     * @param maxY Y축의 최대값&#10;     * @param yTicks Y축에 표시할 눈금 값들&#10;     */&#10;    data class ChartMetrics(&#10;        val paddingX: Float,&#10;        val paddingY: Float,&#10;        val chartWidth: Float,&#10;        val chartHeight: Float,&#10;        val minY: Float,&#10;        val maxY: Float,&#10;        val yTicks: List&lt;Float&gt;&#10;    )&#10;&#10;    /**&#10;     * y-axis 눈금 값들을 계산합니다.&#10;     * 1, 2, 5의 배수를 사용하여 시각적으로 깔끔한 눈금을 생성합니다.&#10;     *&#10;     * @param min 데이터의 최소값&#10;     * @param max 데이터의 최대값&#10;     * @param tickCount 원하는 눈금 개수 (기본값: 5)&#10;     * @param chartType 차트 타입 (BAR/STACKED_BAR/MINIMAL_BAR일 경우 최소값을 0으로 강제)&#10;     * @param actualMin 사용자 지정 최소 Y값 (지정시 데이터 범위를 확장)&#10;     * @param actualMax 사용자 지정 최대 Y값 (지정시 데이터 범위를 확장)&#10;     * @return 계산된 눈금 값들의 리스트&#10;     */&#10;    fun computeNiceTicks(&#10;        min: Float, &#10;        max: Float, &#10;        tickCount: Int = 5, &#10;        chartType: ChartType? = null,&#10;        actualMin: Float? = null,&#10;        actualMax: Float? = null&#10;    ): List&lt;Float&gt; {&#10;        if (min &gt;= max) {&#10;            return listOf(0f, 1f)&#10;        }&#10;        &#10;        // 바 차트의 경우 최소값을 0으로 강제 설정&#10;        var min = if (chartType == ChartType.BAR || &#10;                             chartType == ChartType.STACKED_BAR || &#10;                             chartType == ChartType.MINIMAL_BAR) {&#10;            0f&#10;        } else {&#10;            min&#10;        }&#10;        &#10;        val rawStep = (max - min) / tickCount.toDouble()&#10;        val power = 10.0.pow(floor(log10(rawStep)))&#10;        val candidates = listOf(1.0, 2.0, 5.0).map { it * power }&#10;        val step = candidates.minByOrNull { abs(it - rawStep) } ?: power&#10;&#10;        val niceMin = floor(min / step) * step&#10;        val niceMax = ceil(max / step) * step&#10;&#10;        // 사용자 지정 범위가 있으면 항상 우선 사용 (확장 또는 축소 모두 허용)&#10;        val finalMin = actualMin?.toDouble() ?: niceMin&#10;        val finalMax = actualMax?.toDouble() ?: niceMax&#10;&#10;        // 최종 범위에 대해 ticks 생성&#10;        val ticks = mutableListOf&lt;Float&gt;()&#10;        &#10;        // 사용자 지정 최소값이 있으면 먼저 추가&#10;        actualMin?.let { userMin -&gt;&#10;            ticks.add(userMin)&#10;        }&#10;        &#10;        // step에 따른 nice ticks 추가&#10;        var t = if (actualMin != null) {&#10;            // 사용자 최소값 다음부터 step 단위로 시작&#10;            ceil(finalMin / step) * step&#10;        } else {&#10;            finalMin&#10;        }&#10;        &#10;        while (t &lt;= finalMax + 1e-6) {&#10;            val roundedTick = round(t * 1000000) / 1000000&#10;            val tickValue = roundedTick.toFloat()&#10;            &#10;            // 사용자 지정 값과 중복되지 않는 경우만 추가&#10;            if (actualMin == null || abs(tickValue - actualMin) &gt; 1e-6) {&#10;                if (actualMax == null || abs(tickValue - actualMax) &gt; 1e-6) {&#10;                    ticks.add(tickValue)&#10;                }&#10;            }&#10;            t += step&#10;        }&#10;        &#10;        // 사용자 지정 최대값이 있으면 마지막에 추가&#10;        actualMax?.let { userMax -&gt;&#10;            ticks.add(userMax)&#10;        }&#10;&#10;        return ticks.distinct().sorted()&#10;    }&#10;&#10;    /**&#10;     * 차트 그리기에 필요한 메트릭 값을 계산합니다.&#10;     *&#10;     * @param size Canvas의 전체 크기&#10;     * @param values 차트에 표시할 Y축 데이터 값 목록&#10;     * @param tickCount 원하는 Y축 눈금 개수 (기본값: 5)&#10;     * @param chartType 차트 타입 (BAR/STACKED_BAR 타입일 경우 기본적으로 minY를 0으로 설정)&#10;     * @param isMinimal 미니멀 차트 모드인지 여부 (기본값: false)&#10;     * @param paddingX X축 패딩 값 (기본값: normal=60f, minimal=8f)&#10;     * @param paddingY Y축 패딩 값 (기본값: normal=40f, minimal=8f)&#10;     * @param minY 사용자 지정 최소 Y값 (지정시 바 차트의 기본 동작을 오버라이드)&#10;     * @param maxY 사용자 지정 최대 Y값 (지정시 nice ticks보다 우선적용)&#10;     * @return 차트 메트릭 객체&#10;     */&#10;    fun computeMetrics(&#10;        size: Size, &#10;        values: List&lt;Float&gt;, &#10;        tickCount: Int = 5, &#10;        chartType: ChartType? = null,&#10;        isMinimal: Boolean = false,&#10;        paddingX: Float = if (isMinimal) 8f else 60f,&#10;        paddingY: Float = if (isMinimal) 8f else 40f,&#10;        minY: Float? = null,&#10;        maxY: Float? = null&#10;    ): ChartMetrics {&#10;        val chartWidth = size.width - paddingX&#10;        val chartHeight = size.height - paddingY&#10;&#10;        val dataMax = values.maxOrNull() ?: 1f&#10;        val dataMin = values.minOrNull() ?: 0f&#10;&#10;        val yTicks = computeNiceTicks(dataMin, dataMax, tickCount, chartType, actualMin = minY, actualMax = maxY)&#10;&#10;        // Y축 범위 계산: 사용자 지정 값이 있으면 우선 사용, 없으면 nice ticks 또는 데이터 범위 사용&#10;        val actualMinY = if (isMinimal) {&#10;            minY ?: dataMin&#10;        } else {&#10;            minY ?: (yTicks.minOrNull() ?: dataMin)&#10;        }&#10;        &#10;        val actualMaxY = if (isMinimal) {&#10;            maxY ?: dataMax&#10;        } else {&#10;            maxY ?: (yTicks.maxOrNull() ?: dataMax)&#10;        }&#10;&#10;        return ChartMetrics(paddingX, paddingY, chartWidth, chartHeight, actualMinY, actualMaxY, yTicks)&#10;    }&#10;&#10;    /**&#10;     * 데이터 포인트를 화면 좌표로 변환합니다.&#10;     *&#10;     * @param data 차트 데이터 포인트 목록&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @return 화면 좌표로 변환된 Offset 목록&#10;     */&#10;    fun mapToCanvasPoints(data: List&lt;ChartPoint&gt;, size: Size, metrics: ChartMetrics): List&lt;Offset&gt; {&#10;        val spacing = metrics.chartWidth / (data.size - 1)&#10;        return data.mapIndexed { i, point -&gt;&#10;            val x = metrics.paddingX + i * spacing&#10;            val y = metrics.chartHeight - ((point.y - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;            Offset(x, y)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/ScatterPlot.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/ScatterPlot.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;@Composable&#10;fun ScatterPlot(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    xLabel: String = &quot;X Axis&quot;,&#10;    yLabel: String = &quot;Y Axis&quot;,&#10;    title: String = &quot;Scatter Plot Example&quot;,&#10;    pointColor: Color = com.hdil.saluschart.ui.theme.ChartColor.Default,&#10;    width: androidx.compose.ui.unit.Dp = 250.dp,&#10;    height: androidx.compose.ui.unit.Dp = 250.dp,&#10;    tooltipTextSize: Float = 32f        // 툴팁 텍스트 크기&#10;&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.x }&#10;    val yValues = data.map { it.y }&#10;&#10;    // 터치한 바의 위치와 값을 저장할 상태 변수&#10;    var touchedBarValue by remember { mutableStateOf&lt;Float?&gt;(null) }&#10;    var touchedPosition by remember { mutableStateOf&lt;Offset?&gt;(null) }&#10;&#10;&#10;    // State variables for points and selection&#10;    var canvasPoints by remember { mutableStateOf(listOf&lt;Offset&gt;()) }&#10;    var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;    var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(text = title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectTapGestures { tapOffset -&gt;&#10;                        // 터치 이벤트 발생 시 처리&#10;                        touchedPosition = tapOffset&#10;                        // 툴팁을 표시하기 위해 상태 초기화 (바를 탭하지 않았을 때)&#10;                        touchedBarValue = null&#10;                    }&#10;                }&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val metrics = ChartMath.computeMetrics(size, yValues)&#10;                val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;                // Store points and canvas size&#10;                canvasPoints = points&#10;                canvasSize = size&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.Line.drawXAxisLabels(drawContext, xLabels.map { it.toString() }, metrics)&#10;                val hitAreas = ChartDraw.Bar.drawBars(&#10;                    drawScope = this,&#10;                    values = yValues,&#10;                    metrics = metrics,&#10;                    color = Color.Transparent,  // 색상은 사용되지 않음&#10;                    barWidthMultiplier = 1.0f,  // 전체 너비 사용&#10;                    isInteractiveBars = true,&#10;                )&#10;&#10;                touchedPosition?.let { position -&gt;&#10;                    hitAreas.forEachIndexed { index, (hitArea, value) -&gt;&#10;                        if (hitArea.contains(position)) {&#10;                            // 터치한 바의 값을 저장하고 최적 위치 계산 후 통합 툴팁 표시&#10;                            touchedBarValue = value&#10;&#10;                            // 포인트 마커 위에 툴팁 위치 계산 (몇 픽셀 위로)&#10;                            val pointPosition = points[index]&#10;                            val optimalPosition = Offset(&#10;                                x = pointPosition.x,&#10;                                y = pointPosition.y - 40f  // 40 픽셀 위로&#10;                            )&#10;&#10;                            // 통합 툴팁 메서드 사용&#10;                            ChartDraw.drawTooltip(&#10;                                drawScope = this,&#10;                                value = value,&#10;                                position = optimalPosition,&#10;                                textSize = tooltipTextSize&#10;                            )&#10;                            return@forEachIndexed  // 첫 번째 매치에서 중단&#10;                        }&#10;                    }&#10;&#10;                    // 터치한 위치에 바가 없으면 툴팁 숨김&#10;                    if (touchedBarValue == null) {&#10;                        touchedPosition = null&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Add PointMarkers for each data point&#10;            canvasPoints.forEachIndexed { index, point -&gt;&#10;                ChartDraw.Scatter.PointMarker(&#10;                    center = point,&#10;                    value = yValues[index].toInt().toString(),&#10;                    isSelected = true  // 항상 기본 색상으로 표시&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;@Composable&#10;fun ScatterPlot(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    xLabel: String = &quot;X Axis&quot;,&#10;    yLabel: String = &quot;Y Axis&quot;,&#10;    title: String = &quot;Scatter Plot Example&quot;,&#10;    pointColor: Color = com.hdil.saluschart.ui.theme.ChartColor.Default,&#10;    width: androidx.compose.ui.unit.Dp = 250.dp,&#10;    height: androidx.compose.ui.unit.Dp = 250.dp,&#10;    tooltipTextSize: Float = 32f        // 툴팁 텍스트 크기&#10;&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.x }&#10;    val yValues = data.map { it.y }&#10;&#10;    // 터치한 바의 위치와 값을 저장할 상태 변수&#10;    var touchedBarValue by remember { mutableStateOf&lt;Float?&gt;(null) }&#10;    var touchedPosition by remember { mutableStateOf&lt;Offset?&gt;(null) }&#10;&#10;&#10;    // State variables for points and selection&#10;    var canvasPoints by remember { mutableStateOf(listOf&lt;Offset&gt;()) }&#10;    var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;    var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(text = title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectTapGestures { tapOffset -&gt;&#10;                        // 터치 이벤트 발생 시 처리&#10;                        touchedPosition = tapOffset&#10;                        // 툴팁을 표시하기 위해 상태 초기화 (바를 탭하지 않았을 때)&#10;                        touchedBarValue = null&#10;                    }&#10;                }&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val metrics = ChartMath.computeMetrics(size, yValues)&#10;                val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;                // Store points and canvas size&#10;                canvasPoints = points&#10;                canvasSize = size&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.Line.drawXAxisLabels(drawContext, xLabels.map { it.toString() }, metrics)&#10;                val hitAreas = ChartDraw.Bar.drawBars(&#10;                    drawScope = this,&#10;                    values = yValues,&#10;                    metrics = metrics,&#10;                    color = Color.Transparent,  // 색상은 사용되지 않음&#10;                    barWidthMultiplier = 1.0f,  // 전체 너비 사용&#10;                    isInteractiveBars = true,&#10;                )&#10;&#10;                touchedPosition?.let { position -&gt;&#10;                    hitAreas.forEachIndexed { index, (hitArea, value) -&gt;&#10;                        if (hitArea.contains(position)) {&#10;                            // 터치한 바의 값을 저장하고 최적 위치 계산 후 통합 툴팁 표시&#10;                            touchedBarValue = value&#10;&#10;                            // 포인트 마커 위에 툴팁 위치 계산 (몇 픽셀 위로)&#10;                            val pointPosition = points[index]&#10;                            val optimalPosition = Offset(&#10;                                x = pointPosition.x,&#10;                                y = pointPosition.y - 40f  // 40 픽셀 위로&#10;                            )&#10;&#10;                            // 통합 툴팁 메서드 사용&#10;                            ChartDraw.drawTooltip(&#10;                                drawScope = this,&#10;                                value = value,&#10;                                position = optimalPosition,&#10;                                textSize = tooltipTextSize&#10;                            )&#10;                            return@forEachIndexed  // 첫 번째 매치에서 중단&#10;                        }&#10;                    }&#10;&#10;                    // 터치한 위치에 바가 없으면 툴팁 숨김&#10;                    if (touchedBarValue == null) {&#10;                        touchedPosition = null&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Add PointMarkers for each data point&#10;            canvasPoints.forEachIndexed { index, point -&gt;&#10;                ChartDraw.Scatter.PointMarker(&#10;                    center = point,&#10;                    value = yValues[index].toInt().toString(),&#10;                    isSelected = true  // 항상 기본 색상으로 표시&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>