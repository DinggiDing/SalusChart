<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartMath/CalendarChartMath.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartMath/CalendarChartMath.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartMath&#10;&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.toArgb&#10;import java.time.YearMonth&#10;&#10;object CalendarChartMath {&#10;    /**&#10;     * 캘린더에 필요한 정보를 계산합니다.&#10;     *&#10;     * @param yearMonth 표시할 년월&#10;     * @return 달력 구성에 필요한 정보 (첫 번째 요일 위치, 해당 월의 일 수, 필요한 행 수)&#10;     */&#10;    fun computeCalendarMetrics(yearMonth: YearMonth): Triple&lt;Int, Int, Int&gt; {&#10;        val firstDayOfMonth = yearMonth.atDay(1)&#10;        val lastDayOfMonth = yearMonth.atEndOfMonth()&#10;        val firstDayOfWeek = firstDayOfMonth.dayOfWeek.value % 7 // 일요일이 0이 되도록 조정&#10;        val totalDays = lastDayOfMonth.dayOfMonth&#10;&#10;        // 필요한 행의 수 계산 (첫 요일 위치 + 일수에 따라 필요한 행 결정)&#10;        val weeks = (firstDayOfWeek + totalDays + 6) / 7&#10;&#10;        return Triple(firstDayOfWeek, totalDays, weeks)&#10;    }&#10;&#10;    /**&#10;     * 값에 따른 원의 크기를 계산합니다.&#10;     *&#10;     * @param value 현재 값&#10;     * @param maxValue 가능한 최대값&#10;     * @param minSize 최소 원 크기&#10;     * @param maxSize 최대 원 크기&#10;     * @return 계산된 원의 크기&#10;     */&#10;    fun calculateBubbleSize(value: Float, maxValue: Float, minSize: Float, maxSize: Float): Float {&#10;        if (maxValue &lt;= 0f) return minSize&#10;        val normalizedValue = value / maxValue&#10;        return minSize + (maxSize - minSize) * normalizedValue&#10;    }&#10;&#10;    fun calculateBubbleColor(color: Color, value: Float, maxValue: Float, minSize: Float, maxSize: Float): Color {&#10;        if (maxValue &lt;= 0f) return color&#10;        val normalizedValue = (value / maxValue).coerceIn(0f, 1f)&#10;        val hsl = FloatArray(3)&#10;        androidx.core.graphics.ColorUtils.colorToHSL(color.toArgb(), hsl)&#10;        val originalL = hsl[2]&#10;        // 최대값일 때 color의 밝기, 값이 작을수록 밝기가 커짐(최대 1.0까지)&#10;        hsl[2] = originalL + (1.0f - originalL) * (1f - normalizedValue)&#10;        hsl[2] = hsl[2].coerceIn(0f, 1f)&#10;        val newArgb = androidx.core.graphics.ColorUtils.HSLToColor(hsl)&#10;        return Color(newArgb)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartMath&#10;&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.toArgb&#10;import java.time.YearMonth&#10;&#10;object CalendarChartMath {&#10;    /**&#10;     * 캘린더에 필요한 정보를 계산합니다.&#10;     *&#10;     * @param yearMonth 표시할 년월&#10;     * @return 달력 구성에 필요한 정보 (첫 번째 요일 위치, 해당 월의 일 수, 필요한 행 수)&#10;     */&#10;    fun computeCalendarMetrics(yearMonth: YearMonth): Triple&lt;Int, Int, Int&gt; {&#10;        val firstDayOfMonth = yearMonth.atDay(1)&#10;        val lastDayOfMonth = yearMonth.atEndOfMonth()&#10;        val firstDayOfWeek = firstDayOfMonth.dayOfWeek.value % 7 // 일요일이 0이 되도록 조정&#10;        val totalDays = lastDayOfMonth.dayOfMonth&#10;&#10;        // 필요한 행의 수 계산 (첫 요일 위치 + 일수에 따라 필요한 행 결정)&#10;        val weeks = (firstDayOfWeek + totalDays + 6) / 7&#10;&#10;        return Triple(firstDayOfWeek, totalDays, weeks)&#10;    }&#10;&#10;    /**&#10;     * 값에 따른 원의 크기를 계산합니다.&#10;     *&#10;     * @param value 현재 값&#10;     * @param maxValue 가능한 최대값&#10;     * @param minSize 최소 원 크기&#10;     * @param maxSize 최대 원 크기&#10;     * @return 계산된 원의 크기&#10;     */&#10;    fun calculateBubbleSize(value: Float, maxValue: Float, minSize: Float, maxSize: Float): Float {&#10;        if (maxValue &lt;= 0f) return minSize&#10;        val normalizedValue = value / maxValue&#10;        return minSize + (maxSize - minSize) * normalizedValue&#10;    }&#10;&#10;    fun calculateBubbleColor(color: Color, value: Float, maxValue: Float, minSize: Float, maxSize: Float): Color {&#10;        if (maxValue &lt;= 0f) return color&#10;        val normalizedValue = (value / maxValue).coerceIn(0f, 1f)&#10;        val hsl = FloatArray(3)&#10;        androidx.core.graphics.ColorUtils.colorToHSL(color.toArgb(), hsl)&#10;        val originalL = hsl[2]&#10;        // 최대값일 때 color의 밝기, 값이 작을수록 밝기가 커짐(최대 0.9까지)&#10;        hsl[2] = originalL + (0.9f - originalL) * (1f - normalizedValue)&#10;        hsl[2] = hsl[2].coerceIn(0f, 0.9f)&#10;        val newArgb = androidx.core.graphics.ColorUtils.HSLToColor(hsl)&#10;        return Color(newArgb)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/CalendarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/CalendarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import android.graphics.Paint&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import java.time.DayOfWeek&#10;import java.time.LocalDate&#10;import java.time.YearMonth&#10;import java.time.format.TextStyle&#10;import java.util.*&#10;&#10;/**&#10; * 캘린더 차트에 표시할 데이터 모델&#10; */&#10;data class CalendarEntry(&#10;    val date: LocalDate,&#10;    val value: Float,&#10;    val color: Color? = null&#10;)&#10;&#10;/**&#10; * 캘린더 차트를 표시하는 Composable 함수&#10; */&#10;@Composable&#10;fun CalendarChart(&#10;    modifier: Modifier = Modifier,&#10;    entries: List&lt;CalendarEntry&gt;,&#10;    yearMonth: YearMonth = YearMonth.now(),&#10;    maxBubbleSize: Float = 24f,&#10;    minBubbleSize: Float = 6f,&#10;    defaultColor: Color = MaterialTheme.colorScheme.primary,&#10;    showGrid: Boolean = true,&#10;) {&#10;    // 단일 월 데이터만 있으면 기존 CalendarChart 로직 사용&#10;    SingleMonthCalendarChart(&#10;        modifier = modifier,&#10;        entries = entries,&#10;        yearMonth = yearMonth,&#10;        maxBubbleSize = maxBubbleSize,&#10;        minBubbleSize = minBubbleSize,&#10;        defaultColor = defaultColor,&#10;        showGrid = showGrid,&#10;    )&#10;}&#10;&#10;/**&#10; * 단일 월을 표시하는 캘린더 차트 (기존 CalendarChart 로직)&#10; */&#10;@Composable&#10;private fun SingleMonthCalendarChart(&#10;    modifier: Modifier = Modifier,&#10;    entries: List&lt;CalendarEntry&gt;,&#10;    yearMonth: YearMonth = YearMonth.now(),&#10;    maxBubbleSize: Float = 24f,&#10;    minBubbleSize: Float = 6f,&#10;    defaultColor: Color = MaterialTheme.colorScheme.primary,&#10;    showGrid: Boolean = true,&#10;) {&#10;    val maxValue = entries.maxOfOrNull { it.value } ?: 1f&#10;    val entriesByDate = entries.associateBy { it.date }&#10;&#10;    // 요일 배열 생성&#10;    val dayOfWeeks = listOf(DayOfWeek.SUNDAY, DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY)&#10;    // 캘린더 정보 계산&#10;    val (firstDayOfWeek, totalDays, weeks) = ChartMath.Calendar.computeCalendarMetrics(yearMonth)&#10;&#10;    Column(modifier = modifier) {&#10;        // 월/년 제목&#10;        Text(&#10;            text = yearMonth.month.getDisplayName(TextStyle.FULL_STANDALONE, Locale.getDefault()) + &quot; &quot; + yearMonth.year,&#10;            style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold),&#10;            modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        // 요일 헤더&#10;        Row(modifier = Modifier.fillMaxWidth()) {&#10;            dayOfWeeks.forEach { dayOfWeek -&gt;&#10;                Text(&#10;                    text = dayOfWeek.getDisplayName(TextStyle.SHORT, Locale.getDefault()),&#10;                    modifier = Modifier.weight(1f),&#10;                    textAlign = TextAlign.Center,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = MaterialTheme.colorScheme.onBackground&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // 캘린더 그리드 - Composable로 변환&#10;        Column(modifier = modifier) {&#10;            for (week in 0 until weeks) {&#10;                Row(modifier = Modifier.fillMaxWidth().height(IntrinsicSize.Min)) {&#10;                    for (day in 0 until 7) {&#10;                        val dayOfMonth = week * 7 + day - firstDayOfWeek + 1&#10;&#10;                        CalendarCellComposable(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .let { if (showGrid) it.border(0.5.dp, Color.Gray) else it },&#10;                            dayOfMonth = dayOfMonth,&#10;                            totalDays = totalDays,&#10;                            yearMonth = yearMonth,&#10;                            isWeekend = day == 0,&#10;                            entry = if (dayOfMonth in 1..totalDays) {&#10;                                entriesByDate[yearMonth.atDay(dayOfMonth)]&#10;                            } else null,&#10;                            maxValue = maxValue,&#10;                            minBubbleSize = minBubbleSize,&#10;                            maxBubbleSize = maxBubbleSize,&#10;                            defaultColor = defaultColor&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;/**&#10; * 개별 캘린더 셀을 Composable로 구현&#10; */&#10;@Composable&#10;private fun CalendarCellComposable(&#10;    modifier: Modifier = Modifier,&#10;    dayOfMonth: Int,&#10;    totalDays: Int,&#10;    isWeekend: Boolean,&#10;    entry: CalendarEntry?,&#10;    maxValue: Float,&#10;    yearMonth: YearMonth,&#10;    minBubbleSize: Float,&#10;    maxBubbleSize: Float,&#10;    defaultColor: Color&#10;) {&#10;    Box(&#10;        modifier = modifier.padding(4.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (dayOfMonth in 1..totalDays) {&#10;            Column(&#10;                modifier = Modifier.fillMaxSize().defaultMinSize(minHeight = 64.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                // 상단: 날짜 텍스트&#10;                Text(&#10;                    text = dayOfMonth.toString(),&#10;                    fontSize = 12.sp,&#10;                    color = if (isWeekend) Color.Red else Color.Black,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                // 중앙: 데이터 포인트(원)&#10;                entry?.let { dataEntry -&gt;&#10;                    val bubbleRadius = ChartMath.Calendar.calculateBubbleSize(&#10;                        value = dataEntry.value,&#10;                        maxValue = maxValue,&#10;                        minSize = minBubbleSize,&#10;                        maxSize = maxBubbleSize&#10;                    )&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size((bubbleRadius * 2).dp)&#10;                            .clip(CircleShape)&#10;                            .background(dataEntry.color ?: defaultColor)&#10;                    )&#10;                } ?: Spacer(modifier = Modifier.height((maxBubbleSize*2).dp)) // 데이터 없을 때 공간 확보&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import android.graphics.Paint&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import java.time.DayOfWeek&#10;import java.time.LocalDate&#10;import java.time.YearMonth&#10;import java.time.format.TextStyle&#10;import java.util.*&#10;&#10;/**&#10; * 캘린더 차트에 표시할 데이터 모델&#10; */&#10;data class CalendarEntry(&#10;    val date: LocalDate,&#10;    val value: Float,&#10;    val color: Color? = null&#10;)&#10;&#10;/**&#10; * 캘린더 차트를 표시하는 Composable 함수&#10; */&#10;@Composable&#10;fun CalendarChart(&#10;    modifier: Modifier = Modifier,&#10;    entries: List&lt;CalendarEntry&gt;,&#10;    yearMonth: YearMonth = YearMonth.now(),&#10;    maxBubbleSize: Float = 24f,&#10;    minBubbleSize: Float = 6f,&#10;    defaultColor: Color = MaterialTheme.colorScheme.primary,&#10;    showGrid: Boolean = true,&#10;) {&#10;    // 단일 월 데이터만 있으면 기존 CalendarChart 로직 사용&#10;    SingleMonthCalendarChart(&#10;        modifier = modifier,&#10;        entries = entries,&#10;        yearMonth = yearMonth,&#10;        maxBubbleSize = maxBubbleSize,&#10;        minBubbleSize = minBubbleSize,&#10;        defaultColor = defaultColor,&#10;        showGrid = showGrid,&#10;    )&#10;}&#10;&#10;/**&#10; * 단일 월을 표시하는 캘린더 차트 (기존 CalendarChart 로직)&#10; */&#10;@Composable&#10;private fun SingleMonthCalendarChart(&#10;    modifier: Modifier = Modifier,&#10;    entries: List&lt;CalendarEntry&gt;,&#10;    yearMonth: YearMonth = YearMonth.now(),&#10;    maxBubbleSize: Float = 24f,&#10;    minBubbleSize: Float = 6f,&#10;    defaultColor: Color = MaterialTheme.colorScheme.primary,&#10;    showGrid: Boolean = true,&#10;) {&#10;    val maxValue = entries.maxOfOrNull { it.value } ?: 1f&#10;    val entriesByDate = entries.associateBy { it.date }&#10;&#10;    // 요일 배열 생성&#10;    val dayOfWeeks = listOf(DayOfWeek.SUNDAY, DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY)&#10;    // 캘린더 정보 계산&#10;    val (firstDayOfWeek, totalDays, weeks) = ChartMath.Calendar.computeCalendarMetrics(yearMonth)&#10;&#10;    Column(modifier = modifier) {&#10;        // 월/년 제목&#10;        Text(&#10;            text = yearMonth.month.getDisplayName(TextStyle.FULL_STANDALONE, Locale.getDefault()) + &quot; &quot; + yearMonth.year,&#10;            style = MaterialTheme.typography.headlineSmall.copy(fontWeight = FontWeight.Bold),&#10;            modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        // 요일 헤더&#10;        Row(modifier = Modifier.fillMaxWidth()) {&#10;            dayOfWeeks.forEach { dayOfWeek -&gt;&#10;                Text(&#10;                    text = dayOfWeek.getDisplayName(TextStyle.SHORT, Locale.getDefault()),&#10;                    modifier = Modifier.weight(1f),&#10;                    textAlign = TextAlign.Center,&#10;                    fontWeight = FontWeight.SemiBold,&#10;                    color = MaterialTheme.colorScheme.onBackground&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        // 캘린더 그리드 - Composable로 변환&#10;        Column(modifier = modifier) {&#10;            for (week in 0 until weeks) {&#10;                Row(modifier = Modifier.fillMaxWidth().height(IntrinsicSize.Min)) {&#10;                    for (day in 0 until 7) {&#10;                        val dayOfMonth = week * 7 + day - firstDayOfWeek + 1&#10;&#10;                        CalendarCellComposable(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .let { if (showGrid) it.border(0.5.dp, Color.Gray) else it },&#10;                            dayOfMonth = dayOfMonth,&#10;                            totalDays = totalDays,&#10;                            yearMonth = yearMonth,&#10;                            isWeekend = day == 0,&#10;                            entry = if (dayOfMonth in 1..totalDays) {&#10;                                entriesByDate[yearMonth.atDay(dayOfMonth)]&#10;                            } else null,&#10;                            maxValue = maxValue,&#10;                            minBubbleSize = minBubbleSize,&#10;                            maxBubbleSize = maxBubbleSize,&#10;                            defaultColor = defaultColor&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;/**&#10; * 개별 캘린더 셀을 Composable로 구현&#10; */&#10;@Composable&#10;private fun CalendarCellComposable(&#10;    modifier: Modifier = Modifier,&#10;    dayOfMonth: Int,&#10;    totalDays: Int,&#10;    isWeekend: Boolean,&#10;    entry: CalendarEntry?,&#10;    maxValue: Float,&#10;    yearMonth: YearMonth,&#10;    minBubbleSize: Float,&#10;    maxBubbleSize: Float,&#10;    defaultColor: Color&#10;) {&#10;    Box(&#10;        modifier = modifier.padding(4.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        if (dayOfMonth in 1..totalDays) {&#10;            Column(&#10;                modifier = Modifier.fillMaxSize().defaultMinSize(minHeight = 64.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                // 상단: 날짜 텍스트&#10;                Text(&#10;                    text = dayOfMonth.toString(),&#10;                    fontSize = 12.sp,&#10;                    color = if (isWeekend) Color.Red else Color.Black,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                // 중앙: 데이터 포인트(원)&#10;                entry?.let { dataEntry -&gt;&#10;                    val bubbleRadius = ChartMath.Calendar.calculateBubbleSize(&#10;                        value = dataEntry.value,&#10;                        maxValue = maxValue,&#10;                        minSize = minBubbleSize,&#10;                        maxSize = maxBubbleSize&#10;                    )&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size((bubbleRadius * 2).dp)&#10;                            .clip(CircleShape)&#10;                            .background(dataEntry.color ?: defaultColor)&#10;                    )&#10;                } ?: Spacer(modifier = Modifier.height((maxBubbleSize*2).dp)) // 데이터 없을 때 공간 확보&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>