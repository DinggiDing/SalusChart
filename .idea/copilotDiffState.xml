<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/ChartType.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/ChartType.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart&#10;&#10;enum class ChartType {&#10;    LINE,&#10;    BAR,&#10;    RANGE_BAR,&#10;    STACKED_BAR,&#10;    PIE,&#10;    PROGRESS,&#10;    SCATTERPLOT,&#10;    SLEEPSTAGE_CHART,&#10;    CALENDAR,&#10;    MINIMAL_BAR,&#10;    MINIMAL_LINE,&#10;    MINIMAL_RANGE_BAR;&#10;&#10;    companion object {&#10;        fun fromString(type: String): ChartType? {&#10;            return values().find { it.name.equals(type, ignoreCase = true) }&#10;        }&#10;    }&#10;}&#10;&#10;enum class InteractionType {&#10;    POINT,         // Direct point touching using PointMarker()&#10;    NEAR_X_AXIS,    // Area-based touching using BarMarker()&#10;    BAR;          // Bar touching using BarMarker()&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart&#10;&#10;enum class ChartType {&#10;    LINE,&#10;    BAR,&#10;    RANGE_BAR,&#10;    STACKED_BAR,&#10;    PIE,&#10;    PROGRESS,&#10;    SCATTERPLOT,&#10;    SLEEPSTAGE_CHART,&#10;    CALENDAR,&#10;    MINIMAL_BAR,&#10;    MINIMAL_LINE,&#10;    MINIMAL_RANGE_BAR;&#10;&#10;    companion object {&#10;        fun fromString(type: String): ChartType? {&#10;            return values().find { it.name.equals(type, ignoreCase = true) }&#10;        }&#10;    }&#10;}&#10;&#10;enum class InteractionType {&#10;    POINT,         // Direct point touching using PointMarker()&#10;    NEAR_X_AXIS,    // Area-based touching using BarMarker()&#10;    BAR,           // Bar touching using BarMarker()&#10;    STACKED_BAR;   // Individual segment touching in stacked bar charts&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/StackedBarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/StackedBarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;&#10;/**&#10; * 스택 바 차트 컴포저블 (건강 데이터 시각화에 최적화)&#10; * &#10; * 영양소 섭취량, 운동 시간 등 여러 구성 요소를 가진 데이터를 시각화할 때 사용합니다.&#10; * 예: 일별 영양소 섭취량 (단백질, 지방, 탄수화물)&#10; * &#10; * @param modifier 커스텀 modifier&#10; * @param data 스택 차트 데이터 포인트 목록&#10; * @param segmentLabels 각 세그먼트의 레이블들 (예: [&quot;단백질&quot;, &quot;지방&quot;, &quot;탄수화물&quot;])&#10; * @param xLabel X축 레이블 (예: &quot;날짜&quot;)&#10; * @param yLabel Y축 레이블 (예: &quot;영양소 (g)&quot;)&#10; * @param title 차트 제목&#10; * @param colors 각 세그먼트의 색상 팔레트 (건강 데이터에 적합한 기본 색상 제공)&#10; * @param width 차트 너비&#10; * @param height 차트 높이&#10; * @param barWidthRatio 바 너비 비율 (0.0 ~ 1.0)&#10; * @param showLegend 범례 표시 여부&#10; * @param interactionType 상호작용 타입 (STACKED_BAR: 개별 세그먼트 터치, NEAR_X_AXIS: 전체 스택 툴팁)&#10; * @param onBarClick 바 클릭 시 호출되는 콜백 (바 인덱스, 세그먼트 인덱스, 값)&#10; */&#10;@Composable&#10;fun StackedBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;StackedChartPoint&gt;,&#10;    segmentLabels: List&lt;String&gt; = emptyList(),&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Stacked Bar Chart&quot;,&#10;    colors: List&lt;Color&gt; = listOf(&#10;        Color(0xFF2196F3), // 파랑 (단백질)&#10;        Color(0xFFFF9800), // 주황 (지방)&#10;        Color(0xFF4CAF50), // 초록 (탄수화물)&#10;        Color(0xFF9C27B0), // 보라 (기타)&#10;        Color(0xFFE91E63), // 분홍&#10;        Color(0xFFFFEB3B), // 노랑&#10;    ),&#10;    width: Dp = 300.dp,&#10;    height: Dp = 300.dp,&#10;    barWidthRatio: Float = 0.6f,&#10;    showLegend: Boolean = true,&#10;    interactionType: InteractionType = InteractionType.STACKED_BAR,&#10;    onBarClick: ((barIndex: Int, segmentIndex: Int?, value: Float) -&gt; Unit)? = null,&#10;    chartType: ChartType = ChartType.STACKED_BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.label ?: it.x.toString() }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;    var selectedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height)&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val totalValues = data.map { it.total }&#10;                val metrics = ChartMath.computeMetrics(size, totalValues, chartType = ChartType.STACKED_BAR)&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.drawXAxis(this, metrics)&#10;                ChartDraw.drawYAxis(this, metrics)&#10;                ChartDraw.Bar.drawBarXAxisLabels(drawContext, xLabels, metrics)&#10;                &#10;                // 범례 그리기 (통합된 범례 시스템 사용)&#10;                if (showLegend &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    val legendPosition = Offset(size.width, 20f)&#10;                    ChartDraw.drawChartLegend(&#10;                        drawScope = this,&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = legendPosition,&#10;                        chartSize = size,&#10;                        title = null, &#10;                        itemHeight = 18f&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Conditional rendering based on interaction type&#10;            when (interactionType) {&#10;                InteractionType.STACKED_BAR -&gt; {&#10;                    // Individual segment interaction - each segment is touchable&#10;                    renderStackedBarsWithSegmentInteraction(&#10;                        data = data,&#10;                        chartMetrics = chartMetrics,&#10;                        colors = colors,&#10;                        barWidthRatio = barWidthRatio,&#10;                        chartType = chartType,&#10;                        segmentLabels = segmentLabels,&#10;                        onBarClick = onBarClick&#10;                    )&#10;                }&#10;                InteractionType.NEAR_X_AXIS -&gt; {&#10;                    // Area-based interaction - show all segment values in tooltip&#10;                    renderStackedBarsWithAreaInteraction(&#10;                        data = data,&#10;                        chartMetrics = chartMetrics,&#10;                        colors = colors,&#10;                        barWidthRatio = barWidthRatio,&#10;                        chartType = chartType,&#10;                        segmentLabels = segmentLabels,&#10;                        selectedBarIndex = selectedBarIndex,&#10;                        onBarClick = { index, tooltipText -&gt;&#10;                            selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                            onBarClick?.invoke(index, null, data.getOrNull(index)?.total ?: 0f)&#10;                        }&#10;                    )&#10;                }&#10;                else -&gt; {&#10;                    // Default: non-interactive rendering&#10;                    renderStackedBarsDefault(&#10;                        data = data,&#10;                        chartMetrics = chartMetrics,&#10;                        colors = colors,&#10;                        barWidthRatio = barWidthRatio,&#10;                        chartType = chartType&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;&#10;/**&#10; * Renders stacked bars with individual segment interaction (InteractionType.STACKED_BAR)&#10; * Each segment is touchable and shows its individual value in tooltip&#10; */&#10;@Composable&#10;private fun renderStackedBarsWithSegmentInteraction(&#10;    data: List&lt;StackedChartPoint&gt;,&#10;    chartMetrics: ChartMath.ChartMetrics?,&#10;    colors: List&lt;Color&gt;,&#10;    barWidthRatio: Float,&#10;    chartType: ChartType,&#10;    segmentLabels: List&lt;String&gt;,&#10;    onBarClick: ((barIndex: Int, segmentIndex: Int?, value: Float) -&gt; Unit)?&#10;) {&#10;    chartMetrics?.let { metrics -&gt;&#10;        val segmentCounts = data.map { it.values.size }&#10;        val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;        // Render each segment as an interactive BarMarker&#10;        for (segmentIndex in 0 until maxSegments) {&#10;            val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;            val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;            data.forEach { stackedPoint -&gt;&#10;                var cumulativeValue = 0f&#10;                for (i in 0 until segmentIndex) {&#10;                    cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                }&#10;                val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                segmentMinValues.add(cumulativeValue)&#10;                segmentMaxValues.add(cumulativeValue + segmentValue)&#10;            }&#10;&#10;            val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;            if (hasNonZeroValues) {&#10;                val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;                val segmentLabel = segmentLabels.getOrNull(segmentIndex) ?: &quot;Segment $segmentIndex&quot;&#10;&#10;                ChartDraw.Bar.BarMarker(&#10;                    minValues = segmentMinValues,&#10;                    maxValues = segmentMaxValues,&#10;                    metrics = metrics,&#10;                    color = segmentColor,&#10;                    barWidthRatio = barWidthRatio,&#10;                    interactive = true,&#10;                    chartType = chartType,&#10;                    onBarClick = { barIndex, _ -&gt;&#10;                        val segmentValue = data.getOrNull(barIndex)?.values?.getOrNull(segmentIndex) ?: 0f&#10;                        onBarClick?.invoke(barIndex, segmentIndex, segmentValue)&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Renders stacked bars with area interaction (InteractionType.NEAR_X_AXIS)&#10; * Shows all segment values in a combined tooltip&#10; */&#10;@Composable&#10;private fun renderStackedBarsWithAreaInteraction(&#10;    data: List&lt;StackedChartPoint&gt;,&#10;    chartMetrics: ChartMath.ChartMetrics?,&#10;    colors: List&lt;Color&gt;,&#10;    barWidthRatio: Float,&#10;    chartType: ChartType,&#10;    segmentLabels: List&lt;String&gt;,&#10;    selectedBarIndex: Int?,&#10;    onBarClick: (Int, String) -&gt; Unit&#10;) {&#10;    chartMetrics?.let { metrics -&gt;&#10;        val segmentCounts = data.map { it.values.size }&#10;        val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;        // First, render non-interactive visual segments&#10;        for (segmentIndex in 0 until maxSegments) {&#10;            val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;            val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;            data.forEach { stackedPoint -&gt;&#10;                var cumulativeValue = 0f&#10;                for (i in 0 until segmentIndex) {&#10;                    cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                }&#10;                val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                segmentMinValues.add(cumulativeValue)&#10;                segmentMaxValues.add(cumulativeValue + segmentValue)&#10;            }&#10;&#10;            val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;            if (hasNonZeroValues) {&#10;                val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                ChartDraw.Bar.BarMarker(&#10;                    minValues = segmentMinValues,&#10;                    maxValues = segmentMaxValues,&#10;                    metrics = metrics,&#10;                    color = segmentColor,&#10;                    barWidthRatio = barWidthRatio,&#10;                    interactive = false,&#10;                    chartType = chartType&#10;                )&#10;            }&#10;        }&#10;&#10;        // Create transparent overlay bars for interaction with combined tooltip&#10;        val totalMinValues = List(data.size) { metrics.minY }&#10;        val totalMaxValues = data.map { it.total }&#10;&#10;        ChartDraw.Bar.BarMarker(&#10;            minValues = totalMinValues,&#10;            maxValues = totalMaxValues,&#10;            metrics = metrics,&#10;            onBarClick = { index, _ -&gt;&#10;                // Create combined tooltip text for all segments&#10;                val stackedPoint = data.getOrNull(index)&#10;                if (stackedPoint != null) {&#10;                    val tooltipParts = mutableListOf&lt;String&gt;()&#10;                    stackedPoint.values.forEachIndexed { segmentIndex, value -&gt;&#10;                        val label = segmentLabels.getOrNull(segmentIndex) ?: &quot;Segment $segmentIndex&quot;&#10;                        if (value &gt; 0f) {&#10;                            tooltipParts.add(&quot;$label: ${value.toInt()}&quot;)&#10;                        }&#10;                    }&#10;                    val combinedTooltip = tooltipParts.joinToString(&quot;, &quot;)&#10;                    onBarClick(index, combinedTooltip)&#10;                }&#10;            },&#10;            chartType = chartType,&#10;            showTooltipForIndex = selectedBarIndex,&#10;            isTouchArea = true&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Renders stacked bars without interaction (default mode)&#10; */&#10;@Composable&#10;private fun renderStackedBarsDefault(&#10;    data: List&lt;StackedChartPoint&gt;,&#10;    chartMetrics: ChartMath.ChartMetrics?,&#10;    colors: List&lt;Color&gt;,&#10;    barWidthRatio: Float,&#10;    chartType: ChartType&#10;) {&#10;    chartMetrics?.let { metrics -&gt;&#10;        val segmentCounts = data.map { it.values.size }&#10;        val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;        for (segmentIndex in 0 until maxSegments) {&#10;            val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;            val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;            data.forEach { stackedPoint -&gt;&#10;                var cumulativeValue = 0f&#10;                for (i in 0 until segmentIndex) {&#10;                    cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                }&#10;                val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                segmentMinValues.add(cumulativeValue)&#10;                segmentMaxValues.add(cumulativeValue + segmentValue)&#10;            }&#10;&#10;            val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;            if (hasNonZeroValues) {&#10;                val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                ChartDraw.Bar.BarMarker(&#10;                    minValues = segmentMinValues,&#10;                    maxValues = segmentMaxValues,&#10;                    metrics = metrics,&#10;                    color = segmentColor,&#10;                    barWidthRatio = barWidthRatio,&#10;                    interactive = false,&#10;                    chartType = chartType&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;&#10;/**&#10; * 스택 바 차트 컴포저블 (건강 데이터 시각화에 최적화)&#10; * &#10; * 영양소 섭취량, 운동 시간 등 여러 구성 요소를 가진 데이터를 시각화할 때 사용합니다.&#10; * 예: 일별 영양소 섭취량 (단백질, 지방, 탄수화물)&#10; * &#10; * @param modifier 커스텀 modifier&#10; * @param data 스택 차트 데이터 포인트 목록&#10; * @param segmentLabels 각 세그먼트의 레이블들 (예: [&quot;단백질&quot;, &quot;지방&quot;, &quot;탄수화물&quot;])&#10; * @param xLabel X축 레이블 (예: &quot;날짜&quot;)&#10; * @param yLabel Y축 레이블 (예: &quot;영양소 (g)&quot;)&#10; * @param title 차트 제목&#10; * @param colors 각 세그먼트의 색상 팔레트 (건강 데이터에 적합한 기본 색상 제공)&#10; * @param width 차트 너비&#10; * @param height 차트 높이&#10; * @param barWidthRatio 바 너비 비율 (0.0 ~ 1.0)&#10; * @param showLegend 범례 표시 여부&#10; * @param interactionType 상호작용 타입 (STACKED_BAR: 개별 세그먼트 터치, NEAR_X_AXIS: 전체 스택 툴팁)&#10; * @param onBarClick 바 클릭 시 호출되는 콜백 (바 인덱스, 세그먼트 인덱스, 값)&#10; */&#10;@Composable&#10;fun StackedBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;StackedChartPoint&gt;,&#10;    segmentLabels: List&lt;String&gt; = emptyList(),&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Stacked Bar Chart&quot;,&#10;    colors: List&lt;Color&gt; = listOf(&#10;        Color(0xFF2196F3), // 파랑 (단백질)&#10;        Color(0xFFFF9800), // 주황 (지방)&#10;        Color(0xFF4CAF50), // 초록 (탄수화물)&#10;        Color(0xFF9C27B0), // 보라 (기타)&#10;        Color(0xFFE91E63), // 분홍&#10;        Color(0xFFFFEB3B), // 노랑&#10;    ),&#10;    width: Dp = 300.dp,&#10;    height: Dp = 300.dp,&#10;    barWidthRatio: Float = 0.6f,&#10;    showLegend: Boolean = true,&#10;    interactionType: InteractionType = InteractionType.STACKED_BAR,&#10;    onBarClick: ((barIndex: Int, segmentIndex: Int?, value: Float) -&gt; Unit)? = null,&#10;    chartType: ChartType = ChartType.STACKED_BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.label ?: it.x.toString() }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;    var selectedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;                .width(width)&#10;                .height(height)&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val totalValues = data.map { it.total }&#10;                val metrics = ChartMath.computeMetrics(size, totalValues, chartType = ChartType.STACKED_BAR)&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.drawXAxis(this, metrics)&#10;                ChartDraw.drawYAxis(this, metrics)&#10;                ChartDraw.Bar.drawBarXAxisLabels(drawContext, xLabels, metrics)&#10;                &#10;                // 범례 그리기 (통합된 범례 시스템 사용)&#10;                if (showLegend &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    val legendPosition = Offset(size.width, 20f)&#10;                    ChartDraw.drawChartLegend(&#10;                        drawScope = this,&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = legendPosition,&#10;                        chartSize = size,&#10;                        title = null, &#10;                        itemHeight = 18f&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Conditional rendering based on interaction type&#10;            when (interactionType) {&#10;                InteractionType.STACKED_BAR -&gt; {&#10;                    // Individual segment interaction - each segment is touchable&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        val segmentCounts = data.map { it.values.size }&#10;                        val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;                        &#10;                        // Validate that all StackedChartPoints have the same number of segments&#10;                        if (segmentCounts.any { it != maxSegments }) {&#10;                            throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                        }&#10;                        &#10;                        // Render each segment as an interactive BarMarker&#10;                        for (segmentIndex in 0 until maxSegments) {&#10;                            val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                            val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;                            &#10;                            data.forEach { stackedPoint -&gt;&#10;                                var cumulativeValue = 0f&#10;                                for (i in 0 until segmentIndex) {&#10;                                    cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                }&#10;                                val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;                                &#10;                                segmentMinValues.add(cumulativeValue)&#10;                                segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                            }&#10;                            &#10;                            val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                            if (hasNonZeroValues) {&#10;                                val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;                                &#10;                                ChartDraw.Bar.BarMarker(&#10;                                    minValues = segmentMinValues,&#10;                                    maxValues = segmentMaxValues,&#10;                                    metrics = metrics,&#10;                                    color = segmentColor,&#10;                                    barWidthRatio = barWidthRatio,&#10;                                    interactive = true,&#10;                                    chartType = chartType,&#10;                                    onBarClick = { barIndex, _ -&gt;&#10;                                        val segmentValue = data.getOrNull(barIndex)?.values?.getOrNull(segmentIndex) ?: 0f&#10;                                        onBarClick?.invoke(barIndex, segmentIndex, segmentValue)&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                InteractionType.NEAR_X_AXIS -&gt; {&#10;                    // Area-based interaction - show all segment values in tooltip&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        val segmentCounts = data.map { it.values.size }&#10;                        val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;                        &#10;                        // Validate that all StackedChartPoints have the same number of segments&#10;                        if (segmentCounts.any { it != maxSegments }) {&#10;                            throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                        }&#10;                        &#10;                        // First, render non-interactive visual segments&#10;                        for (segmentIndex in 0 until maxSegments) {&#10;                            val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                            val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;                            &#10;                            data.forEach { stackedPoint -&gt;&#10;                                var cumulativeValue = 0f&#10;                                for (i in 0 until segmentIndex) {&#10;                                    cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                }&#10;                                val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;                                &#10;                                segmentMinValues.add(cumulativeValue)&#10;                                segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                            }&#10;                            &#10;                            val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                            if (hasNonZeroValues) {&#10;                                val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;                                &#10;                                ChartDraw.Bar.BarMarker(&#10;                                    minValues = segmentMinValues,&#10;                                    maxValues = segmentMaxValues,&#10;                                    metrics = metrics,&#10;                                    color = segmentColor,&#10;                                    barWidthRatio = barWidthRatio,&#10;                                    interactive = false,&#10;                                    chartType = chartType&#10;                                )&#10;                            }&#10;                        }&#10;                        &#10;                        // Create transparent overlay bars for interaction with combined tooltip&#10;                        val totalMinValues = List(data.size) { metrics.minY }&#10;                        val totalMaxValues = data.map { it.total }&#10;                        &#10;                        ChartDraw.Bar.BarMarker(&#10;                            minValues = totalMinValues,&#10;                            maxValues = totalMaxValues,&#10;                            metrics = metrics,&#10;                            onBarClick = { index, _ -&gt;&#10;                                // Create combined tooltip text for all segments&#10;                                val stackedPoint = data.getOrNull(index)&#10;                                if (stackedPoint != null) {&#10;                                    val tooltipParts = mutableListOf&lt;String&gt;()&#10;                                    stackedPoint.values.forEachIndexed { segmentIndex, value -&gt;&#10;                                        val label = segmentLabels.getOrNull(segmentIndex) ?: &quot;Segment $segmentIndex&quot;&#10;                                        if (value &gt; 0f) {&#10;                                            tooltipParts.add(&quot;$label: ${value.toInt()}&quot;)&#10;                                        }&#10;                                    }&#10;                                    val combinedTooltip = tooltipParts.joinToString(&quot;, &quot;)&#10;                                    &#10;                                    // Toggle selection state&#10;                                    selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                    onBarClick?.invoke(index, null, stackedPoint.total)&#10;                                }&#10;                            },&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex,&#10;                            isTouchArea = true&#10;                        )&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    // Default: non-interactive rendering&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        val segmentCounts = data.map { it.values.size }&#10;                        val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;                        &#10;                        // Validate that all StackedChartPoints have the same number of segments&#10;                        if (segmentCounts.any { it != maxSegments }) {&#10;                            throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                        }&#10;                        &#10;                        for (segmentIndex in 0 until maxSegments) {&#10;                            val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                            val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;                            &#10;                            data.forEach { stackedPoint -&gt;&#10;                                var cumulativeValue = 0f&#10;                                for (i in 0 until segmentIndex) {&#10;                                    cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                }&#10;                                val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;                                &#10;                                segmentMinValues.add(cumulativeValue)&#10;                                segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                            }&#10;                            &#10;                            val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                            if (hasNonZeroValues) {&#10;                                val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;                                &#10;                                ChartDraw.Bar.BarMarker(&#10;                                    minValues = segmentMinValues,&#10;                                    maxValues = segmentMaxValues,&#10;                                    metrics = metrics,&#10;                                    color = segmentColor,&#10;                                    barWidthRatio = barWidthRatio,&#10;                                    interactive = false,&#10;                                    chartType = chartType&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>