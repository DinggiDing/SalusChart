<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/build.gradle.kts" />
              <option name="originalContent" value="import org.jetbrains.kotlin.gradle.dsl.JvmTarget&#10;&#10;plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.chart&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core module dependencies&#10;    implementation(project(&quot;:core:transform&quot;))&#10;&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.runtime)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;}" />
              <option name="updatedContent" value="import org.jetbrains.kotlin.gradle.dsl.JvmTarget&#10;&#10;plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.chart&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core module dependencies&#10;    implementation(project(&quot;:core:util&quot;))&#10;&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.runtime)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/ChartPoint.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/ChartPoint.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart&#10;&#10;import com.hdil.saluschart.core.util.TimeUnitGroup&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import java.time.format.DateTimeFormatter&#10;import android.util.Log&#10;&#10;data class ChartPoint(&#10;    val x: Float,&#10;    val y: Float,&#10;    val label: String? = null,&#10;    val color: Int? = null,&#10;    val isSelected: Boolean = false&#10;) {&#10;    override fun toString(): String {&#10;        return &quot;ChartPoint(x=$x, y=$y, label=$label, color=$color, isSelected=$isSelected)&quot;&#10;    }&#10;}&#10;&#10;/**&#10; * 범위 바 차트를 위한 데이터 포인트 클래스&#10; */&#10;data class RangeChartPoint(&#10;    val x: Float,&#10;    val yMin: Float,&#10;    val yMax: Float,&#10;    val label: String? = null,&#10;    val color: Int? = null,&#10;    val isSelected: Boolean = false&#10;) {&#10;    override fun toString(): String {&#10;        return &quot;RangeChartPoint(x=$x, yMin=$yMin, yMax=$yMax, label=$label, color=$color, isSelected=$isSelected)&quot;&#10;    }&#10;}&#10;&#10;/**&#10; * 스택 바 차트를 위한 데이터 포인트 클래스&#10; * &#10; * @param x X축 위치 또는 시간 인덱스&#10; * @param values 각 세그먼트의 값들 (예: [단백질, 지방, 탄수화물])&#10; * @param label X축에 표시할 레이블 (예: 날짜, 요일 등)&#10; * @param segmentColors 각 세그먼트의 색상 (null인 경우 기본 색상 팔레트 사용)&#10; * @param isSelected 선택 상태 여부&#10; */&#10;data class StackedChartPoint(&#10;    val x: Float,&#10;    val values: List&lt;Float&gt;,&#10;    val label: String? = null,&#10;    val segmentColors: List&lt;Int&gt;? = null,&#10;    val isSelected: Boolean = false&#10;) {&#10;&#10;    val total: Float = values.sum()&#10;    &#10;    override fun toString(): String {&#10;        return &quot;StackedChartPoint(x=$x, values=$values, total=$total, label=$label, isSelected=$isSelected)&quot;&#10;    }&#10;}&#10;&#10;/**&#10; * 프로그레스 차트를 위한 데이터 포인트 클래스&#10; * &#10; * @param x X축 위치 또는 인덱스 (0, 1, 2 for Move, Exercise, Stand)&#10; * @param current 현재 값&#10; * @param max 최대 값&#10; * @param label 라벨 (예: &quot;Move&quot;, &quot;Exercise&quot;, &quot;Stand&quot;)&#10; * @param unit 단위 (예: &quot;KJ&quot;, &quot;min&quot;, &quot;h&quot;)&#10; * @param color 색상 (null인 경우 기본 색상 팔레트 사용)&#10; * @param isSelected 선택 상태 여부&#10; */&#10;data class ProgressChartPoint(&#10;    val x: Float,&#10;    val current: Float,&#10;    val max: Float,&#10;    val label: String? = null,&#10;    val unit: String? = null,&#10;    val color: Int? = null,&#10;    val isSelected: Boolean = false&#10;) {&#10;    val progress: Float = if (max &gt; 0f) (current / max).coerceIn(0f, 1f) else 0f&#10;    val percentage: Float = progress * 100f&#10;    &#10;    override fun toString(): String {&#10;        return &quot;ProgressChartPoint(x=$x, current=$current, max=$max, progress=$progress, label=$label, unit=$unit)&quot;&#10;    }&#10;}&#10;&#10;/**&#10; * 시간 기반 원시 데이터 포인트&#10; * ChartPoint로 변환해서 사용&#10; * @param timestamp 데이터 발생 시각&#10; * @param value 측정값&#10; * @param label 데이터 레이블 (선택사항)&#10; */&#10;data class TimeDataPoint(&#10;    val x : List&lt;String&gt;,&#10;    val y : List&lt;Float&gt;,&#10;    val timeUnit : TimeUnitGroup = TimeUnitGroup.HOUR,&#10;    val label: String? = null&#10;)&#10;&#10;/**&#10; * TimeDataPoint를 ChartPoint 리스트로 변환하는 확장 함수&#10; *&#10; * @return ChartPoint 리스트&#10; */&#10;fun TimeDataPoint.toChartPoints(): List&lt;ChartPoint&gt; {&#10;    Log.d(&quot;toChartPoints&quot;, &quot;=== TimeDataPoint -&gt; ChartPoint 변환 시작 ===&quot;)&#10;    Log.d(&quot;toChartPoints&quot;, &quot;입력 데이터 크기: ${x.size}개, 시간 단위: $timeUnit&quot;)&#10;    Log.d(&quot;toChartPoints&quot;, &quot;Y값 범위: min=${y.minOrNull()}, max=${y.maxOrNull()}&quot;)&#10;    Log.d(&quot;toChartPoints&quot;, &quot;첫 3개 Y값: ${y.take(3)}&quot;)&#10;&#10;    // DataTransformer에서 변환된 데이터의 경우, 적절한 레이블 생성&#10;    val labels = when (timeUnit) {&#10;        TimeUnitGroup.HOUR -&gt; {&#10;            // ISO 타임스탬프에서 시간 추출하여 &quot;시간시&quot; 형태로 변환&#10;            x.map { isoString -&gt;&#10;                try {&#10;                    val cleanedString = isoString.replace(&quot;Z&quot;, &quot;&quot;)&#10;                    val dateTime = LocalDateTime.parse(cleanedString, DateTimeFormatter.ISO_DATE_TIME)&#10;                    &quot;${dateTime.hour}시&quot;&#10;                } catch (e: Exception) {&#10;                    isoString // 파싱 실패시 원본 문자열 사용&#10;                }&#10;            }&#10;        }&#10;        TimeUnitGroup.DAY -&gt; {&#10;            // ISO 타임스탬프에서 날짜 추출하여 &quot;월/일&quot; 형태로 변환&#10;            x.map { isoString -&gt;&#10;                try {&#10;                    val cleanedString = isoString.replace(&quot;Z&quot;, &quot;&quot;)&#10;                    val dateTime = LocalDateTime.parse(cleanedString, DateTimeFormatter.ISO_DATE_TIME)&#10;                    &quot;${dateTime.monthValue}/${dateTime.dayOfMonth}&quot;&#10;                } catch (e: Exception) {&#10;                    isoString // 파싱 실패시 원본 문자열 사용&#10;                }&#10;            }&#10;        }&#10;        TimeUnitGroup.WEEK -&gt; {&#10;            // ISO 타임스탬프에서 주 정보 추출하여 &quot;월 주차&quot; 형태로 변환&#10;            x.map { isoString -&gt;&#10;                try {&#10;                    val cleanedString = isoString.replace(&quot;Z&quot;, &quot;&quot;)&#10;                    val dateTime = LocalDateTime.parse(cleanedString, DateTimeFormatter.ISO_DATE_TIME)&#10;                    val monday = dateTime.toLocalDate().minusDays((dateTime.dayOfWeek.value - 1).toLong())&#10;                    val firstMondayOfMonth = LocalDate.of(monday.year, monday.month, 1)&#10;                        .let { firstDay -&gt;&#10;                            val dayOfWeek = firstDay.dayOfWeek.value&#10;                            if (dayOfWeek == 1) firstDay else firstDay.minusDays((dayOfWeek - 1).toLong())&#10;                        }&#10;                    val weekNumber = ((monday.toEpochDay() - firstMondayOfMonth.toEpochDay()) / 7 + 1).toInt()&#10;                    &quot;${monday.monthValue}월 ${weekNumber}주차&quot;&#10;                } catch (e: Exception) {&#10;                    isoString // 파싱 실패시 원본 문자열 사용&#10;                }&#10;            }&#10;        }&#10;        TimeUnitGroup.MONTH -&gt; {&#10;            // ISO 타임스탬프에서 월 정보 추출하여 &quot;년 월&quot; 형태로 변환&#10;            x.map { isoString -&gt;&#10;                try {&#10;                    val cleanedString = isoString.replace(&quot;Z&quot;, &quot;&quot;)&#10;                    val dateTime = LocalDateTime.parse(cleanedString, DateTimeFormatter.ISO_DATE_TIME)&#10;                    &quot;${dateTime.year}년 ${dateTime.monthValue}월&quot;&#10;                } catch (e: Exception) {&#10;                    isoString // 파싱 실패시 원본 문자열 사용&#10;                }&#10;            }&#10;        }&#10;        TimeUnitGroup.YEAR -&gt; {&#10;            // ISO 타임스탬프에서 연도 정보 추출하여 &quot;년&quot; 형태로 변환&#10;            x.map { isoString -&gt;&#10;                try {&#10;                    val cleanedString = isoString.replace(&quot;Z&quot;, &quot;&quot;)&#10;                    val dateTime = LocalDateTime.parse(cleanedString, DateTimeFormatter.ISO_DATE_TIME)&#10;                    &quot;${dateTime.year}년&quot;&#10;                } catch (e: Exception) {&#10;                    isoString // 파싱 실패시 원본 문자열 사용&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    val result = x.indices.map { index -&gt;&#10;        ChartPoint(&#10;            x = index.toFloat(),&#10;            y = y[index],&#10;            label = labels.getOrNull(index) ?: x.getOrNull(index)&#10;        )&#10;    }&#10;&#10;    Log.d(&quot;toChartPoints&quot;, &quot;=== ChartPoint 변환 완료 ===&quot;)&#10;    Log.d(&quot;toChartPoints&quot;, &quot;결과 크기: ${result.size}개&quot;)&#10;    Log.d(&quot;toChartPoints&quot;, &quot;첫 3개 ChartPoint Y값: ${result.take(3).map { it.y }}&quot;)&#10;    Log.d(&quot;toChartPoints&quot;, &quot;첫 3개 ChartPoint 레이블: ${result.take(3).map { it.label }}&quot;)&#10;&#10;    // 음수 Y값 확인&#10;    val negativePoints = result.filter { it.y &lt; 0 }&#10;    if (negativePoints.isNotEmpty()) {&#10;        Log.w(&quot;toChartPoints&quot;, &quot;경고: 음수 Y값을 가진 ChartPoint 발견! ${negativePoints.size}개&quot;)&#10;        negativePoints.forEach { point -&gt;&#10;            Log.w(&quot;toChartPoints&quot;, &quot;  - ChartPoint(x=${point.x}, y=${point.y}, label=${point.label})&quot;)&#10;        }&#10;    }&#10;&#10;    return result&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart&#10;&#10;import com.hdil.saluschart.core.util.TimeUnitGroup&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import java.time.format.DateTimeFormatter&#10;&#10;data class ChartPoint(&#10;    val x: Float,&#10;    val y: Float,&#10;    val label: String? = null,&#10;    val color: Int? = null,&#10;    val isSelected: Boolean = false&#10;) {&#10;    override fun toString(): String {&#10;        return &quot;ChartPoint(x=$x, y=$y, label=$label, color=$color, isSelected=$isSelected)&quot;&#10;    }&#10;}&#10;&#10;/**&#10; * 범위 바 차트를 위한 데이터 포인트 클래스&#10; */&#10;data class RangeChartPoint(&#10;    val x: Float,&#10;    val yMin: Float,&#10;    val yMax: Float,&#10;    val label: String? = null,&#10;    val color: Int? = null,&#10;    val isSelected: Boolean = false&#10;) {&#10;    override fun toString(): String {&#10;        return &quot;RangeChartPoint(x=$x, yMin=$yMin, yMax=$yMax, label=$label, color=$color, isSelected=$isSelected)&quot;&#10;    }&#10;}&#10;&#10;/**&#10; * 스택 바 차트를 위한 데이터 포인트 클래스&#10; * &#10; * @param x X축 위치 또는 시간 인덱스&#10; * @param values 각 세그먼트의 값들 (예: [단백질, 지방, 탄수화물])&#10; * @param label X축에 표시할 레이블 (예: 날짜, 요일 등)&#10; * @param segmentColors 각 세그먼트의 색상 (null인 경우 기본 색상 팔레트 사용)&#10; * @param isSelected 선택 상태 여부&#10; */&#10;data class StackedChartPoint(&#10;    val x: Float,&#10;    val values: List&lt;Float&gt;,&#10;    val label: String? = null,&#10;    val segmentColors: List&lt;Int&gt;? = null,&#10;    val isSelected: Boolean = false&#10;) {&#10;&#10;    val total: Float = values.sum()&#10;    &#10;    override fun toString(): String {&#10;        return &quot;StackedChartPoint(x=$x, values=$values, total=$total, label=$label, isSelected=$isSelected)&quot;&#10;    }&#10;}&#10;&#10;/**&#10; * 프로그레스 차트를 위한 데이터 포인트 클래스&#10; * &#10; * @param x X축 위치 또는 인덱스 (0, 1, 2 for Move, Exercise, Stand)&#10; * @param current 현재 값&#10; * @param max 최대 값&#10; * @param label 라벨 (예: &quot;Move&quot;, &quot;Exercise&quot;, &quot;Stand&quot;)&#10; * @param unit 단위 (예: &quot;KJ&quot;, &quot;min&quot;, &quot;h&quot;)&#10; * @param color 색상 (null인 경우 기본 색상 팔레트 사용)&#10; * @param isSelected 선택 상태 여부&#10; */&#10;data class ProgressChartPoint(&#10;    val x: Float,&#10;    val current: Float,&#10;    val max: Float,&#10;    val label: String? = null,&#10;    val unit: String? = null,&#10;    val color: Int? = null,&#10;    val isSelected: Boolean = false&#10;) {&#10;    val progress: Float = if (max &gt; 0f) (current / max).coerceIn(0f, 1f) else 0f&#10;    val percentage: Float = progress * 100f&#10;    &#10;    override fun toString(): String {&#10;        return &quot;ProgressChartPoint(x=$x, current=$current, max=$max, progress=$progress, label=$label, unit=$unit)&quot;&#10;    }&#10;}&#10;&#10;/**&#10; * 시간 기반 원시 데이터 포인트&#10; * ChartPoint로 변환해서 사용&#10; * @param timestamp 데이터 발생 시각&#10; * @param value 측정값&#10; * @param label 데이터 레이블 (선택사항)&#10; */&#10;data class TimeDataPoint(&#10;    val x : List&lt;String&gt;,&#10;    val y : List&lt;Float&gt;,&#10;    val timeUnit : TimeUnitGroup = TimeUnitGroup.HOUR,&#10;    val label: String? = null&#10;)&#10;&#10;/**&#10; * TimeDataPoint를 ChartPoint 리스트로 변환하는 확장 함수&#10; *&#10; * @return ChartPoint 리스트&#10; */&#10;fun TimeDataPoint.toChartPoints(): List&lt;ChartPoint&gt; {&#10;    // DataTransformer에서 변환된 데이터의 경우, 적절한 레이블 생성&#10;    val labels = when (timeUnit) {&#10;        TimeUnitGroup.HOUR -&gt; {&#10;            // ISO 타임스탬프에서 시간 추출하여 &quot;시간시&quot; 형태로 변환&#10;            x.map { isoString -&gt;&#10;                try {&#10;                    val cleanedString = isoString.replace(&quot;Z&quot;, &quot;&quot;)&#10;                    val dateTime = LocalDateTime.parse(cleanedString, DateTimeFormatter.ISO_DATE_TIME)&#10;                    &quot;${dateTime.hour}시&quot;&#10;                } catch (e: Exception) {&#10;                    isoString // 파싱 실패시 원본 문자열 사용&#10;                }&#10;            }&#10;        }&#10;        TimeUnitGroup.DAY -&gt; {&#10;            // ISO 타임스탬프에서 날짜 추출하여 &quot;월/일&quot; 형태로 변환&#10;            x.map { isoString -&gt;&#10;                try {&#10;                    val cleanedString = isoString.replace(&quot;Z&quot;, &quot;&quot;)&#10;                    val dateTime = LocalDateTime.parse(cleanedString, DateTimeFormatter.ISO_DATE_TIME)&#10;                    &quot;${dateTime.monthValue}/${dateTime.dayOfMonth}&quot;&#10;                } catch (e: Exception) {&#10;                    isoString // 파싱 실패시 원본 문자열 사용&#10;                }&#10;            }&#10;        }&#10;        TimeUnitGroup.WEEK -&gt; {&#10;            // ISO 타임스탬프에서 주 정보 추출하여 &quot;월 주차&quot; 형태로 변환&#10;            x.map { isoString -&gt;&#10;                try {&#10;                    val cleanedString = isoString.replace(&quot;Z&quot;, &quot;&quot;)&#10;                    val dateTime = LocalDateTime.parse(cleanedString, DateTimeFormatter.ISO_DATE_TIME)&#10;                    val monday = dateTime.toLocalDate().minusDays((dateTime.dayOfWeek.value - 1).toLong())&#10;                    val firstMondayOfMonth = LocalDate.of(monday.year, monday.month, 1)&#10;                        .let { firstDay -&gt;&#10;                            val dayOfWeek = firstDay.dayOfWeek.value&#10;                            if (dayOfWeek == 1) firstDay else firstDay.minusDays((dayOfWeek - 1).toLong())&#10;                        }&#10;                    val weekNumber = ((monday.toEpochDay() - firstMondayOfMonth.toEpochDay()) / 7 + 1).toInt()&#10;                    &quot;${monday.monthValue}월 ${weekNumber}주차&quot;&#10;                } catch (e: Exception) {&#10;                    isoString // 파싱 실패시 원본 문자열 사용&#10;                }&#10;            }&#10;        }&#10;        TimeUnitGroup.MONTH -&gt; {&#10;            // ISO 타임스탬프에서 월 정보 추출하여 &quot;년 월&quot; 형태로 변환&#10;            x.map { isoString -&gt;&#10;                try {&#10;                    val cleanedString = isoString.replace(&quot;Z&quot;, &quot;&quot;)&#10;                    val dateTime = LocalDateTime.parse(cleanedString, DateTimeFormatter.ISO_DATE_TIME)&#10;                    &quot;${dateTime.year}년 ${dateTime.monthValue}월&quot;&#10;                } catch (e: Exception) {&#10;                    isoString // 파싱 실패시 원본 문자열 사용&#10;                }&#10;            }&#10;        }&#10;        TimeUnitGroup.YEAR -&gt; {&#10;            // ISO 타임스탬프에서 연도 정보 추출하여 &quot;년&quot; 형태로 변환&#10;            x.map { isoString -&gt;&#10;                try {&#10;                    val cleanedString = isoString.replace(&quot;Z&quot;, &quot;&quot;)&#10;                    val dateTime = LocalDateTime.parse(cleanedString, DateTimeFormatter.ISO_DATE_TIME)&#10;                    &quot;${dateTime.year}년&quot;&#10;                } catch (e: Exception) {&#10;                    isoString // 파싱 실패시 원본 문자열 사용&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    return x.indices.map { index -&gt;&#10;        ChartPoint(&#10;            x = index.toFloat(),&#10;            y = y[index],&#10;            label = labels.getOrNull(index) ?: x.getOrNull(index)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/JsonMapper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/JsonMapper.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart&#10;&#10;object JsonMapper {&#10;    fun mapJsonToChartPoints(json: String): List&lt;ChartPoint&gt; {&#10;        // This is a placeholder for actual JSON parsing logic.&#10;        // In a real implementation, you would use a library like Gson or Moshi to parse the JSON string.&#10;        return TODO() // Return an empty list for now&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/transform/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/transform/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.transform&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(project(&quot;:core:chart&quot;)) // ChartPoint 사용&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-datetime:0.4.0&quot;) // 시간 필터링 등&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.transform&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(project(&quot;:core:chart&quot;)) // ChartPoint 사용&#10;    implementation(project(&quot;:core:util&quot;)) // TimeUnitGroup 사용&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-datetime:0.4.0&quot;) // 시간 필터링 등&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/transform/src/main/java/com/hdil/saluschart/core/transform/DataExtension.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/transform/src/main/java/com/hdil/saluschart/core/transform/DataExtension.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.transform&#10;&#10;import com.hdil.saluschart.core.util.TimeUnitGroup&#10;import com.hdil.saluschart.core.chart.TimeDataPoint&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.toChartPoints&#10;&#10;/**&#10; * TimeDataPoint에 대한 확장 함수 - 시간 단위 변환&#10; */&#10;fun TimeDataPoint.transform(&#10;    timeUnit: TimeUnitGroup = TimeUnitGroup.DAY&#10;): TimeDataPoint {&#10;    return DataTransformer().transform(&#10;        data = this,&#10;        transformTimeUnit = timeUnit&#10;    )&#10;}&#10;&#10;/**&#10; * TimeDataPoint 리스트에 대한 확장 함수 - 시간 단위 변환&#10; */&#10;fun List&lt;TimeDataPoint&gt;.transform(&#10;    timeUnit: TimeUnitGroup = TimeUnitGroup.DAY&#10;): List&lt;ChartPoint&gt; {&#10;    return this.map { dataPoint -&gt;&#10;        DataTransformer().transform(&#10;            data = dataPoint,&#10;            transformTimeUnit = timeUnit&#10;        )&#10;    }.flatMap { it.toChartPoints() }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/util/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/util/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.util&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(project(&quot;:core:chart&quot;)) // ChartPoint 사용&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0&quot;)&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.library)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;&#10;}&#10;android {&#10;    namespace = &quot;com.hdil.saluschart.core.util&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        minSdk = 30&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0&quot;)&#10;    // Core Android dependencies&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose BOM - manages all Compose library versions&#10;    implementation(platform(libs.androidx.compose.bom))&#10;&#10;    // Compose UI dependencies&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;&#10;    // Compose Foundation dependencies (for Canvas, layouts, shapes)&#10;    implementation(libs.androidx.compose.foundation)&#10;    implementation(libs.androidx.compose.foundation.layout)&#10;    implementation(libs.androidx.compose.runtime)&#10;&#10;    // Material3 for UI components and theming&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Testing dependencies&#10;    testImplementation(libs.junit)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>