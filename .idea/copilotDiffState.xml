<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/MinimalGaugeChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/MinimalGaugeChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import android.R.attr.maxWidth&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.BoxWithConstraints&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;&#10;/**&#10; * 미니멀 범위 바 차트 - 위젯이나 스마트워치 등 작은 화면용&#10; * 범위 데이터를 컨테이너 범위 내에서 표시하며, 상단에 범위 텍스트 표시&#10; * &#10; * @param modifier 모디파이어&#10; * @param data 범위 차트 데이터 (yMin, yMax 포함)&#10; * @param containerMin 컨테이너의 최소값 (전체 범위 시작)&#10; * @param containerMax 컨테이너의 최대값 (전체 범위 끝)&#10; * @param containerColor 컨테이너(배경) 바 색상&#10; * @param rangeColor 범위 바 색상&#10; * @param textColor 범위 텍스트 색상&#10; * @param showRangeText 범위 텍스트를 표시할지 여부&#10; * @param chartType 차트 타입 (사용되지 않음, 호환성을 위해 유지)&#10; */&#10;@Composable&#10;fun MinimalGaugeChart(&#10;    modifier: Modifier = Modifier,&#10;    data: RangeChartPoint,&#10;    containerMin: Float,&#10;    containerMax: Float,&#10;    containerColor: Color = Color.LightGray,&#10;    rangeColor: Color = Color(0xFFFF9500),&#10;    textColor: Color = Color.Black,&#10;    showRangeText: Boolean = true,&#10;    chartType: ChartType = ChartType.MINIMAL_GAUGE&#10;) {&#10;    // 데이터 범위가 컨테이너 범위를 벗어나지 않도록 클램핑&#10;    val clampedDataMin = data.yMin.coerceIn(containerMin, containerMax)&#10;    val clampedDataMax = data.yMax.coerceIn(containerMin, containerMax)&#10;&#10;    Column(&#10;        modifier = modifier.padding(8.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // 범위 텍스트 표시&#10;        if (showRangeText) {&#10;            RangeText(&#10;                dataMin = clampedDataMin,&#10;                dataMax = clampedDataMax,&#10;                textColor = textColor&#10;            )&#10;        }&#10;&#10;        // 게이지 바 컴포저블&#10;        GaugeBar(&#10;            dataMin = clampedDataMin,&#10;            dataMax = clampedDataMax,&#10;            containerMin = containerMin,&#10;            containerMax = containerMax,&#10;            containerColor = containerColor,&#10;            rangeColor = rangeColor&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 범위 텍스트를 표시하는 컴포저블&#10; */&#10;@Composable&#10;private fun RangeText(&#10;    dataMin: Float,&#10;    dataMax: Float,&#10;    textColor: Color&#10;) {&#10;    Text(&#10;        text = &quot;${dataMin.toInt()}-${dataMax.toInt()}&quot;,&#10;        color = textColor,&#10;        fontSize = 14.sp,&#10;        fontWeight = FontWeight.Medium,&#10;        textAlign = TextAlign.Center,&#10;        modifier = Modifier.padding(bottom = 8.dp)&#10;    )&#10;}&#10;&#10;/**&#10; * 게이지 바를 그리는 컴포저블&#10; */&#10;@Composable&#10;private fun GaugeBar(&#10;    dataMin: Float,&#10;    dataMax: Float,&#10;    containerMin: Float,&#10;    containerMax: Float,&#10;    containerColor: Color,&#10;    rangeColor: Color&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(24.dp)&#10;    ) {&#10;        val containerRange = containerMax - containerMin&#10;        val availableWidth = maxWidth&#10;&#10;        // 정규화된 위치와 크기 계산 (0.0 ~ 1.0 비율)&#10;        val startRatio = if (containerRange &gt; 0) {&#10;            (dataMin - containerMin) / containerRange&#10;        } else 0f&#10;        val widthRatio = if (containerRange &gt; 0) {&#10;            (dataMax - dataMin) / containerRange&#10;        } else 0f&#10;&#10;        // 실제 픽셀 단위로 변환&#10;        val rangeStartOffset = availableWidth * startRatio&#10;        val rangeWidth = availableWidth * widthRatio&#10;&#10;        // 컨테이너 바 (배경)&#10;        ContainerBar(&#10;            containerColor = containerColor,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(24.dp)&#10;        )&#10;&#10;        // 범위 바 (실제 데이터 범위)&#10;        RangeBar(&#10;            rangeColor = rangeColor,&#10;            startOffset = rangeStartOffset,&#10;            width = rangeWidth,&#10;            modifier = Modifier.height(24.dp)&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 컨테이너(배경) 바 컴포저블&#10; */&#10;@Composable&#10;private fun ContainerBar(&#10;    containerColor: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .clip(RoundedCornerShape(8.dp))&#10;            .background(containerColor)&#10;    )&#10;}&#10;&#10;/**&#10; * 범위 바 컴포저블&#10; */&#10;@Composable&#10;private fun RangeBar(&#10;    rangeColor: Color,&#10;    startOffset: Dp,&#10;    width: Dp,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .width(width)&#10;            .offset(x = startOffset)&#10;            .clip(RoundedCornerShape(8.dp))&#10;            .background(rangeColor)&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;&#10;/**&#10; * 미니멀 범위 바 차트 - 위젯이나 스마트워치 등 작은 화면용&#10; * 범위 데이터를 컨테이너 범위 내에서 표시하며, 상단에 범위 텍스트 표시&#10; * &#10; * @param modifier 모디파이어&#10; * @param data 범위 차트 데이터 (yMin, yMax 포함)&#10; * @param containerMin 컨테이너의 최소값 (전체 범위 시작)&#10; * @param containerMax 컨테이너의 최대값 (전체 범위 끝)&#10; * @param containerColor 컨테이너(배경) 바 색상&#10; * @param rangeColor 범위 바 색상&#10; * @param textColor 범위 텍스트 색상&#10; * @param showRangeText 범위 텍스트를 표시할지 여부&#10; * @param chartType 차트 타입 (사용되지 않음, 호환성을 위해 유지)&#10; */&#10;@Composable&#10;fun MinimalGaugeChart(&#10;    modifier: Modifier = Modifier,&#10;    data: RangeChartPoint,&#10;    containerMin: Float,&#10;    containerMax: Float,&#10;    containerColor: Color = Color.LightGray,&#10;    rangeColor: Color = Color(0xFFFF9500),&#10;    textColor: Color = Color.Black,&#10;    showRangeText: Boolean = true,&#10;    chartType: ChartType = ChartType.MINIMAL_GAUGE&#10;) {&#10;    // 데이터 범위가 컨테이너 범위를 벗어나지 않도록 클램핑&#10;    val clampedDataMin = data.yMin.coerceIn(containerMin, containerMax)&#10;    val clampedDataMax = data.yMax.coerceIn(containerMin, containerMax)&#10;&#10;    Column(&#10;        modifier = modifier.padding(8.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // 범위 텍스트 표시&#10;        if (showRangeText) {&#10;            RangeText(&#10;                dataMin = clampedDataMin,&#10;                dataMax = clampedDataMax,&#10;                textColor = textColor&#10;            )&#10;        }&#10;&#10;        // 게이지 바 컴포저블&#10;        GaugeBar(&#10;            dataMin = clampedDataMin,&#10;            dataMax = clampedDataMax,&#10;            containerMin = containerMin,&#10;            containerMax = containerMax,&#10;            containerColor = containerColor,&#10;            rangeColor = rangeColor&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 범위 텍스트를 표시하는 컴포저블&#10; */&#10;@Composable&#10;private fun RangeText(&#10;    dataMin: Float,&#10;    dataMax: Float,&#10;    textColor: Color&#10;) {&#10;    Text(&#10;        text = &quot;${dataMin.toInt()}-${dataMax.toInt()}&quot;,&#10;        color = textColor,&#10;        fontSize = 14.sp,&#10;        fontWeight = FontWeight.Medium,&#10;        textAlign = TextAlign.Center,&#10;        modifier = Modifier.padding(bottom = 8.dp)&#10;    )&#10;}&#10;&#10;/**&#10; * 게이지 바를 그리는 컴포저블&#10; */&#10;@Composable&#10;private fun GaugeBar(&#10;    dataMin: Float,&#10;    dataMax: Float,&#10;    containerMin: Float,&#10;    containerMax: Float,&#10;    containerColor: Color,&#10;    rangeColor: Color&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(24.dp)&#10;    ) {&#10;        val containerRange = containerMax - containerMin&#10;        &#10;        // 정규화된 위치와 크기 계산 (0.0 ~ 1.0 비율)&#10;        val startRatio = if (containerRange &gt; 0) {&#10;            (dataMin - containerMin) / containerRange&#10;        } else 0f&#10;        val widthRatio = if (containerRange &gt; 0) {&#10;            (dataMax - dataMin) / containerRange&#10;        } else 0f&#10;&#10;        // 컨테이너 바 (배경)&#10;        ContainerBar(&#10;            containerColor = containerColor,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(24.dp)&#10;        )&#10;&#10;        // 범위 바 (실제 데이터 범위)&#10;        RangeBar(&#10;            rangeColor = rangeColor,&#10;            startRatio = startRatio,&#10;            widthRatio = widthRatio,&#10;            modifier = Modifier.height(24.dp)&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 컨테이너(배경) 바 컴포저블&#10; */&#10;@Composable&#10;private fun ContainerBar(&#10;    containerColor: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .clip(RoundedCornerShape(8.dp))&#10;            .background(containerColor)&#10;    )&#10;}&#10;&#10;/**&#10; * 범위 바 컴포저블&#10; */&#10;@Composable&#10;private fun RangeBar(&#10;    rangeColor: Color,&#10;    startRatio: Float,&#10;    widthRatio: Float,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth(widthRatio)&#10;            .offset(x = (300.dp * startRatio)) // 기본 너비 기준으로 오프셋 계산&#10;            .clip(RoundedCornerShape(8.dp))&#10;            .background(rangeColor)&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>