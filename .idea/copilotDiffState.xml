<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/BarChartDraw.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/BarChartDraw.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import android.graphics.fonts.FontStyle&#10;import android.util.Log&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawContext&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.unit.times&#10;import com.hdil.saluschart.core.chart.BaseChartPoint&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw.formatTickLabel&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import kotlin.Boolean&#10;&#10;object BarChartDraw {&#10;    /**&#10;     * 바 차트의 X축 레이블을 그립니다 (첫 번째 레이블이 바 너비의 절반만큼 오른쪽에서 시작).&#10;     *&#10;     * @param ctx 그리기 컨텍스트&#10;     * @param labels X축에 표시할 레이블 목록&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param centered 텍스트를 중앙 정렬할지 여부 (기본값: true)&#10;     * @param textSize 레이블 텍스트 크기 (기본값: 28f)&#10;     */&#10;    fun drawBarXAxisLabels(&#10;        ctx: DrawContext,&#10;        labels: List&lt;String&gt;,&#10;        metrics: ChartMath.ChartMetrics,&#10;        centered: Boolean = true,&#10;        textSize: Float = 28f&#10;    ) {&#10;        val barWidth = metrics.chartWidth / labels.size / 2&#10;        val spacing = metrics.chartWidth / labels.size&#10;        labels.forEachIndexed { i, label -&gt;&#10;            // 차트 영역의 시작점(paddingX)에서 바의 중심까지 계산&#10;            val x = metrics.paddingX + barWidth + i * spacing&#10;            ctx.canvas.nativeCanvas.drawText(&#10;                label,&#10;                x,&#10;                metrics.chartHeight + 50f,&#10;                android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.DKGRAY&#10;                    this.textSize = textSize&#10;                    if (centered) {&#10;                        textAlign = android.graphics.Paint.Align.CENTER&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 바 차트 막대들을 Composable로 생성합니다.&#10;     * 상호작용 여부를 제어할 수 있습니다.&#10;     *&#10;     * @param minValues 바의 최소값 목록 (일반 바 차트는 0, 범위 바 차트는 실제 최소값)&#10;     * @param maxValues 바의 최대값 목록 (바의 상단 값)&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param color 바 색상 (단일 바용)&#10;     * @param barWidthRatio 바 너비 배수 (기본값: 0.8f)&#10;     * @param interactive true이면 클릭 가능하고 툴팁 표시, false이면 순수 시각적 렌더링 (기본값: true)&#10;     * @param useLineChartPositioning true이면 라인차트 ���지셔닝 사용, false이면 바차트 포지셔닝 사용 (기본값: false)&#10;     * @param onBarClick 바 클릭 시 호출되는 콜백 (바 인덱스, 툴팁 텍스트)&#10;     * @param chartType 차트 타입 (툴팁 위치 결정용)&#10;     * @param showTooltipForIndex 외부에서 제어되는 툴팁 표시 인덱스 (null이면 표시 안함)&#10;     * @param isTouchArea true이면 터치 영역용 (투명, 전체 높이, 상호작용 가능), false이면 일반 바 (기본값: false)&#10;     * @param customTooltipText 커스텀 툴팁 텍스트 목록 (null이면 기본 툴팁 사용)&#10;     * @param segmentIndex 스택 바 차트에서 세그먼트 인덱스 (툴팁 위치 조정용, null이면 기본 위치)&#10;     */&#10;    @Composable&#10;    fun BarMarker(&#10;        data: List&lt;BaseChartPoint&gt;,&#10;        minValues: List&lt;Float&gt;,&#10;        maxValues: List&lt;Float&gt;,&#10;        metrics: ChartMath.ChartMetrics,&#10;        color: Color = Color.Black,&#10;        barWidthRatio: Float = 0.8f,&#10;        interactive: Boolean = true,&#10;        useLineChartPositioning: Boolean = false,&#10;        onBarClick: ((Int, String) -&gt; Unit)? = null,&#10;        chartType: ChartType,&#10;        showTooltipForIndex: Int? = null,&#10;        isTouchArea: Boolean = false,&#10;        customTooltipText: List&lt;String&gt;? = null,&#10;        segmentIndex: Int? = null,&#10;        showLabel: Boolean = false,&#10;    ) {&#10;        val density = LocalDensity.current&#10;&#10;        // 터치 영역용인 경우 자동으로 파라미터 설정&#10;        val actualBarWidthRatio = if (isTouchArea) 1.0f else barWidthRatio&#10;        val actualInteractive = if (isTouchArea) true else interactive&#10;        &#10;        val dataSize = maxOf(minValues.size, maxValues.size)&#10;&#10;        (0 until dataSize).forEach { index -&gt;&#10;            // 값 추출&#10;            val minValue = minValues.getOrNull(index) ?: 0f&#10;            val maxValue = maxValues.getOrNull(index) ?: 0f&#10;            &#10;            // 색상 결정&#10;            val actualColor = if (isTouchArea) Color.Transparent else color&#10;            &#10;            // 툴팁 텍스트 결정: 커스텀 텍스트가 있으면 사용, 없으면 기본 로직 사용&#10;            val tooltipText = customTooltipText?.getOrNull(index) ?: run {&#10;                if (chartType == ChartType.STACKED_BAR) {&#10;                    // For stacked bars, always show segment value (maxValue - minValue)&#10;                    (maxValue - minValue).toInt().toString()&#10;                } else if (minValue == metrics.minY) {&#10;                    // For regular bars starting from chart minimum, show only max value&#10;                    maxValue.toInt().toString()&#10;                } else {&#10;                    // For range bars, show min-max range&#10;                    &quot;${minValue.toInt()}-${maxValue.toInt()}&quot;&#10;                }&#10;            }&#10;&#10;            // 바 높이와 위치 계산&#10;            val (barHeight, barY) = if (isTouchArea) {&#10;                // 전체 차트 높이 사용 (터치 영역용)&#10;                Pair(metrics.chartHeight, 0f)&#10;            } else {&#10;                // minValue에서 maxValue까지의 바 계산&#10;                val yMinScreen = metrics.chartHeight - ((minValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;                val yMaxScreen = metrics.chartHeight - ((maxValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;                val height = yMinScreen - yMaxScreen&#10;                Pair(height, yMaxScreen)&#10;            }&#10;&#10;            // 바 X 위치 계산 - 차트 타입에 따라 다른 포지셔닝 로직 사용&#10;            val (barWidth, barX) = if (useLineChartPositioning) {&#10;                // 라인차트 포지셔닝: 포인트 중심에 바 배치&#10;                val pointSpacing = if (dataSize &gt; 1) metrics.chartWidth / (dataSize - 1) else 0f&#10;                val pointX = metrics.paddingX + index * pointSpacing&#10;                &#10;                // 첫 번째와 마지막 바는 차트 영역을 벗어나지 않도록 절반 너비로 설정&#10;                val isFirstOrLast = (index == 0 || index == dataSize - 1) &amp;&amp; dataSize &gt; 1&#10;                val widthMultiplier = if (isFirstOrLast) 0.5f else 1.0f&#10;                val barW = if (dataSize &gt; 1) {&#10;                    pointSpacing * actualBarWidthRatio * widthMultiplier&#10;                } else {&#10;                    metrics.chartWidth * actualBarWidthRatio&#10;                }&#10;                &#10;                // 첫 번째 바는 오른쪽으로만 확장, 마지막 바는 왼쪽으로만 확장&#10;                val barXPos = when {&#10;                    index == 0 &amp;&amp; dataSize &gt; 1 -&gt; pointX // 첫 번째 바: 포인트에서 시작&#10;                    index == dataSize - 1 &amp;&amp; dataSize &gt; 1 -&gt; pointX - barW // 마지막 바: 포인트에서 끝&#10;                    else -&gt; pointX - barW / 2f // 중간 바들: 포인트 중심&#10;                }&#10;                &#10;                Pair(barW, barXPos)&#10;            } else {&#10;                // 바차트 포지셔닝: 할당된 공간의 중앙에 배치&#10;                val barW = metrics.chartWidth / dataSize * actualBarWidthRatio&#10;                val spacing = metrics.chartWidth / dataSize&#10;                val barXPos = metrics.paddingX + index * spacing + (spacing - barW) / 2f&#10;                Pair(barW, barXPos)&#10;            }&#10;&#10;            // Float 좌표를 Dp로 변환&#10;            val barXDp = with(density) { barX.toDp() }&#10;            val barYDp = with(density) { barY.toDp() }&#10;            val barWidthDp = with(density) { barWidth.toDp() }&#10;            val barHeightDp = with(density) { barHeight.toDp() }&#10;&#10;&#10;            if (actualInteractive) {&#10;                // 각 바의 툴팁 표시 상태&#10;                var showTooltip by remember { mutableStateOf(false) }&#10;&#10;                // 툴팁 표시 여부 결정: &#10;                // - isTouchArea = true인 경우 툴팁 표시 안함 (터치 영역용이므로)&#10;                // - 바 차트 타입이 아닌 경우 툴팁 표시 안함 (LINE, SCATTERPLOT 등은 PointMarker 사용)&#10;                val shouldShowTooltip = when {&#10;                    isTouchArea -&gt; false // 터치 영역용이므로 툴팁 표시 안함&#10;                    chartType in listOf(ChartType.BAR, ChartType.RANGE_BAR, ChartType.STACKED_BAR) -&gt; {&#10;                        if (actualInteractive) showTooltip else (showTooltipForIndex == index)&#10;                    }&#10;                    else -&gt; false // LINE, SCATTERPLOT 등에서는 툴팁 표시 안함&#10;                }&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .offset(x = barXDp, y = barYDp)&#10;                        .size(width = barWidthDp, height = barHeightDp)&#10;                        .background(color = actualColor)&#10;                        .clickable {&#10;                            // 툴팁 상태 토글&#10;                            showTooltip = !showTooltip&#10;                            // 외부 클릭 이벤트 처리&#10;                            onBarClick?.invoke(index, tooltipText)&#10;                        },&#10;                    contentAlignment = Alignment.TopCenter&#10;                ) {&#10;&#10;                    // label 표시 여부 결정&#10;                    if (showLabel) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .offset(0.dp, (0).dp) // 바 위에 표시&#10;                        ) {&#10;                            Text(&#10;                                text = maxValue.toInt().toString(),&#10;                                color = Color.White,&#10;                                fontSize = 12.sp,&#10;                                textAlign = TextAlign.Center,&#10;                                fontWeight = FontWeight.Bold,&#10;                                modifier = Modifier&#10;                                    .align(Alignment.Center),&#10;                                maxLines = 1, // 한 줄로 제한하여 수평 확장 유도&#10;                                softWrap = false // 텍스트 래핑 비활성화&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // 툴팁 표시 (바 박스 외부에 독립적으로 배치)&#10;                if (shouldShowTooltip) {&#10;                    ChartTooltip(&#10;                        chartPoint = data[index],&#10;                        modifier = Modifier.offset(x = barXDp, y = barYDp - 80.dp)&#10;                    )&#10;                }&#10;            } else {&#10;                // 비상호작용 모드: 순수 시각적 렌더링만 (클릭 불가)&#10;                // 툴팁 표시 여부 결정:&#10;                // - isTouchArea = true인 경우 툴팁 표시 안함 (터치 영역용이므로)&#10;                // - 바 차트 타입이 아닌 경우 툴팁 표시 안함 (LINE, SCATTERPLOT 등은 PointMarker 사용)&#10;                val shouldShowTooltip = when {&#10;                    isTouchArea -&gt; false // 터치 영역용이므로 툴팁 표시 안함&#10;                    chartType in listOf(ChartType.BAR, ChartType.RANGE_BAR, ChartType.STACKED_BAR) -&gt; {&#10;                        showTooltipForIndex == index&#10;                    }&#10;                    else -&gt; false // LINE, SCATTERPLOT 등에서는 툴팁 표시 안함&#10;                }&#10;                &#10;                Box(&#10;                    modifier = Modifier&#10;                        .offset(x = barXDp, y = barYDp)&#10;                        .size(width = barWidthDp, height = barHeightDp)&#10;                        .background(color = actualColor)&#10;                ) {&#10;&#10;                    // label 표시 여부 결정&#10;                    if (showLabel) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .offset(0.dp, (0).dp) // 바 위에 표시&#10;&#10;                                .border(2.dp, Color.Red)&#10;                        ) {&#10;                            Text(&#10;                                text = maxValue.toInt().toString(),&#10;                                color = Color.White,&#10;                                fontSize = 12.sp,&#10;                                textAlign = TextAlign.Center,&#10;                                modifier = Modifier&#10;                                    .offset(0.dp, (0).dp) // 바 위에 표시&#10;                                    .align(Alignment.Center)&#10;                                    .width(IntrinsicSize.Min), // 최소 너비로 설정하여 수평 확장 유도&#10;                                maxLines = 1, // 한 줄로 제한하여 수평 확장 유도&#10;                                softWrap = false // 텍스트 래핑 비활성화&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // 외부에서 제어되는 툴팁 표시 (바 박스 외부에 독립적으로 배치)&#10;                if (shouldShowTooltip) {&#10;                    ChartTooltip(&#10;                        chartPoint = data[index],&#10;                        modifier = Modifier.offset(x = barXDp, y = barYDp - 80.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import android.graphics.fonts.FontStyle&#10;import android.util.Log&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawContext&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.unit.times&#10;import com.hdil.saluschart.core.chart.BaseChartPoint&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw.formatTickLabel&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import kotlin.Boolean&#10;&#10;object BarChartDraw {&#10;    /**&#10;     * 바 차트의 X축 레이블을 그립니다 (첫 번째 레이블이 바 너비의 절반만큼 오른쪽에서 시작).&#10;     *&#10;     * @param ctx 그리기 컨텍스트&#10;     * @param labels X축에 표시할 레이블 목록&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param centered 텍스트를 중앙 정렬할지 여부 (기본값: true)&#10;     * @param textSize 레이블 텍스트 크기 (기본값: 28f)&#10;     */&#10;    fun drawBarXAxisLabels(&#10;        ctx: DrawContext,&#10;        labels: List&lt;String&gt;,&#10;        metrics: ChartMath.ChartMetrics,&#10;        centered: Boolean = true,&#10;        textSize: Float = 28f&#10;    ) {&#10;        val barWidth = metrics.chartWidth / labels.size / 2&#10;        val spacing = metrics.chartWidth / labels.size&#10;        labels.forEachIndexed { i, label -&gt;&#10;            // 차트 영역의 시작점(paddingX)에서 바의 중심까지 계산&#10;            val x = metrics.paddingX + barWidth + i * spacing&#10;            ctx.canvas.nativeCanvas.drawText(&#10;                label,&#10;                x,&#10;                metrics.chartHeight + 50f,&#10;                android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.DKGRAY&#10;                    this.textSize = textSize&#10;                    if (centered) {&#10;                        textAlign = android.graphics.Paint.Align.CENTER&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 바 차트 막대들을 Composable로 생성합니다.&#10;     * 상호작용 여부를 제어할 수 있습니다.&#10;     *&#10;     * @param minValues 바의 최소값 목록 (일반 바 차트는 0, 범위 바 차트는 실제 최소값)&#10;     * @param maxValues 바의 최대값 목록 (바의 상단 값)&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param color 바 색상 (단일 바용)&#10;     * @param barWidthRatio 바 너비 배수 (기본값: 0.8f)&#10;     * @param interactive true이면 클릭 가능하고 툴팁 표시, false이면 순수 시각적 렌더링 (기본값: true)&#10;     * @param useLineChartPositioning true이면 라인차트 ���지셔닝 사용, false이면 바차트 포지셔닝 사용 (기본값: false)&#10;     * @param onBarClick 바 클릭 시 호출되는 콜백 (바 인덱스, 툴팁 텍스트)&#10;     * @param chartType 차트 타입 (툴팁 위치 결정용)&#10;     * @param showTooltipForIndex 외부에서 제어되는 툴팁 표시 인덱스 (null이면 표시 안함)&#10;     * @param isTouchArea true이면 터치 영역용 (투명, 전체 높이, 상호작용 가능), false이면 일반 바 (기본값: false)&#10;     * @param customTooltipText 커스텀 툴팁 텍스트 목록 (null이면 기본 툴팁 사용)&#10;     * @param segmentIndex 스택 바 차트에서 세그먼트 인덱스 (툴팁 위치 조정용, null이면 기본 위치)&#10;     */&#10;    @Composable&#10;    fun BarMarker(&#10;        data: List&lt;BaseChartPoint&gt;,&#10;        minValues: List&lt;Float&gt;,&#10;        maxValues: List&lt;Float&gt;,&#10;        metrics: ChartMath.ChartMetrics,&#10;        color: Color = Color.Black,&#10;        barWidthRatio: Float = 0.8f,&#10;        interactive: Boolean = true,&#10;        useLineChartPositioning: Boolean = false,&#10;        onBarClick: ((Int, String) -&gt; Unit)? = null,&#10;        chartType: ChartType,&#10;        showTooltipForIndex: Int? = null,&#10;        isTouchArea: Boolean = false,&#10;        customTooltipText: List&lt;String&gt;? = null,&#10;        segmentIndex: Int? = null,&#10;        showLabel: Boolean = false,&#10;    ) {&#10;        val density = LocalDensity.current&#10;&#10;        // 터치 영역용인 경우 자동으로 파라미터 설정&#10;        val actualBarWidthRatio = if (isTouchArea) 1.0f else barWidthRatio&#10;        val actualInteractive = if (isTouchArea) true else interactive&#10;        &#10;        val dataSize = maxOf(minValues.size, maxValues.size)&#10;&#10;        (0 until dataSize).forEach { index -&gt;&#10;            // 값 추출&#10;            val minValue = minValues.getOrNull(index) ?: 0f&#10;            val maxValue = maxValues.getOrNull(index) ?: 0f&#10;            &#10;            // 색상 결정&#10;            val actualColor = if (isTouchArea) Color.Transparent else color&#10;            &#10;            // 툴팁 텍스트 결정: 커스텀 텍스트가 있으면 사용, 없으면 기본 로직 사용&#10;            val tooltipText = customTooltipText?.getOrNull(index) ?: run {&#10;                if (chartType == ChartType.STACKED_BAR) {&#10;                    // For stacked bars, always show segment value (maxValue - minValue)&#10;                    (maxValue - minValue).toInt().toString()&#10;                } else if (minValue == metrics.minY) {&#10;                    // For regular bars starting from chart minimum, show only max value&#10;                    maxValue.toInt().toString()&#10;                } else {&#10;                    // For range bars, show min-max range&#10;                    &quot;${minValue.toInt()}-${maxValue.toInt()}&quot;&#10;                }&#10;            }&#10;&#10;            // 바 높이와 위치 계산&#10;            val (barHeight, barY) = if (isTouchArea) {&#10;                // 전체 차트 높이 사용 (터치 영역용)&#10;                Pair(metrics.chartHeight, 0f)&#10;            } else {&#10;                // minValue에서 maxValue까지의 바 계산&#10;                val yMinScreen = metrics.chartHeight - ((minValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;                val yMaxScreen = metrics.chartHeight - ((maxValue - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;                val height = yMinScreen - yMaxScreen&#10;                Pair(height, yMaxScreen)&#10;            }&#10;&#10;            // 바 X 위치 계산 - 차트 타입에 따라 다른 포지셔닝 로직 사용&#10;            val (barWidth, barX) = if (useLineChartPositioning) {&#10;                // 라인차트 포지셔닝: 포인트 중심에 바 배치&#10;                val pointSpacing = if (dataSize &gt; 1) metrics.chartWidth / (dataSize - 1) else 0f&#10;                val pointX = metrics.paddingX + index * pointSpacing&#10;                &#10;                // 첫 번째와 마지막 바는 차트 영역을 벗어나지 않도록 절반 너비로 설정&#10;                val isFirstOrLast = (index == 0 || index == dataSize - 1) &amp;&amp; dataSize &gt; 1&#10;                val widthMultiplier = if (isFirstOrLast) 0.5f else 1.0f&#10;                val barW = if (dataSize &gt; 1) {&#10;                    pointSpacing * actualBarWidthRatio * widthMultiplier&#10;                } else {&#10;                    metrics.chartWidth * actualBarWidthRatio&#10;                }&#10;                &#10;                // 첫 번째 바는 오른쪽으로만 확장, 마지막 바는 왼쪽으로만 확장&#10;                val barXPos = when {&#10;                    index == 0 &amp;&amp; dataSize &gt; 1 -&gt; pointX // 첫 번째 바: 포인트에서 시작&#10;                    index == dataSize - 1 &amp;&amp; dataSize &gt; 1 -&gt; pointX - barW // 마지막 바: 포인트에서 끝&#10;                    else -&gt; pointX - barW / 2f // 중간 바들: 포인트 중심&#10;                }&#10;                &#10;                Pair(barW, barXPos)&#10;            } else {&#10;                // 바차트 포지셔닝: 할당된 공간의 중앙에 배치&#10;                val barW = metrics.chartWidth / dataSize * actualBarWidthRatio&#10;                val spacing = metrics.chartWidth / dataSize&#10;                val barXPos = metrics.paddingX + index * spacing + (spacing - barW) / 2f&#10;                Pair(barW, barXPos)&#10;            }&#10;&#10;            // Float 좌표를 Dp로 변환&#10;            val barXDp = with(density) { barX.toDp() }&#10;            val barYDp = with(density) { barY.toDp() }&#10;            val barWidthDp = with(density) { barWidth.toDp() }&#10;            val barHeightDp = with(density) { barHeight.toDp() }&#10;&#10;&#10;            if (actualInteractive) {&#10;                // 각 바의 툴팁 표시 상태&#10;                var showTooltip by remember { mutableStateOf(false) }&#10;&#10;                // 툴팁 표시 여부 결정: &#10;                // - isTouchArea = true인 경우 툴팁 표시 안함 (터치 영역용이므로)&#10;                // - 바 차트 타입이 아닌 경우 툴팁 표시 안함 (LINE, SCATTERPLOT 등은 PointMarker 사용)&#10;                val shouldShowTooltip = when {&#10;                    isTouchArea -&gt; false // 터치 영역용이므로 툴팁 표시 안함&#10;                    chartType in listOf(ChartType.BAR, ChartType.RANGE_BAR, ChartType.STACKED_BAR) -&gt; {&#10;                        if (actualInteractive) showTooltip else (showTooltipForIndex == index)&#10;                    }&#10;                    else -&gt; false // LINE, SCATTERPLOT 등에서는 툴팁 표시 안함&#10;                }&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .offset(x = barXDp, y = barYDp)&#10;                        .size(width = barWidthDp, height = barHeightDp)&#10;                        .background(color = actualColor)&#10;                        .clickable {&#10;                            // 툴팁 상태 토글&#10;                            showTooltip = !showTooltip&#10;                            // 외부 클릭 이벤트 처리&#10;                            onBarClick?.invoke(index, tooltipText)&#10;                        },&#10;                    contentAlignment = Alignment.TopCenter&#10;                ) {&#10;&#10;                    // label 표시 여부 결정&#10;                    if (showLabel) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .offset(0.dp, (0).dp) // 바 위에 표시&#10;                        ) {&#10;                            Text(&#10;                                text = maxValue.toInt().toString(),&#10;                                color = Color.White,&#10;                                fontSize = 12.sp,&#10;                                textAlign = TextAlign.Center,&#10;                                fontWeight = FontWeight.Bold,&#10;                                modifier = Modifier&#10;                                    .align(Alignment.Center),&#10;                                maxLines = 1, // 한 줄로 제한하여 수평 확장 유도&#10;                                softWrap = false // 텍스트 래핑 비활성화&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // 툴팁 표시 (바 박스 외부에 독립적으로 배치)&#10;                if (shouldShowTooltip) {&#10;                    ChartTooltip(&#10;                        chartPoint = data[index],&#10;                        modifier = Modifier.offset(x = barXDp, y = barYDp - 80.dp)&#10;                    )&#10;                }&#10;            } else {&#10;                // 비상호작용 모드: 순수 시각적 렌더링만 (클릭 불가)&#10;                // 툴팁 표시 여부 결정:&#10;                // - isTouchArea = true인 경우 툴팁 표시 안함 (터치 영역용이므로)&#10;                // - 바 차트 타입이 아닌 경우 툴팁 표시 안함 (LINE, SCATTERPLOT 등은 PointMarker 사용)&#10;                val shouldShowTooltip = when {&#10;                    isTouchArea -&gt; false // 터치 영역용이므로 툴팁 표시 안함&#10;                    chartType in listOf(ChartType.BAR, ChartType.RANGE_BAR, ChartType.STACKED_BAR) -&gt; {&#10;                        showTooltipForIndex == index&#10;                    }&#10;                    else -&gt; false // LINE, SCATTERPLOT 등에서는 툴팁 표시 안함&#10;                }&#10;                &#10;                Box(&#10;                    modifier = Modifier&#10;                        .offset(x = barXDp, y = barYDp)&#10;                        .size(width = barWidthDp, height = barHeightDp)&#10;                        .background(color = actualColor)&#10;                ) {&#10;&#10;                    // label 표시 여부 결정&#10;                    if (showLabel) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .offset(0.dp, (0).dp) // 바 위에 표시&#10;&#10;                                .border(2.dp, Color.Red)&#10;                        ) {&#10;                            Text(&#10;                                text = maxValue.toInt().toString(),&#10;                                color = Color.White,&#10;                                fontSize = 12.sp,&#10;                                textAlign = TextAlign.Center,&#10;                                modifier = Modifier&#10;                                    .offset(0.dp, (0).dp) // 바 위에 표시&#10;                                    .align(Alignment.Center)&#10;                                    .width(IntrinsicSize.Min), // 최소 너비로 설정하여 수평 확장 유도&#10;                                maxLines = 1, // 한 줄로 제한하여 수평 확장 유도&#10;                                softWrap = false // 텍스트 래핑 비활성화&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // 외부에서 제어되는 툴팁 표시 (바 박스 외부에 독립적으로 배치)&#10;                if (shouldShowTooltip) {&#10;                    ChartTooltip(&#10;                        chartPoint = data[index],&#10;                        modifier = Modifier.offset(x = barXDp, y = barYDp - 80.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/ChartDraw.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/ChartDraw.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import android.util.Log&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;object ChartDraw {&#10;&#10;    var Pie = PieChartDraw&#10;    val RangeBar = RangeBarChartDraw&#10;    val Line = LineChartDraw&#10;    val Bar = BarChartDraw&#10;    val Scatter = ScatterPlotDraw&#10;    val Progress = ProgressChartDraw&#10;    val Gauge = GaugeChartDraw&#10;&#10;    /**&#10;     * 눈금 값을 적절한 형식으로 포맷합니다.&#10;     *&#10;     * @param value 눈금 값&#10;     * @return 포맷된 문자열&#10;     */&#10;    fun formatTickLabel(value: Float): String {&#10;        return when {&#10;            value == 0f -&gt; &quot;0&quot;&#10;            value &gt;= 1000000 -&gt; &quot;%.1fM&quot;.format(value / 1000000)&#10;            value &gt;= 1000 -&gt; &quot;%.1fK&quot;.format(value / 1000)&#10;            value % 1 == 0f -&gt; &quot;%.0f&quot;.format(value)&#10;            else -&gt; &quot;%.1f&quot;.format(value)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Y축 그리드와 레이블을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yPosition Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;     */&#10;    fun drawGrid(drawScope: DrawScope, size: Size, metrics: ChartMath.ChartMetrics, yPosition: String = &quot;left&quot;) {&#10;        // Y축 라인의 실제 X 좌표 계산&#10;        val yAxisX = when (yPosition) {&#10;            &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth&#10;            else -&gt; metrics.paddingX&#10;        }&#10;&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            val y = metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // 그리드 라인은 차트 영역 전체에 걸쳐 그리기&#10;            val gridStart = when (yPosition) {&#10;                &quot;right&quot; -&gt; metrics.paddingX // 오른쪽 Y축일 때는 왼쪽부터 시작&#10;                else -&gt; metrics.paddingX // 왼쪽 Y축일 때도 왼쪽부터 시작&#10;            }&#10;            val gridEnd = when (yPosition) {&#10;                &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 Y축까지&#10;                else -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 끝까지&#10;            }&#10;&#10;            drawScope.drawLine(&#10;                color = Color.LightGray,&#10;                start = Offset(gridStart, y),&#10;                end = Offset(gridEnd, y),&#10;                strokeWidth = 1f&#10;            )&#10;            &#10;            val labelText = formatTickLabel(yVal)&#10;            &#10;            // Y축 레이블 위치를 yPosition에 따라 결정&#10;            val labelX = when (yPosition) {&#10;                &quot;right&quot; -&gt; yAxisX + 10f // 오른쪽 Y축 라인의 오른쪽에 위치&#10;                else -&gt; 10f // 기본값: 왼쪽 위치&#10;            }&#10;            &#10;            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;                labelText,&#10;                labelX,&#10;                y + 10f,&#10;                android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.DKGRAY&#10;                    textSize = 28f&#10;                    // 오른쪽 Y축일 때는 왼쪽 정렬, 왼쪽 Y축일 때는 왼쪽 정렬&#10;                    textAlign = android.graphics.Paint.Align.LEFT&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * X축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     */&#10;    fun drawXAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics) {&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(metrics.paddingX, metrics.chartHeight),&#10;            end = Offset(metrics.paddingX + metrics.chartWidth, metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Y축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yPosition Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;     */&#10;    fun drawYAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics, yPosition: String = &quot;left&quot;) {&#10;        // Y축 라인 위치를 yPosition에 따라 결정&#10;        val axisStartX = when (yPosition) {&#10;            &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 위치&#10;            else -&gt; metrics.paddingX // 기본값: 왼쪽 위치&#10;        }&#10;&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisStartX, 0f),&#10;            end = Offset(axisStartX, metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;// ** 쓰이지 않는 Canvas API를 사용한 코드 **&#10;//&#10;//    /**&#10;//     * 범례를 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록&#10;//     * @param colors 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (null인 경우 제목 없음)&#10;//     * @param baseItemHeight 기본 항목 간 세로 간격 (스케일링 적용됨)&#10;//     */&#10;//    fun drawLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        baseItemHeight: Float = 20f&#10;//    ) {&#10;//        // 차트 크기에 따른 스케일 팩터 계산 (기준: 250x250)&#10;//        val scaleFactor = minOf(chartSize.width, chartSize.height) / 250f&#10;//        val clampedScale = scaleFactor.coerceIn(0.5f, 2.0f)&#10;//&#10;//        val colorBoxSize = (8f * clampedScale).coerceAtLeast(4f)&#10;//        val padding = (4f * clampedScale).coerceAtLeast(2f)&#10;//        val itemHeight = baseItemHeight * clampedScale&#10;//        val titleTextSize = (14f * clampedScale).coerceAtLeast(10f)&#10;//        val labelTextSize = (12f * clampedScale).coerceAtLeast(8f)&#10;//&#10;//        Log.e(&quot;ChartDraw&quot;, &quot;Legend scale factor: $clampedScale, itemHeight: $itemHeight, colorBoxSize: $colorBoxSize, labelTextSize: $labelTextSize&quot;)&#10;//&#10;//        var yOffset = position.y&#10;//&#10;//        // 범례 제목 그리기 (제공된 경우)&#10;//        title?.let {&#10;//            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//                it,&#10;//                position.x,&#10;//                yOffset,&#10;//                android.graphics.Paint().apply {&#10;//                    color = android.graphics.Color.DKGRAY&#10;//                    textSize = titleTextSize&#10;//                    isFakeBoldText = true&#10;//                }&#10;//            )&#10;//            yOffset += itemHeight * 0.8f&#10;//        }&#10;//&#10;//        // 각 범례 항목 그리기&#10;//        labels.forEachIndexed { index, label -&gt;&#10;//            if (index &lt; colors.size) {&#10;//                drawLegendItem(&#10;//                    drawScope,&#10;//                    colors[index],&#10;//                    label,&#10;//                    Offset(position.x, yOffset),&#10;//                    colorBoxSize,&#10;//                    padding,&#10;//                    labelTextSize&#10;//                )&#10;//                yOffset += itemHeight * 0.7f&#10;//            }&#10;//        }&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트의 범례를 그립니다 (통합된 범례 시스템, 스케일링 지원).&#10;//     *&#10;//     * 파이 차트와 스택 바 차트 모두에서 사용할 수 있는 통합된 범례 시스템입니다.&#10;//     * 레이블을 직접 제공하거나 차트 데이터에서 추출할 수 있습니다.&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10;//     * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10;//     * @param colors 각 항목에 사용한 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (기본값: null)&#10;//     * @param itemHeight 항목 간 세로 간격&#10;//     */&#10;//    fun drawChartLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;? = null,&#10;//        chartData: List&lt;ChartPoint&gt;? = null,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        itemHeight: Float = 40f&#10;//    ) {&#10;//        val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;//            point.label ?: &quot;항목 ${i+1}&quot;&#10;//        } ?: emptyList()&#10;//&#10;//        drawLegend(drawScope, legendLabels, colors, position, chartSize, title, itemHeight)&#10;//    }&#10;//&#10;//    /**&#10;//     * 범례의 개별 항목을 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param color 색상&#10;//     * @param label 레이블 텍스트&#10;//     * @param position 항목이 표시될 위치&#10;//     * @param boxSize 색상 상자 크기 (이미 스케일링 적용됨)&#10;//     * @param padding 상자와 텍스트 사이 간격 (이미 스케일링 적용됨)&#10;//     * @param textSize 텍스트 크기 (이미 스케일링 적용됨)&#10;//     */&#10;//    fun drawLegendItem(&#10;//        drawScope: DrawScope,&#10;//        color: Color,&#10;//        label: String,&#10;//        position: Offset,&#10;//        boxSize: Float,&#10;//        padding: Float,&#10;//        textSize: Float = 30f&#10;//    ) {&#10;//        // 색상 상자 그리기&#10;//        drawScope.drawRect(&#10;//            color = color,&#10;//            topLeft = position,&#10;//            size = Size(boxSize, boxSize)&#10;//        )&#10;//&#10;//        // 레이블 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            label,&#10;//            position.x + boxSize + padding,&#10;//            position.y + boxSize,&#10;//            android.graphics.Paint().apply {&#10;//                this.color = android.graphics.Color.DKGRAY&#10;//                this.textSize = textSize&#10;//            }&#10;//        )&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트 툴팁을 그립니다 (모든 차트 타입에서 공통 사용).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param value 표시할 값&#10;//     * @param position 툴팁이 표시될 위치 (미리 계산된 최적 위치)&#10;//     * @param backgroundColor 툴팁 배경 색상&#10;//     * @param textColor 텍스트 색상&#10;//     * @param textSize 툴팁 텍스트 크기 (기본값: 32f)&#10;//     */&#10;//    fun drawTooltip(&#10;//        drawScope: DrawScope,&#10;//        value: Float,&#10;//        position: Offset,&#10;//        backgroundColor: Color = Color(0xE6333333), // 반투명 다크 그레이&#10;//        textColor: Int = android.graphics.Color.WHITE,&#10;//        textSize: Float = 32f&#10;//    ) {&#10;//        val tooltipText = formatTickLabel(value)&#10;//        val textPaint = android.graphics.Paint().apply {&#10;//            color = textColor&#10;//            this.textSize = textSize&#10;//            textAlign = android.graphics.Paint.Align.CENTER&#10;//        }&#10;//&#10;//        // 텍스트 크기 측정&#10;//        val textBounds = android.graphics.Rect()&#10;//        textPaint.getTextBounds(tooltipText, 0, tooltipText.length, textBounds)&#10;//&#10;//        // 툴팁 크기 계산 (패딩 포함)&#10;//        val padding = 16f&#10;//        val tooltipWidth = textBounds.width() + padding * 2&#10;//        val tooltipHeight = textBounds.height() + padding * 2&#10;//&#10;//        // 툴팁이 화면 밖으로 나가지 않도록 위치 조정&#10;//        val tooltipX = position.x.coerceIn(&#10;//            tooltipWidth / 2,&#10;//            drawScope.size.width - tooltipWidth / 2&#10;//        )&#10;//        val tooltipY = position.y.coerceIn(&#10;//            tooltipHeight / 2,&#10;//            drawScope.size.height - tooltipHeight / 2&#10;//        )&#10;//&#10;//        // 배경 그리기&#10;//        drawScope.drawRoundRect(&#10;//            color = backgroundColor,&#10;//            topLeft = Offset(tooltipX - tooltipWidth / 2, tooltipY - tooltipHeight / 2),&#10;//            size = Size(tooltipWidth, tooltipHeight),&#10;//            cornerRadius = androidx.compose.ui.geometry.CornerRadius(4f)&#10;//        )&#10;//&#10;//        // 텍스트 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            tooltipText,&#10;//            tooltipX,&#10;//            tooltipY + textBounds.height() / 2,&#10;//            textPaint&#10;//        )&#10;//    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import android.util.Log&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;object ChartDraw {&#10;&#10;    var Pie = PieChartDraw&#10;    val RangeBar = RangeBarChartDraw&#10;    val Line = LineChartDraw&#10;    val Bar = BarChartDraw&#10;    val Scatter = ScatterPlotDraw&#10;    val Progress = ProgressChartDraw&#10;    val Gauge = GaugeChartDraw&#10;&#10;    /**&#10;     * 눈금 값을 적절한 형식으로 포맷합니다.&#10;     *&#10;     * @param value 눈금 값&#10;     * @return 포맷된 문자열&#10;     */&#10;    fun formatTickLabel(value: Float): String {&#10;        return when {&#10;            value == 0f -&gt; &quot;0&quot;&#10;            value &gt;= 1000000 -&gt; &quot;%.1fM&quot;.format(value / 1000000)&#10;            value &gt;= 1000 -&gt; &quot;%.1fK&quot;.format(value / 1000)&#10;            value % 1 == 0f -&gt; &quot;%.0f&quot;.format(value)&#10;            else -&gt; &quot;%.1f&quot;.format(value)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Y축 그리드와 레이블을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yPosition Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;     */&#10;    fun drawGrid(drawScope: DrawScope, size: Size, metrics: ChartMath.ChartMetrics, yPosition: String = &quot;left&quot;) {&#10;        // Y축 라인의 실제 X 좌표 계산&#10;        val yAxisX = when (yPosition) {&#10;            &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth&#10;            else -&gt; metrics.paddingX&#10;        }&#10;&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            val y = metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // 그리드 라인은 차트 영역 전체에 걸쳐 그리기&#10;            val gridStart = when (yPosition) {&#10;                &quot;right&quot; -&gt; metrics.paddingX // 오른쪽 Y축일 때는 왼쪽부터 시작&#10;                else -&gt; metrics.paddingX // 왼쪽 Y축일 때도 왼쪽부터 시작&#10;            }&#10;            val gridEnd = when (yPosition) {&#10;                &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 Y축까지&#10;                else -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 끝까지&#10;            }&#10;&#10;            drawScope.drawLine(&#10;                color = Color.LightGray,&#10;                start = Offset(gridStart, y),&#10;                end = Offset(gridEnd, y),&#10;                strokeWidth = 1f&#10;            )&#10;            &#10;            val labelText = formatTickLabel(yVal)&#10;            &#10;            // Y축 레이블 위치를 yPosition에 따라 결정&#10;            val labelX = when (yPosition) {&#10;                &quot;right&quot; -&gt; yAxisX + 10f // 오른쪽 Y축 라인의 오른쪽에 위치&#10;                else -&gt; 10f // 기본값: 왼쪽 위치&#10;            }&#10;            &#10;            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;                labelText,&#10;                labelX,&#10;                y + 10f,&#10;                android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.DKGRAY&#10;                    textSize = 28f&#10;                    // 오른쪽 Y축일 때는 왼쪽 정렬, 왼쪽 Y축일 때는 왼쪽 정렬&#10;                    textAlign = android.graphics.Paint.Align.LEFT&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * X축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     */&#10;    fun drawXAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics) {&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(metrics.paddingX, metrics.chartHeight),&#10;            end = Offset(metrics.paddingX + metrics.chartWidth, metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Y축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yPosition Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;     */&#10;    fun drawYAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics, yPosition: String = &quot;left&quot;) {&#10;        // Y축 라인 위치를 yPosition에 따라 결정&#10;        val axisStartX = when (yPosition) {&#10;            &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 위치&#10;            else -&gt; metrics.paddingX // 기본값: 왼쪽 위치&#10;        }&#10;&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisStartX, 0f),&#10;            end = Offset(axisStartX, metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;// ** 쓰이지 않는 Canvas API를 사용한 코드 **&#10;//&#10;//    /**&#10;//     * 범례를 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록&#10;//     * @param colors 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (null인 경우 제목 없음)&#10;//     * @param baseItemHeight 기본 항목 간 세로 간격 (스케일링 적용됨)&#10;//     */&#10;//    fun drawLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        baseItemHeight: Float = 20f&#10;//    ) {&#10;//        // 차트 크기에 따른 스케일 팩터 계산 (기준: 250x250)&#10;//        val scaleFactor = minOf(chartSize.width, chartSize.height) / 250f&#10;//        val clampedScale = scaleFactor.coerceIn(0.5f, 2.0f)&#10;//&#10;//        val colorBoxSize = (8f * clampedScale).coerceAtLeast(4f)&#10;//        val padding = (4f * clampedScale).coerceAtLeast(2f)&#10;//        val itemHeight = baseItemHeight * clampedScale&#10;//        val titleTextSize = (14f * clampedScale).coerceAtLeast(10f)&#10;//        val labelTextSize = (12f * clampedScale).coerceAtLeast(8f)&#10;//&#10;//        Log.e(&quot;ChartDraw&quot;, &quot;Legend scale factor: $clampedScale, itemHeight: $itemHeight, colorBoxSize: $colorBoxSize, labelTextSize: $labelTextSize&quot;)&#10;//&#10;//        var yOffset = position.y&#10;//&#10;//        // 범례 제목 그리기 (제공된 경우)&#10;//        title?.let {&#10;//            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//                it,&#10;//                position.x,&#10;//                yOffset,&#10;//                android.graphics.Paint().apply {&#10;//                    color = android.graphics.Color.DKGRAY&#10;//                    textSize = titleTextSize&#10;//                    isFakeBoldText = true&#10;//                }&#10;//            )&#10;//            yOffset += itemHeight * 0.8f&#10;//        }&#10;//&#10;//        // 각 범례 항목 그리기&#10;//        labels.forEachIndexed { index, label -&gt;&#10;//            if (index &lt; colors.size) {&#10;//                drawLegendItem(&#10;//                    drawScope,&#10;//                    colors[index],&#10;//                    label,&#10;//                    Offset(position.x, yOffset),&#10;//                    colorBoxSize,&#10;//                    padding,&#10;//                    labelTextSize&#10;//                )&#10;//                yOffset += itemHeight * 0.7f&#10;//            }&#10;//        }&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트의 범례를 그립니다 (통합된 범례 시스템, 스케일링 지원).&#10;//     *&#10;//     * 파이 차트와 스택 바 차트 모두에서 사용할 수 있는 통합된 범례 시스템입니다.&#10;//     * 레이블을 직접 제공하거나 차트 데이터에서 추출할 수 있습니다.&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10;//     * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10;//     * @param colors 각 항목에 사용한 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (기본값: null)&#10;//     * @param itemHeight 항목 간 세로 간격&#10;//     */&#10;//    fun drawChartLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;? = null,&#10;//        chartData: List&lt;ChartPoint&gt;? = null,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        itemHeight: Float = 40f&#10;//    ) {&#10;//        val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;//            point.label ?: &quot;항목 ${i+1}&quot;&#10;//        } ?: emptyList()&#10;//&#10;//        drawLegend(drawScope, legendLabels, colors, position, chartSize, title, itemHeight)&#10;//    }&#10;//&#10;//    /**&#10;//     * 범례의 개별 항목을 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param color 색상&#10;//     * @param label 레이블 텍스트&#10;//     * @param position 항목이 표시될 위치&#10;//     * @param boxSize 색상 상자 크기 (이미 스케일링 적용됨)&#10;//     * @param padding 상자와 텍스트 사이 간격 (이미 스케일링 적용됨)&#10;//     * @param textSize 텍스트 크기 (이미 스케일링 적용됨)&#10;//     */&#10;//    fun drawLegendItem(&#10;//        drawScope: DrawScope,&#10;//        color: Color,&#10;//        label: String,&#10;//        position: Offset,&#10;//        boxSize: Float,&#10;//        padding: Float,&#10;//        textSize: Float = 30f&#10;//    ) {&#10;//        // 색상 상자 그리기&#10;//        drawScope.drawRect(&#10;//            color = color,&#10;//            topLeft = position,&#10;//            size = Size(boxSize, boxSize)&#10;//        )&#10;//&#10;//        // 레이블 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            label,&#10;//            position.x + boxSize + padding,&#10;//            position.y + boxSize,&#10;//            android.graphics.Paint().apply {&#10;//                this.color = android.graphics.Color.DKGRAY&#10;//                this.textSize = textSize&#10;//            }&#10;//        )&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트 툴팁을 그립니다 (모든 차트 타입에서 공통 사용).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param value 표시할 값&#10;//     * @param position 툴팁이 표시될 위치 (미리 계산된 최적 위치)&#10;//     * @param backgroundColor 툴팁 배경 색상&#10;//     * @param textColor 텍스트 색상&#10;//     * @param textSize 툴팁 텍스트 크기 (기본값: 32f)&#10;//     */&#10;//    fun drawTooltip(&#10;//        drawScope: DrawScope,&#10;//        value: Float,&#10;//        position: Offset,&#10;//        backgroundColor: Color = Color(0xE6333333), // 반투명 다크 그레이&#10;//        textColor: Int = android.graphics.Color.WHITE,&#10;//        textSize: Float = 32f&#10;//    ) {&#10;//        val tooltipText = formatTickLabel(value)&#10;//        val textPaint = android.graphics.Paint().apply {&#10;//            color = textColor&#10;//            this.textSize = textSize&#10;//            textAlign = android.graphics.Paint.Align.CENTER&#10;//        }&#10;//&#10;//        // 텍스트 크기 측정&#10;//        val textBounds = android.graphics.Rect()&#10;//        textPaint.getTextBounds(tooltipText, 0, tooltipText.length, textBounds)&#10;//&#10;//        // 툴팁 크기 계산 (패딩 포함)&#10;//        val padding = 16f&#10;//        val tooltipWidth = textBounds.width() + padding * 2&#10;//        val tooltipHeight = textBounds.height() + padding * 2&#10;//&#10;//        // 툴팁이 화면 밖으로 나가지 않도록 위치 조정&#10;//        val tooltipX = position.x.coerceIn(&#10;//            tooltipWidth / 2,&#10;//            drawScope.size.width - tooltipWidth / 2&#10;//        )&#10;//        val tooltipY = position.y.coerceIn(&#10;//            tooltipHeight / 2,&#10;//            drawScope.size.height - tooltipHeight / 2&#10;//        )&#10;//&#10;//        // 배경 그리기&#10;//        drawScope.drawRoundRect(&#10;//            color = backgroundColor,&#10;//            topLeft = Offset(tooltipX - tooltipWidth / 2, tooltipY - tooltipHeight / 2),&#10;//            size = Size(tooltipWidth, tooltipHeight),&#10;//            cornerRadius = androidx.compose.ui.geometry.CornerRadius(4f)&#10;//        )&#10;//&#10;//        // 텍스트 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            tooltipText,&#10;//            tooltipX,&#10;//            tooltipY + textBounds.height() / 2,&#10;//            textPaint&#10;//        )&#10;//    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/BarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/BarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun BarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,      // ChartPoint 기반&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Bar Chart Example&quot;,&#10;    barColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    minY: Float? = null,                    // 사용자 지정 최소 Y값&#10;    maxY: Float? = null,                    // 사용자 지정 최대 Y값&#10;    barWidthRatio: Float = 0.8f,       // 바 너비 배수&#10;    labelTextSize: Float = 28f,             // X축 레이블 텍스트 크기&#10;    tooltipTextSize: Float = 32f,           // 툴팁 텍스트 크기&#10;    interactionType: InteractionType = InteractionType.BAR, // 상호작용 타입&#10;    onBarClick: ((Int, Float) -&gt; Unit)? = null,  // 바 클릭 콜백&#10;    showLabel: Boolean = false,&#10;    chartType: ChartType = ChartType.BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.label ?: it.x.toString() }&#10;    val yValues = data.map { it.y }&#10;&#10;    var canvasSize by remember { mutableStateOf(androidx.compose.ui.geometry.Size.Zero) }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;    var selectedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            modifier = modifier&#10;        ) {&#10;            Canvas(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                val metrics = ChartMath.computeMetrics(&#10;                    size = size,&#10;                    values = yValues,&#10;                    chartType = ChartType.BAR,&#10;                    minY = minY,&#10;                    maxY = maxY&#10;                )&#10;&#10;                // Store metrics and canvas size for InteractiveBars&#10;                canvasSize = size&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.drawXAxis(this, metrics)&#10;                ChartDraw.drawYAxis(this, metrics)&#10;&#10;                ChartDraw.Bar.drawBarXAxisLabels(&#10;                    ctx = drawContext,&#10;                    labels = xLabels,&#10;                    metrics = metrics,&#10;                    textSize = labelTextSize&#10;                )&#10;            }&#10;&#10;            // Conditional interaction based on interactionType parameter&#10;            when (interactionType) {&#10;                InteractionType.TOUCH_AREA -&gt; {&#10;                    // Visual bars (non-interactive)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(yValues.size) { metrics.minY },&#10;                            maxValues = yValues,&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = false,&#10;                            chartType = ChartType.BAR,&#10;                            showTooltipForIndex = selectedBarIndex&#10;                        )&#10;                    }&#10;&#10;                    // Interactive bars overlay (transparent bars for easier touching)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(yValues.size) { metrics.minY },&#10;                            maxValues = yValues,&#10;                            metrics = metrics,&#10;                            onBarClick = { index, tooltipText -&gt;&#10;                                selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                onBarClick?.invoke(index, tooltipText.toFloat())&#10;                            },&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex,&#10;                            isTouchArea = true&#10;                        )&#10;                    }&#10;                }&#10;                InteractionType.BAR -&gt; {&#10;                    // Interactive visual bars (direct bar touching)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(yValues.size) { metrics.minY },&#10;                            maxValues = yValues,&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = true,&#10;                            onBarClick = { index, tooltipText -&gt;&#10;                                onBarClick?.invoke(index, tooltipText.toFloat())&#10;                            },&#10;                            chartType = chartType,&#10;                            showLabel = showLabel&#10;                        )&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    // Visual bars (non-interactive)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(yValues.size) { metrics.minY },&#10;                            maxValues = yValues,&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = false,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun BarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,      // ChartPoint 기반&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Bar Chart Example&quot;,&#10;    barColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    minY: Float? = null,                    // 사용자 지정 최소 Y값&#10;    maxY: Float? = null,                    // 사용자 지정 최대 Y값&#10;    barWidthRatio: Float = 0.8f,       // 바 너비 배수&#10;    labelTextSize: Float = 28f,             // X축 레이블 텍스트 크기&#10;    tooltipTextSize: Float = 32f,           // 툴팁 텍스트 크기&#10;    yPosition: String = &quot;left&quot;,             // Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;    interactionType: InteractionType = InteractionType.BAR, // 상호작용 타입&#10;    onBarClick: ((Int, Float) -&gt; Unit)? = null,  // 바 클릭 콜백&#10;    showLabel: Boolean = false,&#10;    chartType: ChartType = ChartType.BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.label ?: it.x.toString() }&#10;    val yValues = data.map { it.y }&#10;&#10;    var canvasSize by remember { mutableStateOf(androidx.compose.ui.geometry.Size.Zero) }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;    var selectedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            modifier = modifier&#10;        ) {&#10;            Canvas(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;                val metrics = ChartMath.computeMetrics(&#10;                    size = size,&#10;                    values = yValues,&#10;                    chartType = ChartType.BAR,&#10;                    minY = minY,&#10;                    maxY = maxY&#10;                )&#10;&#10;                // Store metrics and canvas size for InteractiveBars&#10;                canvasSize = size&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics, yPosition)&#10;                ChartDraw.drawXAxis(this, metrics)&#10;                ChartDraw.drawYAxis(this, metrics, yPosition)&#10;&#10;                ChartDraw.Bar.drawBarXAxisLabels(&#10;                    ctx = drawContext,&#10;                    labels = xLabels,&#10;                    metrics = metrics,&#10;                    textSize = labelTextSize&#10;                )&#10;            }&#10;&#10;            // Conditional interaction based on interactionType parameter&#10;            when (interactionType) {&#10;                InteractionType.TOUCH_AREA -&gt; {&#10;                    // Visual bars (non-interactive)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(yValues.size) { metrics.minY },&#10;                            maxValues = yValues,&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = false,&#10;                            chartType = ChartType.BAR,&#10;                            showTooltipForIndex = selectedBarIndex&#10;                        )&#10;                    }&#10;&#10;                    // Interactive bars overlay (transparent bars for easier touching)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(yValues.size) { metrics.minY },&#10;                            maxValues = yValues,&#10;                            metrics = metrics,&#10;                            onBarClick = { index, tooltipText -&gt;&#10;                                selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                onBarClick?.invoke(index, tooltipText.toFloat())&#10;                            },&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex,&#10;                            isTouchArea = true&#10;                        )&#10;                    }&#10;                }&#10;                InteractionType.BAR -&gt; {&#10;                    // Interactive visual bars (direct bar touching)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(yValues.size) { metrics.minY },&#10;                            maxValues = yValues,&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = true,&#10;                            onBarClick = { index, tooltipText -&gt;&#10;                                onBarClick?.invoke(index, tooltipText.toFloat())&#10;                            },&#10;                            chartType = chartType,&#10;                            showLabel = showLabel&#10;                        )&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    // Visual bars (non-interactive)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(yValues.size) { metrics.minY },&#10;                            maxValues = yValues,&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = false,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/LineChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/LineChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.chartDraw.LegendPosition&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun LineChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,      // ChartPoint 기반&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Line Chart Example&quot;,&#10;    lineColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    strokeWidth: Float = 4f,&#10;    minY: Float? = null,                    // 사용자 지정 최소 Y값&#10;    maxY: Float? = null,                    // 사용자 지정 최대 Y값&#10;    labelTextSize: Float = 28f,&#10;    tooltipTextSize: Float = 32f,&#10;    interactionType: InteractionType = InteractionType.POINT,&#10;    showPoint: Boolean = false, // 포인트 표시 여부&#10;    showLegend: Boolean = false,&#10;    legendPosition: LegendPosition = LegendPosition.BOTTOM,&#10;    chartType : ChartType = ChartType.LINE // 차트 타입 (툴팁 위치 결정용&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.x }&#10;    val yValues = data.map { it.y }&#10;&#10;    var canvasPoints by remember { mutableStateOf(listOf&lt;androidx.compose.ui.geometry.Offset&gt;()) }&#10;    var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;&#10;    var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(16.dp))&#10;&#10;        Box(&#10;            Modifier&#10;        ) {&#10;            Canvas(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;//                val metrics = ChartMath.computeMetrics(size, yValues)&#10;                val metrics = ChartMath.computeMetrics(&#10;                    size = size,&#10;                    values = yValues,&#10;                    chartType = ChartType.BAR,&#10;                    minY = minY, // 사용자 지정 최소 Y값&#10;                    maxY = maxY&#10;                )&#10;&#10;                val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;                // 포인트 위치와 캔버스 크기를 상태 변수에 저장&#10;                canvasPoints = points&#10;                canvasSize = size&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.Line.drawLine(this, points, lineColor, strokeWidth)&#10;                ChartDraw.Line.drawXAxisLabels(&#10;                    ctx = drawContext,&#10;                    labels = xLabels.map { it.toString() },&#10;                    metrics = metrics,&#10;                    textSize = labelTextSize&#10;                )&#10;            }&#10;&#10;//            if (showPoint) {&#10;            // Conditional interaction based on interactionType parameter&#10;                when (interactionType) {&#10;                    InteractionType.TOUCH_AREA -&gt; {&#10;                        // BarMarker interactions (invisible bars for easier touching)&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ChartDraw.Bar.BarMarker(&#10;                                data = data,&#10;                                minValues = List(yValues.size) { metrics.minY },&#10;                                maxValues = yValues,&#10;                                metrics = metrics,&#10;                                useLineChartPositioning = true,&#10;                                onBarClick = { index, tooltipText -&gt;&#10;                                    selectedPointIndex =&#10;                                        if (selectedPointIndex == index) null else index&#10;                                },&#10;                                isTouchArea = true,&#10;                                chartType = chartType,&#10;                                showTooltipForIndex = selectedPointIndex&#10;                            )&#10;                        }&#10;                        ChartDraw.Scatter.PointMarker(&#10;                            data = data,&#10;                            points = canvasPoints,&#10;                            values = yValues,&#10;                            color = lineColor,&#10;                            showPoint = showPoint,&#10;                            selectedPointIndex = selectedPointIndex,&#10;                            onPointClick = null,&#10;                            interactive = false,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedPointIndex&#10;                        )&#10;                    }&#10;                    InteractionType.POINT -&gt; {&#10;                        // PointMarker interactions (interactive data points)&#10;                        ChartDraw.Scatter.PointMarker(&#10;                            data = data,&#10;                            points = canvasPoints,&#10;                            values = yValues,&#10;                            color = lineColor,&#10;                            showPoint = showPoint,&#10;                            selectedPointIndex = selectedPointIndex,&#10;                            onPointClick = { index -&gt;&#10;                                // 이미 선택된 포인트를 다시 클릭하면 선택 해제(null로 설정)&#10;                                selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                            },&#10;                            interactive = true,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedPointIndex&#10;                        )&#10;                    }&#10;                    else -&gt; {&#10;                        // Non-interactive rendering&#10;                        ChartDraw.Scatter.PointMarker(&#10;                            data = data,&#10;                            points = canvasPoints,&#10;                            values = yValues,&#10;                            color = lineColor,&#10;                            selectedPointIndex = selectedPointIndex,&#10;                            onPointClick = null,&#10;                            interactive = false,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = null&#10;                        )&#10;                    }&#10;//                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.chartDraw.LegendPosition&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun LineChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,      // ChartPoint 기반&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Line Chart Example&quot;,&#10;    lineColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    strokeWidth: Float = 4f,&#10;    minY: Float? = null,                    // 사용자 지정 최소 Y값&#10;    maxY: Float? = null,                    // 사용자 지정 최대 Y값&#10;    labelTextSize: Float = 28f,&#10;    tooltipTextSize: Float = 32f,&#10;    yPosition: String = &quot;left&quot;,             // Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;    interactionType: InteractionType = InteractionType.POINT,&#10;    showPoint: Boolean = false, // 포인트 표시 여부&#10;    showLegend: Boolean = false,&#10;    legendPosition: LegendPosition = LegendPosition.BOTTOM,&#10;    chartType : ChartType = ChartType.LINE // 차트 타입 (툴팁 위치 결정용&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.x }&#10;    val yValues = data.map { it.y }&#10;&#10;    var canvasPoints by remember { mutableStateOf(listOf&lt;androidx.compose.ui.geometry.Offset&gt;()) }&#10;    var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;&#10;    var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(16.dp))&#10;&#10;        Box(&#10;            Modifier&#10;        ) {&#10;            Canvas(&#10;                modifier = Modifier.fillMaxSize()&#10;            ) {&#10;//                val metrics = ChartMath.computeMetrics(size, yValues)&#10;                val metrics = ChartMath.computeMetrics(&#10;                    size = size,&#10;                    values = yValues,&#10;                    chartType = ChartType.BAR,&#10;                    minY = minY, // 사용자 지정 최소 Y값&#10;                    maxY = maxY&#10;                )&#10;&#10;                val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;                // 포인트 위치와 캔버스 크기를 상태 변수에 저장&#10;                canvasPoints = points&#10;                canvasSize = size&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics, yPosition)&#10;                ChartDraw.Line.drawLine(this, points, lineColor, strokeWidth)&#10;                ChartDraw.Line.drawXAxisLabels(&#10;                    ctx = drawContext,&#10;                    labels = xLabels.map { it.toString() },&#10;                    metrics = metrics,&#10;                    textSize = labelTextSize&#10;                )&#10;            }&#10;&#10;//            if (showPoint) {&#10;            // Conditional interaction based on interactionType parameter&#10;                when (interactionType) {&#10;                    InteractionType.TOUCH_AREA -&gt; {&#10;                        // BarMarker interactions (invisible bars for easier touching)&#10;                        chartMetrics?.let { metrics -&gt;&#10;                            ChartDraw.Bar.BarMarker(&#10;                                data = data,&#10;                                minValues = List(yValues.size) { metrics.minY },&#10;                                maxValues = yValues,&#10;                                metrics = metrics,&#10;                                useLineChartPositioning = true,&#10;                                onBarClick = { index, tooltipText -&gt;&#10;                                    selectedPointIndex =&#10;                                        if (selectedPointIndex == index) null else index&#10;                                },&#10;                                isTouchArea = true,&#10;                                chartType = chartType,&#10;                                showTooltipForIndex = selectedPointIndex&#10;                            )&#10;                        }&#10;                        ChartDraw.Scatter.PointMarker(&#10;                            data = data,&#10;                            points = canvasPoints,&#10;                            values = yValues,&#10;                            color = lineColor,&#10;                            showPoint = showPoint,&#10;                            selectedPointIndex = selectedPointIndex,&#10;                            onPointClick = null,&#10;                            interactive = false,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedPointIndex&#10;                        )&#10;                    }&#10;                    InteractionType.POINT -&gt; {&#10;                        // PointMarker interactions (interactive data points)&#10;                        ChartDraw.Scatter.PointMarker(&#10;                            data = data,&#10;                            points = canvasPoints,&#10;                            values = yValues,&#10;                            color = lineColor,&#10;                            showPoint = showPoint,&#10;                            selectedPointIndex = selectedPointIndex,&#10;                            onPointClick = { index -&gt;&#10;                                // 이미 선택된 포인트를 다시 클릭하면 선택 해제(null로 설정)&#10;                                selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                            },&#10;                            interactive = true,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedPointIndex&#10;                        )&#10;                    }&#10;                    else -&gt; {&#10;                        // Non-interactive rendering&#10;                        ChartDraw.Scatter.PointMarker(&#10;                            data = data,&#10;                            points = canvasPoints,&#10;                            values = yValues,&#10;                            color = lineColor,&#10;                            selectedPointIndex = selectedPointIndex,&#10;                            onPointClick = null,&#10;                            interactive = false,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = null&#10;                        )&#10;                    }&#10;//                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/RangeBarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/RangeBarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun RangeBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;RangeChartPoint&gt;,&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;, &#10;    title: String = &quot;Range Bar Chart&quot;,&#10;    barColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    barWidthRatio: Float = 0.6f,&#10;    interactionType: InteractionType = InteractionType.BAR,&#10;    onBarClick: ((Int, RangeChartPoint) -&gt; Unit)? = null,&#10;    chartType: ChartType = ChartType.RANGE_BAR&#10;) {&#10;    if (data.isEmpty()) return&#10;    &#10;    val labels = data.map { it.label ?: it.x.toString() }&#10;    var selectedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val metrics = ChartMath.RangeBar.computeRangeMetrics(size, data)&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.drawYAxis(this, metrics)&#10;                ChartDraw.Bar.drawBarXAxisLabels(drawContext, labels, metrics)&#10;            }&#10;&#10;            // Conditional interaction based on interactionType parameter&#10;            when (interactionType) {&#10;                InteractionType.BAR -&gt; {&#10;                    // Interactive range bars&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = data.map { it.yMin },&#10;                            maxValues = data.map { it.yMax },&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = true,&#10;                            onBarClick = { index, tooltipText -&gt;&#10;                                selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                onBarClick?.invoke(index, data[index])&#10;                            },&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex&#10;                        )&#10;                    }&#10;                }&#10;                InteractionType.TOUCH_AREA -&gt; {&#10;                    // Non-interactive range bars&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = data.map { it.yMin },&#10;                            maxValues = data.map { it.yMax },&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = false,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex&#10;                        )&#10;                    }&#10;&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(data.size) { metrics.minY },&#10;                            maxValues = data.map { it.yMax },&#10;                            metrics = metrics,&#10;                            onBarClick = { index, _ -&gt;&#10;                                selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                onBarClick?.invoke(index, data[index])&#10;                            },&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex,&#10;                            isTouchArea = true&#10;                        )&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    // Default case - no interaction&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = data.map { it.yMin },&#10;                            maxValues = data.map { it.yMax },&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = false,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = null&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.ui.theme.ChartColor&#10;&#10;@Composable&#10;fun RangeBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;RangeChartPoint&gt;,&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;, &#10;    title: String = &quot;Range Bar Chart&quot;,&#10;    barColor: androidx.compose.ui.graphics.Color = ChartColor.Default,&#10;    barWidthRatio: Float = 0.6f,&#10;    yPosition: String = &quot;left&quot;, // Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;    interactionType: InteractionType = InteractionType.BAR,&#10;    onBarClick: ((Int, RangeChartPoint) -&gt; Unit)? = null,&#10;    chartType: ChartType = ChartType.RANGE_BAR&#10;) {&#10;    if (data.isEmpty()) return&#10;    &#10;    val labels = data.map { it.label ?: it.x.toString() }&#10;    var selectedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Box(&#10;            Modifier&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val metrics = ChartMath.RangeBar.computeRangeMetrics(size, data)&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics, yPosition)&#10;                ChartDraw.drawYAxis(this, metrics, yPosition)&#10;                ChartDraw.Bar.drawBarXAxisLabels(drawContext, labels, metrics)&#10;            }&#10;&#10;            // Conditional interaction based on interactionType parameter&#10;            when (interactionType) {&#10;                InteractionType.BAR -&gt; {&#10;                    // Interactive range bars&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = data.map { it.yMin },&#10;                            maxValues = data.map { it.yMax },&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = true,&#10;                            onBarClick = { index, tooltipText -&gt;&#10;                                selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                onBarClick?.invoke(index, data[index])&#10;                            },&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex&#10;                        )&#10;                    }&#10;                }&#10;                InteractionType.TOUCH_AREA -&gt; {&#10;                    // Non-interactive range bars&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = data.map { it.yMin },&#10;                            maxValues = data.map { it.yMax },&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = false,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex&#10;                        )&#10;                    }&#10;&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(data.size) { metrics.minY },&#10;                            maxValues = data.map { it.yMax },&#10;                            metrics = metrics,&#10;                            onBarClick = { index, _ -&gt;&#10;                                selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                onBarClick?.invoke(index, data[index])&#10;                            },&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = selectedBarIndex,&#10;                            isTouchArea = true&#10;                        )&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    // Default case - no interaction&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = data.map { it.yMin },&#10;                            maxValues = data.map { it.yMax },&#10;                            metrics = metrics,&#10;                            color = barColor,&#10;                            barWidthRatio = barWidthRatio,&#10;                            interactive = false,&#10;                            chartType = chartType,&#10;                            showTooltipForIndex = null&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/ScatterPlot.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/ScatterPlot.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;&#10;@Composable&#10;fun ScatterPlot(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    xLabel: String = &quot;X Axis&quot;,&#10;    yLabel: String = &quot;Y Axis&quot;,&#10;    title: String = &quot;Scatter Plot Example&quot;,&#10;    pointColor: Color = com.hdil.saluschart.ui.theme.ChartColor.Default,&#10;    tooltipTextSize: Float = 32f,        // 툴팁 텍스트 크기&#10;    interactionType: InteractionType = InteractionType.POINT,&#10;    chartType: ChartType = ChartType.SCATTERPLOT // 차트 타입 (툴팁 위치 결정용&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.x }&#10;    val yValues = data.map { it.y }&#10;&#10;    var canvasPoints by remember { mutableStateOf(listOf&lt;Offset&gt;()) }&#10;    var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;    &#10;    var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(text = title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Box(&#10;            Modifier&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val metrics = ChartMath.computeMetrics(size, yValues)&#10;                val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;                canvasPoints = points&#10;                canvasSize = size&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.Line.drawXAxisLabels(drawContext, xLabels.map { it.toString() }, metrics)&#10;            }&#10;&#10;            // Conditional interaction based on interactionType parameter&#10;            when (interactionType) {&#10;                InteractionType.TOUCH_AREA -&gt; {&#10;                    // BarMarker interactions (invisible bars for easier touching)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(yValues.size) { metrics.minY },&#10;                            maxValues = yValues,&#10;                            metrics = metrics,&#10;                            useLineChartPositioning = true,&#10;                            onBarClick = { index, tooltipText -&gt;&#10;                                selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                            },&#10;                            chartType = chartType,&#10;                            isTouchArea = true&#10;                        )&#10;                    }&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        data = data,&#10;                        points = canvasPoints,&#10;                        values = yValues,&#10;                        selectedPointIndex = selectedPointIndex,&#10;                        onPointClick = null, // No point interaction in this mode&#10;                        interactive = false, // Visual only, no interactions&#10;                        chartType = chartType,&#10;                        showTooltipForIndex = selectedPointIndex&#10;                    )&#10;                }&#10;                InteractionType.POINT -&gt; {&#10;                    // PointMarker interactions (direct point touching)&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        data = data,&#10;                        points = canvasPoints,&#10;                        values = yValues,&#10;                        color = pointColor,&#10;                        selectedPointIndex = selectedPointIndex,&#10;                        onPointClick = { index -&gt;&#10;                            // Handle point click - toggle selection&#10;                            selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                        },&#10;                        chartType = chartType,&#10;                        showTooltipForIndex = selectedPointIndex,&#10;                        pointRadius = 8.dp,&#10;                        innerRadius = 0.dp,&#10;                        interactive = true&#10;                    )&#10;                }&#10;                else -&gt; {&#10;                    // Default to non-interactive rendering&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        data = data,&#10;                        points = canvasPoints,&#10;                        values = yValues,&#10;                        selectedPointIndex = null, // No selection in non-interactive mode&#10;                        onPointClick = null,&#10;                        chartType = chartType,&#10;                        showTooltipForIndex = null&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;&#10;@Composable&#10;fun ScatterPlot(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    xLabel: String = &quot;X Axis&quot;,&#10;    yLabel: String = &quot;Y Axis&quot;,&#10;    title: String = &quot;Scatter Plot Example&quot;,&#10;    pointColor: Color = com.hdil.saluschart.ui.theme.ChartColor.Default,&#10;    tooltipTextSize: Float = 32f,        // 툴팁 텍스트 크기&#10;    yPosition: String = &quot;left&quot;,          // Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;    interactionType: InteractionType = InteractionType.POINT,&#10;    chartType: ChartType = ChartType.SCATTERPLOT // 차트 타입 (툴팁 위치 결정용&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.x }&#10;    val yValues = data.map { it.y }&#10;&#10;    var canvasPoints by remember { mutableStateOf(listOf&lt;Offset&gt;()) }&#10;    var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;    &#10;    var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(text = title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Box(&#10;            Modifier&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val metrics = ChartMath.computeMetrics(size, yValues)&#10;                val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;                canvasPoints = points&#10;                canvasSize = size&#10;                chartMetrics = metrics&#10;&#10;                ChartDraw.drawGrid(this, size, metrics, yPosition)&#10;                ChartDraw.Line.drawXAxisLabels(drawContext, xLabels.map { it.toString() }, metrics)&#10;            }&#10;&#10;            // Conditional interaction based on interactionType parameter&#10;            when (interactionType) {&#10;                InteractionType.TOUCH_AREA -&gt; {&#10;                    // BarMarker interactions (invisible bars for easier touching)&#10;                    chartMetrics?.let { metrics -&gt;&#10;                        ChartDraw.Bar.BarMarker(&#10;                            data = data,&#10;                            minValues = List(yValues.size) { metrics.minY },&#10;                            maxValues = yValues,&#10;                            metrics = metrics,&#10;                            useLineChartPositioning = true,&#10;                            onBarClick = { index, tooltipText -&gt;&#10;                                selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                            },&#10;                            chartType = chartType,&#10;                            isTouchArea = true&#10;                        )&#10;                    }&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        data = data,&#10;                        points = canvasPoints,&#10;                        values = yValues,&#10;                        selectedPointIndex = selectedPointIndex,&#10;                        onPointClick = null, // No point interaction in this mode&#10;                        interactive = false, // Visual only, no interactions&#10;                        chartType = chartType,&#10;                        showTooltipForIndex = selectedPointIndex&#10;                    )&#10;                }&#10;                InteractionType.POINT -&gt; {&#10;                    // PointMarker interactions (direct point touching)&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        data = data,&#10;                        points = canvasPoints,&#10;                        values = yValues,&#10;                        color = pointColor,&#10;                        selectedPointIndex = selectedPointIndex,&#10;                        onPointClick = { index -&gt;&#10;                            // Handle point click - toggle selection&#10;                            selectedPointIndex = if (selectedPointIndex == index) null else index&#10;                        },&#10;                        chartType = chartType,&#10;                        showTooltipForIndex = selectedPointIndex,&#10;                        pointRadius = 8.dp,&#10;                        innerRadius = 0.dp,&#10;                        interactive = true&#10;                    )&#10;                }&#10;                else -&gt; {&#10;                    // Default to non-interactive rendering&#10;                    ChartDraw.Scatter.PointMarker(&#10;                        data = data,&#10;                        points = canvasPoints,&#10;                        values = yValues,&#10;                        selectedPointIndex = null, // No selection in non-interactive mode&#10;                        onPointClick = null,&#10;                        chartType = chartType,&#10;                        showTooltipForIndex = null&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/StackedBarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/StackedBarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartLegend&#10;import com.hdil.saluschart.core.chart.chartDraw.LegendPosition&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;&#10;/**&#10; * 스택 바 차트 컴포저블 (건강 데이터 시각화에 최적화)&#10; * &#10; * 영양소 섭취량, 운동 시간 등 여러 구성 요소를 가진 데이터를 시각화할 때 사용합니다.&#10; * 예: 일별 영양소 섭취량 (단백질, 지방, 탄수화물)&#10; * &#10; * @param modifier 커스텀 modifier&#10; * @param data 스택 차트 데이터 포인트 목록&#10; * @param segmentLabels 각 세그먼트의 레이블들 (예: [&quot;단백질&quot;, &quot;지방&quot;, &quot;탄수화물&quot;])&#10; * @param xLabel X축 레이블 (예: &quot;날짜&quot;)&#10; * @param yLabel Y축 레이블 (예: &quot;영양소 (g)&quot;)&#10; * @param title 차트 제목&#10; * @param colors 각 세그먼트의 색상 팔레트 (건강 데이터에 적합한 기본 색상 제공)&#10; * @param barWidthRatio 바 너비 비율 (0.0 ~ 1.0)&#10; * @param showLegend 범례 표시 여부&#10; * @param legendPosition 범례 위치 (LEFT, RIGHT, TOP, BOTTOM)&#10; * @param interactionType 상호작용 타입 (STACKED_BAR: 개별 세그먼트 터치, TOUCH_AREA: 전체 스택 툴팁)&#10; * @param onBarClick 바 클릭 시 호출되는 콜백 (바 인덱스, 세그먼트 인덱스, 값)&#10; */&#10;@Composable&#10;fun StackedBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;StackedChartPoint&gt;,&#10;    segmentLabels: List&lt;String&gt; = emptyList(),&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Stacked Bar Chart&quot;,&#10;    colors: List&lt;Color&gt; = listOf(&#10;        Color(0xFF2196F3), // 파랑 (단백질)&#10;        Color(0xFFFF9800), // 주황 (지방)&#10;        Color(0xFF4CAF50), // 초록 (탄수화물)&#10;        Color(0xFF9C27B0), // 보라 (기타)&#10;        Color(0xFFE91E63), // 분홍&#10;        Color(0xFFFFEB3B), // 노랑&#10;    ),&#10;    barWidthRatio: Float = 0.6f,&#10;    showLegend: Boolean = true,&#10;    legendPosition: LegendPosition = LegendPosition.BOTTOM,&#10;    interactionType: InteractionType = InteractionType.STACKED_BAR,&#10;    onBarClick: ((barIndex: Int, segmentIndex: Int?, value: Float) -&gt; Unit)? = null,&#10;    chartType: ChartType = ChartType.STACKED_BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.label ?: it.x.toString() }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;    var selectedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(16.dp))&#10;&#10;        // 차트와 좌우 범례를 담는 Row&#10;        if (legendPosition == LegendPosition.LEFT || legendPosition == LegendPosition.RIGHT) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // 범례를 왼쪽에 배치&#10;                if (showLegend &amp;&amp; legendPosition == LegendPosition.LEFT &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    ChartLegend(&#10;                        modifier = Modifier,&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = LegendPosition.LEFT&#10;                    )&#10;                }&#10;&#10;                // 스택 바 차트&#10;                Box(&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Canvas(modifier = Modifier.fillMaxSize()) {&#10;                        val totalValues = data.map { it.total }&#10;                        val metrics = ChartMath.computeMetrics(size, totalValues, chartType = ChartType.STACKED_BAR)&#10;                        chartMetrics = metrics&#10;&#10;                        ChartDraw.drawGrid(this, size, metrics)&#10;                        ChartDraw.drawXAxis(this, metrics)&#10;                        ChartDraw.drawYAxis(this, metrics)&#10;                        ChartDraw.Bar.drawBarXAxisLabels(drawContext, xLabels, metrics)&#10;                    }&#10;&#10;                    // 상호작용 처리&#10;                    when (interactionType) {&#10;                        InteractionType.STACKED_BAR -&gt; {&#10;                            // Individual segment interaction - each segment is touchable&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = true,&#10;                                            chartType = chartType,&#10;                                            segmentIndex = segmentIndex,&#10;                                            onBarClick = { barIndex, _ -&gt;&#10;                                                val segmentValue = data.getOrNull(barIndex)?.values?.getOrNull(segmentIndex) ?: 0f&#10;                                                onBarClick?.invoke(barIndex, segmentIndex, segmentValue)&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                        InteractionType.TOUCH_AREA -&gt; {&#10;                            // Area-based interaction - show all segment values in tooltip&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = false,&#10;                                            chartType = chartType,&#10;                                            showTooltipForIndex = selectedBarIndex&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                // Then create transparent touch areas for interaction&#10;                                ChartDraw.Bar.BarMarker(&#10;                                    data = data,&#10;                                    minValues = List(data.size) { metrics.minY },&#10;                                    maxValues = data.map { it.total },&#10;                                    metrics = metrics,&#10;                                    onBarClick = { index, _ -&gt;&#10;                                        selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                        val stackedPoint = data.getOrNull(index)&#10;                                        if (stackedPoint != null) {&#10;                                            onBarClick?.invoke(index, null, stackedPoint.total)&#10;                                        }&#10;                                    },&#10;                                    chartType = chartType,&#10;                                    showTooltipForIndex = selectedBarIndex,&#10;                                    isTouchArea = true&#10;                                )&#10;                            }&#10;                        }&#10;                        else -&gt; {&#10;                            // Default: non-interactive rendering&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = false,&#10;                                            chartType = chartType&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // 범례를 오른쪽에 배치&#10;                if (showLegend &amp;&amp; legendPosition == LegendPosition.RIGHT &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    ChartLegend(&#10;                        modifier = Modifier,&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = LegendPosition.RIGHT&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            // TOP, BOTTOM: 차트와 범례를 세로로 배치&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .fillMaxHeight(),&#10;                verticalArrangement = Arrangement.SpaceBetween,&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                if (showLegend &amp;&amp; legendPosition == LegendPosition.TOP &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    ChartLegend(&#10;                        modifier = Modifier,&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = LegendPosition.TOP&#10;                    )&#10;                    Spacer(Modifier.height(16.dp))&#10;                }&#10;&#10;                Box(&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Canvas(modifier = Modifier.fillMaxSize()) {&#10;                        val totalValues = data.map { it.total }&#10;                        val metrics = ChartMath.computeMetrics(size, totalValues, chartType = ChartType.STACKED_BAR)&#10;                        chartMetrics = metrics&#10;&#10;                        ChartDraw.drawGrid(this, size, metrics)&#10;                        ChartDraw.drawXAxis(this, metrics)&#10;                        ChartDraw.drawYAxis(this, metrics)&#10;                        ChartDraw.Bar.drawBarXAxisLabels(drawContext, xLabels, metrics)&#10;                    }&#10;&#10;                    // 상호작용 처리&#10;                    when (interactionType) {&#10;                        InteractionType.STACKED_BAR -&gt; {&#10;                            // Individual segment interaction - each segment is touchable&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = true,&#10;                                            chartType = chartType,&#10;                                            segmentIndex = segmentIndex,&#10;                                            onBarClick = { barIndex, _ -&gt;&#10;                                                val segmentValue = data.getOrNull(barIndex)?.values?.getOrNull(segmentIndex) ?: 0f&#10;                                                onBarClick?.invoke(barIndex, segmentIndex, segmentValue)&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                        InteractionType.TOUCH_AREA -&gt; {&#10;                            // Area-based interaction - show all segment values in tooltip&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = false,&#10;                                            chartType = chartType,&#10;                                            showTooltipForIndex = selectedBarIndex&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                // Then create transparent touch areas for interaction&#10;                                ChartDraw.Bar.BarMarker(&#10;                                    data = data,&#10;                                    minValues = List(data.size) { metrics.minY },&#10;                                    maxValues = data.map { it.total },&#10;                                    metrics = metrics,&#10;                                    onBarClick = { index, _ -&gt;&#10;                                        selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                        val stackedPoint = data.getOrNull(index)&#10;                                        if (stackedPoint != null) {&#10;                                            onBarClick?.invoke(index, null, stackedPoint.total)&#10;                                        }&#10;                                    },&#10;                                    chartType = chartType,&#10;                                    showTooltipForIndex = selectedBarIndex,&#10;                                    isTouchArea = true&#10;                                )&#10;                            }&#10;                        }&#10;                        else -&gt; {&#10;                            // Default: non-interactive rendering&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = false,&#10;                                            chartType = chartType&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (showLegend &amp;&amp; legendPosition == LegendPosition.BOTTOM &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    Spacer(Modifier.height(16.dp))&#10;                    ChartLegend(&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = LegendPosition.BOTTOM&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxHeight&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartLegend&#10;import com.hdil.saluschart.core.chart.chartDraw.LegendPosition&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.InteractionType&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;&#10;/**&#10; * 스택 바 차트 컴포저블 (건강 데이터 시각화에 최적화)&#10; * &#10; * 영양소 섭취량, 운동 시간 등 여러 구성 요소를 가진 데이터를 시각화할 때 사용합니다.&#10; * 예: 일별 영양소 섭취량 (단백질, 지방, 탄수화물)&#10; * &#10; * @param modifier 커스텀 modifier&#10; * @param data 스택 차트 데이터 포인트 목록&#10; * @param segmentLabels 각 세그먼트의 레이블들 (예: [&quot;단백질&quot;, &quot;지방&quot;, &quot;탄수화물&quot;])&#10; * @param xLabel X축 레이블 (예: &quot;날짜&quot;)&#10; * @param yLabel Y축 레이블 (예: &quot;영양소 (g)&quot;)&#10; * @param title 차트 제목&#10; * @param colors 각 세그먼트의 색상 팔레트 (건강 데이터에 적합한 기본 색상 제공)&#10; * @param barWidthRatio 바 너비 비율 (0.0 ~ 1.0)&#10; * @param showLegend 범례 표시 여부&#10; * @param legendPosition 범례 위치 (LEFT, RIGHT, TOP, BOTTOM)&#10; * @param yPosition Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10; * @param interactionType 상호작용 타입 (STACKED_BAR: 개별 세그먼트 터치, TOUCH_AREA: 전체 스택 툴팁)&#10; * @param onBarClick 바 클릭 시 호출되는 콜백 (바 인덱스, 세그먼트 인덱스, 값)&#10; */&#10;@Composable&#10;fun StackedBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;StackedChartPoint&gt;,&#10;    segmentLabels: List&lt;String&gt; = emptyList(),&#10;    xLabel: String = &quot;Time&quot;,&#10;    yLabel: String = &quot;Value&quot;,&#10;    title: String = &quot;Stacked Bar Chart&quot;,&#10;    colors: List&lt;Color&gt; = listOf(&#10;        Color(0xFF2196F3), // 파랑 (단백질)&#10;        Color(0xFFFF9800), // 주황 (지방)&#10;        Color(0xFF4CAF50), // 초록 (탄수화물)&#10;        Color(0xFF9C27B0), // 보라 (기타)&#10;        Color(0xFFE91E63), // 분홍&#10;        Color(0xFFFFEB3B), // 노랑&#10;    ),&#10;    barWidthRatio: Float = 0.6f,&#10;    showLegend: Boolean = true,&#10;    legendPosition: LegendPosition = LegendPosition.BOTTOM,&#10;    yPosition: String = &quot;left&quot;, // Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;    interactionType: InteractionType = InteractionType.STACKED_BAR,&#10;    onBarClick: ((barIndex: Int, segmentIndex: Int?, value: Float) -&gt; Unit)? = null,&#10;    chartType: ChartType = ChartType.STACKED_BAR // 차트 타입 (툴팁 위치 결정용)&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.label ?: it.x.toString() }&#10;    var chartMetrics by remember { mutableStateOf&lt;ChartMath.ChartMetrics?&gt;(null) }&#10;    var selectedBarIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(Modifier.height(16.dp))&#10;&#10;        // 차트와 좌우 범례를 담는 Row&#10;        if (legendPosition == LegendPosition.LEFT || legendPosition == LegendPosition.RIGHT) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // 범례를 왼쪽에 배치&#10;                if (showLegend &amp;&amp; legendPosition == LegendPosition.LEFT &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    ChartLegend(&#10;                        modifier = Modifier,&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = LegendPosition.LEFT&#10;                    )&#10;                }&#10;&#10;                // 스택 바 차트&#10;                Box(&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Canvas(modifier = Modifier.fillMaxSize()) {&#10;                        val totalValues = data.map { it.total }&#10;                        val metrics = ChartMath.computeMetrics(size, totalValues, chartType = ChartType.STACKED_BAR)&#10;                        chartMetrics = metrics&#10;&#10;                        ChartDraw.drawGrid(this, size, metrics, yPosition)&#10;                        ChartDraw.drawXAxis(this, metrics)&#10;                        ChartDraw.drawYAxis(this, metrics, yPosition)&#10;                        ChartDraw.Bar.drawBarXAxisLabels(drawContext, xLabels, metrics)&#10;                    }&#10;&#10;                    // 상호작용 처리&#10;                    when (interactionType) {&#10;                        InteractionType.STACKED_BAR -&gt; {&#10;                            // Individual segment interaction - each segment is touchable&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = true,&#10;                                            chartType = chartType,&#10;                                            segmentIndex = segmentIndex,&#10;                                            onBarClick = { barIndex, _ -&gt;&#10;                                                val segmentValue = data.getOrNull(barIndex)?.values?.getOrNull(segmentIndex) ?: 0f&#10;                                                onBarClick?.invoke(barIndex, segmentIndex, segmentValue)&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                        InteractionType.TOUCH_AREA -&gt; {&#10;                            // Area-based interaction - show all segment values in tooltip&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = false,&#10;                                            chartType = chartType,&#10;                                            showTooltipForIndex = selectedBarIndex&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                // Then create transparent touch areas for interaction&#10;                                ChartDraw.Bar.BarMarker(&#10;                                    data = data,&#10;                                    minValues = List(data.size) { metrics.minY },&#10;                                    maxValues = data.map { it.total },&#10;                                    metrics = metrics,&#10;                                    onBarClick = { index, _ -&gt;&#10;                                        selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                        val stackedPoint = data.getOrNull(index)&#10;                                        if (stackedPoint != null) {&#10;                                            onBarClick?.invoke(index, null, stackedPoint.total)&#10;                                        }&#10;                                    },&#10;                                    chartType = chartType,&#10;                                    showTooltipForIndex = selectedBarIndex,&#10;                                    isTouchArea = true&#10;                                )&#10;                            }&#10;                        }&#10;                        else -&gt; {&#10;                            // Default: non-interactive rendering&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = false,&#10;                                            chartType = chartType&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // 범례를 오른쪽에 배치&#10;                if (showLegend &amp;&amp; legendPosition == LegendPosition.RIGHT &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    ChartLegend(&#10;                        modifier = Modifier,&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = LegendPosition.RIGHT&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            // TOP, BOTTOM: 차트와 범례를 세로로 배치&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .fillMaxHeight(),&#10;                verticalArrangement = Arrangement.SpaceBetween,&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                if (showLegend &amp;&amp; legendPosition == LegendPosition.TOP &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    ChartLegend(&#10;                        modifier = Modifier,&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = LegendPosition.TOP&#10;                    )&#10;                    Spacer(Modifier.height(16.dp))&#10;                }&#10;&#10;                Box(&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Canvas(modifier = Modifier.fillMaxSize()) {&#10;                        val totalValues = data.map { it.total }&#10;                        val metrics = ChartMath.computeMetrics(size, totalValues, chartType = ChartType.STACKED_BAR)&#10;                        chartMetrics = metrics&#10;&#10;                        ChartDraw.drawGrid(this, size, metrics, yPosition)&#10;                        ChartDraw.drawXAxis(this, metrics)&#10;                        ChartDraw.drawYAxis(this, metrics, yPosition)&#10;                        ChartDraw.Bar.drawBarXAxisLabels(drawContext, xLabels, metrics)&#10;                    }&#10;&#10;                    // 상호작용 처리&#10;                    when (interactionType) {&#10;                        InteractionType.STACKED_BAR -&gt; {&#10;                            // Individual segment interaction - each segment is touchable&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = true,&#10;                                            chartType = chartType,&#10;                                            segmentIndex = segmentIndex,&#10;                                            onBarClick = { barIndex, _ -&gt;&#10;                                                val segmentValue = data.getOrNull(barIndex)?.values?.getOrNull(segmentIndex) ?: 0f&#10;                                                onBarClick?.invoke(barIndex, segmentIndex, segmentValue)&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                        InteractionType.TOUCH_AREA -&gt; {&#10;                            // Area-based interaction - show all segment values in tooltip&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = false,&#10;                                            chartType = chartType,&#10;                                            showTooltipForIndex = selectedBarIndex&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                // Then create transparent touch areas for interaction&#10;                                ChartDraw.Bar.BarMarker(&#10;                                    data = data,&#10;                                    minValues = List(data.size) { metrics.minY },&#10;                                    maxValues = data.map { it.total },&#10;                                    metrics = metrics,&#10;                                    onBarClick = { index, _ -&gt;&#10;                                        selectedBarIndex = if (selectedBarIndex == index) null else index&#10;                                        val stackedPoint = data.getOrNull(index)&#10;                                        if (stackedPoint != null) {&#10;                                            onBarClick?.invoke(index, null, stackedPoint.total)&#10;                                        }&#10;                                    },&#10;                                    chartType = chartType,&#10;                                    showTooltipForIndex = selectedBarIndex,&#10;                                    isTouchArea = true&#10;                                )&#10;                            }&#10;                        }&#10;                        else -&gt; {&#10;                            // Default: non-interactive rendering&#10;                            chartMetrics?.let { metrics -&gt;&#10;                                val segmentCounts = data.map { it.values.size }&#10;                                val maxSegments = segmentCounts.maxOrNull() ?: 0&#10;&#10;                                if (segmentCounts.any { it != maxSegments }) {&#10;                                    throw IllegalArgumentException(&quot;All StackedChartPoints must have the same number of segments. Found: $segmentCounts&quot;)&#10;                                }&#10;&#10;                                for (segmentIndex in 0 until maxSegments) {&#10;                                    val segmentMinValues = mutableListOf&lt;Float&gt;()&#10;                                    val segmentMaxValues = mutableListOf&lt;Float&gt;()&#10;&#10;                                    data.forEach { stackedPoint -&gt;&#10;                                        var cumulativeValue = 0f&#10;                                        for (i in 0 until segmentIndex) {&#10;                                            cumulativeValue += stackedPoint.values.getOrNull(i) ?: 0f&#10;                                        }&#10;                                        val segmentValue = stackedPoint.values.getOrNull(segmentIndex) ?: 0f&#10;&#10;                                        segmentMinValues.add(cumulativeValue)&#10;                                        segmentMaxValues.add(cumulativeValue + segmentValue)&#10;                                    }&#10;&#10;                                    val hasNonZeroValues = segmentMaxValues.zip(segmentMinValues).any { (max, min) -&gt; max &gt; min }&#10;                                    if (hasNonZeroValues) {&#10;                                        val segmentColor = colors.getOrNull(segmentIndex) ?: Color.Gray&#10;&#10;                                        ChartDraw.Bar.BarMarker(&#10;                                            data = data,&#10;                                            minValues = segmentMinValues,&#10;                                            maxValues = segmentMaxValues,&#10;                                            metrics = metrics,&#10;                                            color = segmentColor,&#10;                                            barWidthRatio = barWidthRatio,&#10;                                            interactive = false,&#10;                                            chartType = chartType&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (showLegend &amp;&amp; legendPosition == LegendPosition.BOTTOM &amp;&amp; segmentLabels.isNotEmpty()) {&#10;                    Spacer(Modifier.height(16.dp))&#10;                    ChartLegend(&#10;                        labels = segmentLabels,&#10;                        colors = colors,&#10;                        position = LegendPosition.BOTTOM&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>