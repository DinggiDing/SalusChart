<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/BarChartDraw.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/BarChartDraw.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawContext&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw.formatTickLabel&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;object BarChartDraw {&#10;    /**&#10;     * 바차트용 X축 레이블을 그립니다 (첫 번째 레이블이 바 너비의 절반만큼 오른쪽에서 시작).&#10;     *&#10;     * @param ctx 그리기 컨텍스트&#10;     * @param labels X축에 표시할 레이블 목록&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param centered 텍스트를 중앙 정렬할지 여부 (기본값: true)&#10;     * @param textSize 레이블 텍스트 크기 (기본값: 28f)&#10;     */&#10;    fun drawBarXAxisLabels(&#10;        ctx: DrawContext, &#10;        labels: List&lt;String&gt;, &#10;        metrics: ChartMath.ChartMetrics, &#10;        centered: Boolean = true,&#10;        textSize: Float = 28f&#10;    ) {&#10;        val barWidth = metrics.chartWidth / labels.size / 2&#10;        val spacing = metrics.chartWidth / labels.size&#10;        labels.forEachIndexed { i, label -&gt;&#10;            val x = metrics.paddingX + barWidth + i * spacing  // 바 너비의 절반만큼 오른쪽으로 시프트&#10;            ctx.canvas.nativeCanvas.drawText(&#10;                label,&#10;                x,&#10;                metrics.chartHeight + 50f,&#10;                android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.DKGRAY&#10;                    this.textSize = textSize&#10;                    if (centered) {&#10;                        textAlign = android.graphics.Paint.Align.CENTER&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 바차트의 막대들을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param values 원본 데이터 값 목록&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param color 바 색상&#10;     * @param isMinimal 미니멀 차트 모드인지 여부 (기본값: false)&#10;     * @param barWidthMultiplier 바 너비 배수 (기본값: normal=0.5, minimal=0.8)&#10;     * @param isInteractiveBars 터치 상호작용용 바를 그릴지 여부 (true: 전체 크기 투명 바, false: 데이터 시각화 바)&#10;     * @return 각 바의 히트 영역과 값의 쌍 목록 (isInteractiveBars=true일 때만 반환, 아니면 빈 리스트)&#10;     */&#10;    fun drawBars(&#10;        drawScope: DrawScope, &#10;        values: List&lt;Float&gt;, &#10;        metrics: ChartMath.ChartMetrics, &#10;        color: Color,&#10;        isMinimal: Boolean = false,&#10;        barWidthMultiplier: Float = if (isMinimal) 0.8f else 0.5f,&#10;        isInteractiveBars: Boolean = false,&#10;    ): List&lt;Pair&lt;androidx.compose.ui.geometry.Rect, Float&gt;&gt; {&#10;        val hitAreas = mutableListOf&lt;Pair&lt;androidx.compose.ui.geometry.Rect, Float&gt;&gt;()&#10;&#10;        if (isInteractiveBars) {&#10;            // 터치 상호작용용 바 그리기 (전체 너비, 전체 높이)&#10;            val touchBarWidth = metrics.chartWidth / values.size&#10;            val spacing = metrics.chartWidth / values.size&#10;            &#10;            values.forEachIndexed { i, value -&gt;&#10;                val touchBarX = metrics.paddingX + i * spacing&#10;                &#10;                // 터치 영역 바 색상 결정&#10;                val touchBarColor = Color.Transparent&#10;                &#10;                drawScope.drawRect(&#10;                    color = touchBarColor,&#10;                    topLeft = Offset(touchBarX, 0f),&#10;                    size = Size(touchBarWidth, metrics.chartHeight)&#10;                )&#10;                &#10;                // 터치 영역 저장&#10;                val hitArea = androidx.compose.ui.geometry.Rect(&#10;                    left = touchBarX,&#10;                    top = 0f,&#10;                    right = touchBarX + touchBarWidth,&#10;                    bottom = metrics.chartHeight&#10;                )&#10;                hitAreas += Pair(hitArea, value)&#10;            }&#10;        } else {&#10;            // 데이터 시각화용 바 그리기 (커스텀 너비, 데이터 높이)&#10;            val barWidth = metrics.chartWidth / values.size * barWidthMultiplier&#10;            val spacing = metrics.chartWidth / values.size&#10;            &#10;            values.forEachIndexed { i, value -&gt;&#10;                val barHeight = ((value - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;                &#10;                // 모든 차트에서 바를 할당된 공간의 중앙에 배치&#10;                val barX = metrics.paddingX + i * spacing + (spacing - barWidth) / 2f&#10;                &#10;                val barY = metrics.chartHeight - barHeight&#10;&#10;                drawScope.drawRect(&#10;                    color = color,&#10;                    topLeft = Offset(barX, barY),&#10;                    size = Size(barWidth, barHeight)&#10;                )&#10;            }&#10;        }&#10;&#10;        return hitAreas&#10;    }&#10;&#10;    /**&#10;     * 스택 바 차트의 막대들을 그립니다.&#10;     * 각 막대는 여러 세그먼트가 수직으로 쌓인 형태입니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param data 스택 차트 데이터 포인트 목록&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param colors 각 세그먼트의 기본 색상 팔레트&#10;     * @param barWidthRatio 바 너비 비율 (0.0 ~ 1.0, 기본값 0.6)&#10;     */&#10;    fun drawStackedBars(&#10;        drawScope: DrawScope,&#10;        data: List&lt;StackedChartPoint&gt;,&#10;        metrics: ChartMath.ChartMetrics,&#10;        colors: List&lt;Color&gt;,&#10;        barWidthRatio: Float = 0.6f&#10;    ) {&#10;        val barWidth = (metrics.chartWidth / data.size) * barWidthRatio&#10;        val spacing = metrics.chartWidth / data.size&#10;        data.forEachIndexed { i, stackedPoint -&gt;&#10;            val barX = metrics.paddingX + (spacing - barWidth) / 2 + i * spacing&#10;            var currentY = metrics.chartHeight&#10;            // 각 세그먼트를 아래에서 위로 쌓아 올림&#10;            stackedPoint.values.forEachIndexed { segmentIndex, value -&gt;&#10;                if (value &gt; 0) { // 0보다 큰 값만 그리기&#10;                    val segmentHeight = (value / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;                    val segmentY = currentY - segmentHeight&#10;&#10;                    // 색상 결정: 개별 색상이 있으면 사용, 없으면 기본 팔레트 사용&#10;                    val segmentColor = stackedPoint.segmentColors?.getOrNull(segmentIndex)?.let {&#10;                        Color(it)&#10;                    } ?: colors.getOrElse(segmentIndex % colors.size) { colors.first() }&#10;&#10;                    // 세그먼트 그리기&#10;                    drawScope.drawRect(&#10;                        color = segmentColor,&#10;                        topLeft = Offset(barX, segmentY),&#10;                        size = Size(barWidth, segmentHeight)&#10;                    )&#10;&#10;                    currentY = segmentY // 다음 세그먼트를 위해 Y 위치 업데이트&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawContext&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import com.hdil.saluschart.core.chart.StackedChartPoint&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw.formatTickLabel&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;object BarChartDraw {&#10;    /**&#10;     * 바차트용 X축 레이블을 그립니다 (첫 번째 레이블이 바 너비의 절반만큼 오른쪽에서 시작).&#10;     *&#10;     * @param ctx 그리기 컨텍스트&#10;     * @param labels X축에 표시할 레이블 목록&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param centered 텍스트를 중앙 정렬할지 여부 (기본값: true)&#10;     * @param textSize 레이블 텍스트 크기 (기본값: 28f)&#10;     */&#10;    fun drawBarXAxisLabels(&#10;        ctx: DrawContext, &#10;        labels: List&lt;String&gt;, &#10;        metrics: ChartMath.ChartMetrics, &#10;        centered: Boolean = true,&#10;        textSize: Float = 28f&#10;    ) {&#10;        val barWidth = metrics.chartWidth / labels.size / 2&#10;        val spacing = metrics.chartWidth / labels.size&#10;        labels.forEachIndexed { i, label -&gt;&#10;            val x = metrics.paddingX + barWidth + i * spacing  // 바 너비의 절반만큼 오른쪽으로 시프트&#10;            ctx.canvas.nativeCanvas.drawText(&#10;                label,&#10;                x,&#10;                metrics.chartHeight + 50f,&#10;                android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.DKGRAY&#10;                    this.textSize = textSize&#10;                    if (centered) {&#10;                        textAlign = android.graphics.Paint.Align.CENTER&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 바차트의 막대들을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param values 원본 데이터 값 목록&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param color 바 색상&#10;     * @param isMinimal 미니멀 차트 모드인지 여부 (기본값: false)&#10;     * @param barWidthMultiplier 바 너비 배수 (기본값: normal=0.5, minimal=0.8)&#10;     * @param isInteractiveBars 터치 상호작용용 바를 그릴지 여부 (true: 전체 크기 투명 바, false: 데이터 시각화 바)&#10;     * @return 각 바의 히트 영역과 값의 쌍 목록 (isInteractiveBars=true일 때만 반환, 아니면 빈 리스트)&#10;     */&#10;    fun drawBars(&#10;        drawScope: DrawScope, &#10;        values: List&lt;Float&gt;, &#10;        metrics: ChartMath.ChartMetrics, &#10;        color: Color,&#10;        isMinimal: Boolean = false,&#10;        barWidthMultiplier: Float = if (isMinimal) 0.8f else 0.5f,&#10;        isInteractiveBars: Boolean = false,&#10;    ): List&lt;Pair&lt;androidx.compose.ui.geometry.Rect, Float&gt;&gt; {&#10;        val hitAreas = mutableListOf&lt;Pair&lt;androidx.compose.ui.geometry.Rect, Float&gt;&gt;()&#10;&#10;        if (isInteractiveBars) {&#10;            // 터치 상호작용용 바 그리기 (전체 너비, 전체 높이)&#10;            val touchBarWidth = metrics.chartWidth / values.size&#10;            val spacing = metrics.chartWidth / values.size&#10;            &#10;            values.forEachIndexed { i, value -&gt;&#10;                val touchBarX = metrics.paddingX + i * spacing&#10;                &#10;                // 터치 영역 바 색상 결정&#10;                val touchBarColor = Color.Transparent&#10;                &#10;                drawScope.drawRect(&#10;                    color = touchBarColor,&#10;                    topLeft = Offset(touchBarX, 0f),&#10;                    size = Size(touchBarWidth, metrics.chartHeight)&#10;                )&#10;                &#10;                // 디버깅용 테두리 추가&#10;                drawScope.drawRect(&#10;                    color = Color.Red,&#10;                    topLeft = Offset(touchBarX, 0f),&#10;                    size = Size(touchBarWidth, metrics.chartHeight),&#10;                    style = androidx.compose.ui.graphics.drawscope.Stroke(width = 2f)&#10;                )&#10;                &#10;                // 터치 영역 저장&#10;                val hitArea = androidx.compose.ui.geometry.Rect(&#10;                    left = touchBarX,&#10;                    top = 0f,&#10;                    right = touchBarX + touchBarWidth,&#10;                    bottom = metrics.chartHeight&#10;                )&#10;                hitAreas += Pair(hitArea, value)&#10;            }&#10;        } else {&#10;            // 데이터 시각화용 바 그리기 (커스텀 너비, 데이터 높이)&#10;            val barWidth = metrics.chartWidth / values.size * barWidthMultiplier&#10;            val spacing = metrics.chartWidth / values.size&#10;            &#10;            values.forEachIndexed { i, value -&gt;&#10;                val barHeight = ((value - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;                &#10;                // 모든 차트에서 바를 할당된 공간의 중앙에 배치&#10;                val barX = metrics.paddingX + i * spacing + (spacing - barWidth) / 2f&#10;                &#10;                val barY = metrics.chartHeight - barHeight&#10;&#10;                drawScope.drawRect(&#10;                    color = color,&#10;                    topLeft = Offset(barX, barY),&#10;                    size = Size(barWidth, barHeight)&#10;                )&#10;            }&#10;        }&#10;&#10;        return hitAreas&#10;    }&#10;&#10;    /**&#10;     * 스택 바 차트의 막대들을 그립니다.&#10;     * 각 막대는 여러 세그먼트가 수직으로 쌓인 형태입니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param data 스택 차트 데이터 포인트 목록&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param colors 각 세그먼트의 기본 색상 팔레트&#10;     * @param barWidthRatio 바 너비 비율 (0.0 ~ 1.0, 기본값 0.6)&#10;     */&#10;    fun drawStackedBars(&#10;        drawScope: DrawScope,&#10;        data: List&lt;StackedChartPoint&gt;,&#10;        metrics: ChartMath.ChartMetrics,&#10;        colors: List&lt;Color&gt;,&#10;        barWidthRatio: Float = 0.6f&#10;    ) {&#10;        val barWidth = (metrics.chartWidth / data.size) * barWidthRatio&#10;        val spacing = metrics.chartWidth / data.size&#10;        data.forEachIndexed { i, stackedPoint -&gt;&#10;            val barX = metrics.paddingX + (spacing - barWidth) / 2 + i * spacing&#10;            var currentY = metrics.chartHeight&#10;            // 각 세그먼트를 아래에서 위로 쌓아 올림&#10;            stackedPoint.values.forEachIndexed { segmentIndex, value -&gt;&#10;                if (value &gt; 0) { // 0보다 큰 값만 그리기&#10;                    val segmentHeight = (value / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;                    val segmentY = currentY - segmentHeight&#10;&#10;                    // 색상 결정: 개별 색상이 있으면 사용, 없으면 기본 팔레트 사용&#10;                    val segmentColor = stackedPoint.segmentColors?.getOrNull(segmentIndex)?.let {&#10;                        Color(it)&#10;                    } ?: colors.getOrElse(segmentIndex % colors.size) { colors.first() }&#10;&#10;                    // 세그먼트 그리기&#10;                    drawScope.drawRect(&#10;                        color = segmentColor,&#10;                        topLeft = Offset(barX, segmentY),&#10;                        size = Size(barWidth, segmentHeight)&#10;                    )&#10;&#10;                    currentY = segmentY // 다음 세그먼트를 위해 Y 위치 업데이트&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartMath/ChartMath.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartMath/ChartMath.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartMath&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import java.time.YearMonth&#10;import kotlin.math.abs&#10;import kotlin.math.ceil&#10;import kotlin.math.floor&#10;import kotlin.math.log10&#10;import kotlin.math.pow&#10;import kotlin.math.round&#10;import kotlin.math.sqrt&#10;&#10;object ChartMath {&#10;&#10;    var Pie = PieChartMath&#10;    var Calendar = CalendarChartMath&#10;    val RangeBar = RangeBarChartMath&#10;    val Line = LineChartMath&#10;    val Progress = ProgressChartMath&#10;    val Min = MinimalChartMath&#10;&#10;    /**&#10;     * 차트 그리기에 필요한 메트릭 정보를 담는 데이터 클래스&#10;     *&#10;     * @param paddingX X축 패딩 값&#10;     * @param paddingY Y축 패딩 값&#10;     * @param chartWidth 차트의 실제 너비&#10;     * @param chartHeight 차트의 실제 높이&#10;     * @param minY Y축의 최소값&#10;     * @param maxY Y축의 최대값&#10;     * @param yTicks Y축에 표시할 눈금 값들&#10;     */&#10;    data class ChartMetrics(&#10;        val paddingX: Float,&#10;        val paddingY: Float,&#10;        val chartWidth: Float,&#10;        val chartHeight: Float,&#10;        val minY: Float,&#10;        val maxY: Float,&#10;        val yTicks: List&lt;Float&gt;&#10;    )&#10;&#10;    /**&#10;     * y-axis 눈금 값들을 계산합니다.&#10;     * 1, 2, 5의 배수를 사용하여 시각적으로 깔끔한 눈금을 생성합니다.&#10;     *&#10;     * @param min 데이터의 최소값&#10;     * @param max 데이터의 최대값&#10;     * @param tickCount 원하는 눈금 개수 (기본값: 5)&#10;     * @param chartType 차트 타입 (BAR/STACKED_BAR/MINIMAL_BAR일 경우 최소값을 0으로 강제)&#10;     * @param actualMin 사용자 지정 최소 Y값 (지정시 데이터 범위를 확장)&#10;     * @param actualMax 사용자 지정 최대 Y값 (지정시 데이터 범위를 확장)&#10;     * @return 계산된 눈금 값들의 리스트&#10;     */&#10;    fun computeNiceTicks(&#10;        min: Float, &#10;        max: Float, &#10;        tickCount: Int = 5, &#10;        chartType: ChartType? = null,&#10;        actualMin: Float? = null,&#10;        actualMax: Float? = null&#10;    ): List&lt;Float&gt; {&#10;        if (min &gt;= max) {&#10;            return listOf(0f, 1f)&#10;        }&#10;        &#10;        // 바 차트의 경우 최소값을 0으로 강제 설정&#10;        var min = if (chartType == ChartType.BAR || &#10;                             chartType == ChartType.STACKED_BAR || &#10;                             chartType == ChartType.MINIMAL_BAR) {&#10;            0f&#10;        } else {&#10;            min&#10;        }&#10;        &#10;        val rawStep = (max - min) / tickCount.toDouble()&#10;        val power = 10.0.pow(floor(log10(rawStep)))&#10;        val candidates = listOf(1.0, 2.0, 5.0).map { it * power }&#10;        val step = candidates.minByOrNull { abs(it - rawStep) } ?: power&#10;&#10;        val niceMin = floor(min / step) * step&#10;        val niceMax = ceil(max / step) * step&#10;&#10;        // 사용자 지정 범위가 있으면 항상 우선 사용 (확장 또는 축소 모두 허용)&#10;        val finalMin = actualMin?.toDouble() ?: niceMin&#10;        val finalMax = actualMax?.toDouble() ?: niceMax&#10;&#10;        // 최종 범위에 대해 ticks 생성&#10;        val ticks = mutableListOf&lt;Float&gt;()&#10;        &#10;        // 사용자 지정 최소값이 있으면 먼저 추가&#10;        actualMin?.let { userMin -&gt;&#10;            ticks.add(userMin)&#10;        }&#10;        &#10;        // step에 따른 nice ticks 추가&#10;        var t = if (actualMin != null) {&#10;            // 사용자 최소값 다음부터 step 단위로 시작&#10;            ceil(finalMin / step) * step&#10;        } else {&#10;            finalMin&#10;        }&#10;        &#10;        while (t &lt;= finalMax + 1e-6) {&#10;            val roundedTick = round(t * 1000000) / 1000000&#10;            val tickValue = roundedTick.toFloat()&#10;            &#10;            // 사용자 지정 값과 중복되지 않는 경우만 추가&#10;            if (actualMin == null || abs(tickValue - actualMin) &gt; 1e-6) {&#10;                if (actualMax == null || abs(tickValue - actualMax) &gt; 1e-6) {&#10;                    ticks.add(tickValue)&#10;                }&#10;            }&#10;            t += step&#10;        }&#10;        &#10;        // 사용자 지정 최대값이 있으면 마지막에 추가&#10;        actualMax?.let { userMax -&gt;&#10;            ticks.add(userMax)&#10;        }&#10;&#10;        return ticks.distinct().sorted()&#10;    }&#10;&#10;    /**&#10;     * 차트 그리기에 필요한 메트릭 값을 계산합니다.&#10;     *&#10;     * @param size Canvas의 전체 크기&#10;     * @param values 차트에 표시할 Y축 데이터 값 목록&#10;     * @param tickCount 원하는 Y축 눈금 개수 (기본값: 5)&#10;     * @param chartType 차트 타입 (BAR/STACKED_BAR 타입일 경우 기본적으로 minY를 0으로 설정)&#10;     * @param isMinimal 미니멀 차트 모드인지 여부 (기본값: false)&#10;     * @param paddingX X축 패딩 값 (기본값: normal=60f, minimal=8f)&#10;     * @param paddingY Y축 패딩 값 (기본값: normal=40f, minimal=8f)&#10;     * @param minY 사용자 지정 최소 Y값 (지정시 바 차트의 기본 동작을 오버라이드)&#10;     * @param maxY 사용자 지정 최대 Y값 (지정시 nice ticks보다 우선적용)&#10;     * @return 차트 메트릭 객체&#10;     */&#10;    fun computeMetrics(&#10;        size: Size, &#10;        values: List&lt;Float&gt;, &#10;        tickCount: Int = 5, &#10;        chartType: ChartType? = null,&#10;        isMinimal: Boolean = false,&#10;        paddingX: Float = if (isMinimal) 8f else 60f,&#10;        paddingY: Float = if (isMinimal) 8f else 40f,&#10;        minY: Float? = null,&#10;        maxY: Float? = null&#10;    ): ChartMetrics {&#10;        val chartWidth = size.width - paddingX&#10;        val chartHeight = size.height - paddingY&#10;&#10;        val dataMax = values.maxOrNull() ?: 1f&#10;        val dataMin = values.minOrNull() ?: 0f&#10;&#10;        val yTicks = computeNiceTicks(dataMin, dataMax, tickCount, chartType, actualMin = minY, actualMax = maxY)&#10;&#10;        // Y축 범위 계산: 사용자 지정 값이 있으면 우선 사용, 없으면 nice ticks 또는 데이터 범위 사용&#10;        val actualMinY = if (isMinimal) {&#10;            minY ?: dataMin&#10;        } else {&#10;            minY ?: (yTicks.minOrNull() ?: dataMin)&#10;        }&#10;        &#10;        val actualMaxY = if (isMinimal) {&#10;            maxY ?: dataMax&#10;        } else {&#10;            maxY ?: (yTicks.maxOrNull() ?: dataMax)&#10;        }&#10;&#10;        return ChartMetrics(paddingX, paddingY, chartWidth, chartHeight, actualMinY, actualMaxY, yTicks)&#10;    }&#10;&#10;    /**&#10;     * 데이터 포인트를 화면 좌표로 변환합니다.&#10;     *&#10;     * @param data 차트 데이터 포인트 목록&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @return 화면 좌표로 변환된 Offset 목록&#10;     */&#10;    fun mapToCanvasPoints(data: List&lt;ChartPoint&gt;, size: Size, metrics: ChartMetrics): List&lt;Offset&gt; {&#10;        val spacing = metrics.chartWidth / (data.size - 1)&#10;        return data.mapIndexed { i, point -&gt;&#10;            val x = metrics.paddingX + i * spacing&#10;            val y = metrics.chartHeight - ((point.y - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;            Offset(x, y)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartMath&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.ChartType&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import java.time.YearMonth&#10;import kotlin.math.abs&#10;import kotlin.math.ceil&#10;import kotlin.math.floor&#10;import kotlin.math.log10&#10;import kotlin.math.pow&#10;import kotlin.math.round&#10;import kotlin.math.sqrt&#10;&#10;object ChartMath {&#10;&#10;    var Pie = PieChartMath&#10;    var Calendar = CalendarChartMath&#10;    val RangeBar = RangeBarChartMath&#10;    val Line = LineChartMath&#10;    val Progress = ProgressChartMath&#10;    val Min = MinimalChartMath&#10;&#10;    /**&#10;     * 차트 그리기에 필요한 메트릭 정보를 담는 데이터 클래스&#10;     *&#10;     * @param paddingX X축 패딩 값&#10;     * @param paddingY Y축 패딩 값&#10;     * @param chartWidth 차트의 실제 너비&#10;     * @param chartHeight 차트의 실제 높이&#10;     * @param minY Y축의 최소값&#10;     * @param maxY Y축의 최대값&#10;     * @param yTicks Y축에 표시할 눈금 값들&#10;     */&#10;    data class ChartMetrics(&#10;        val paddingX: Float,&#10;        val paddingY: Float,&#10;        val chartWidth: Float,&#10;        val chartHeight: Float,&#10;        val minY: Float,&#10;        val maxY: Float,&#10;        val yTicks: List&lt;Float&gt;&#10;    )&#10;&#10;    /**&#10;     * y-axis 눈금 값들을 계산합니다.&#10;     * 1, 2, 5의 배수를 사용하여 시각적으로 깔끔한 눈금을 생성합니다.&#10;     *&#10;     * @param min 데이터의 최소값&#10;     * @param max 데이터의 최대값&#10;     * @param tickCount 원하는 눈금 개수 (기본값: 5)&#10;     * @param chartType 차트 타입 (BAR/STACKED_BAR/MINIMAL_BAR일 경우 최소값을 0으로 강제)&#10;     * @param actualMin 사용자 지정 최소 Y값 (지정시 데이터 범위를 확장)&#10;     * @param actualMax 사용자 지정 최대 Y값 (지정시 데이터 범위를 확장)&#10;     * @return 계산된 눈금 값들의 리스트&#10;     */&#10;    fun computeNiceTicks(&#10;        min: Float, &#10;        max: Float, &#10;        tickCount: Int = 5, &#10;        chartType: ChartType? = null,&#10;        actualMin: Float? = null,&#10;        actualMax: Float? = null&#10;    ): List&lt;Float&gt; {&#10;        if (min &gt;= max) {&#10;            return listOf(0f, 1f)&#10;        }&#10;        &#10;        // 바 차트의 경우 최소값을 0으로 강제 설정&#10;        var min = if (chartType == ChartType.BAR || &#10;                             chartType == ChartType.STACKED_BAR || &#10;                             chartType == ChartType.MINIMAL_BAR) {&#10;            0f&#10;        } else {&#10;            min&#10;        }&#10;        &#10;        val rawStep = (max - min) / tickCount.toDouble()&#10;        val power = 10.0.pow(floor(log10(rawStep)))&#10;        val candidates = listOf(1.0, 2.0, 5.0).map { it * power }&#10;        val step = candidates.minByOrNull { abs(it - rawStep) } ?: power&#10;&#10;        val niceMin = floor(min / step) * step&#10;        val niceMax = ceil(max / step) * step&#10;&#10;        // 사용자 지정 범위가 있으면 항상 우선 사용 (확장 또는 축소 모두 허용)&#10;        val finalMin = actualMin?.toDouble() ?: niceMin&#10;        val finalMax = actualMax?.toDouble() ?: niceMax&#10;&#10;        // 최종 범위에 대해 ticks 생성&#10;        val ticks = mutableListOf&lt;Float&gt;()&#10;        &#10;        // 사용자 지정 최소값이 있으면 먼저 추가&#10;        actualMin?.let { userMin -&gt;&#10;            ticks.add(userMin)&#10;        }&#10;        &#10;        // step에 따른 nice ticks 추가&#10;        var t = if (actualMin != null) {&#10;            // 사용자 최소값 다음부터 step 단위로 시작&#10;            ceil(finalMin / step) * step&#10;        } else {&#10;            finalMin&#10;        }&#10;        &#10;        while (t &lt;= finalMax + 1e-6) {&#10;            val roundedTick = round(t * 1000000) / 1000000&#10;            val tickValue = roundedTick.toFloat()&#10;            &#10;            // 사용자 지정 값과 중복되지 않는 경우만 추가&#10;            if (actualMin == null || abs(tickValue - actualMin) &gt; 1e-6) {&#10;                if (actualMax == null || abs(tickValue - actualMax) &gt; 1e-6) {&#10;                    ticks.add(tickValue)&#10;                }&#10;            }&#10;            t += step&#10;        }&#10;        &#10;        // 사용자 지정 최대값이 있으면 마지막에 추가&#10;        actualMax?.let { userMax -&gt;&#10;            ticks.add(userMax)&#10;        }&#10;&#10;        return ticks.distinct().sorted()&#10;    }&#10;&#10;    /**&#10;     * 차트 그리기에 필요한 메트릭 값을 계산합니다.&#10;     *&#10;     * @param size Canvas의 전체 크기&#10;     * @param values 차트에 표시할 Y축 데이터 값 목록&#10;     * @param tickCount 원하는 Y축 눈금 개수 (기본값: 5)&#10;     * @param chartType 차트 타입 (BAR/STACKED_BAR 타입일 경우 기본적으로 minY를 0으로 설정)&#10;     * @param isMinimal 미니멀 차트 모드인지 여부 (기본값: false)&#10;     * @param paddingX X축 패딩 값 (기본값: normal=60f, minimal=8f)&#10;     * @param paddingY Y축 패딩 값 (기본값: normal=40f, minimal=8f)&#10;     * @param minY 사용자 지정 최소 Y값 (지정시 바 차트의 기본 동작을 오버라이드)&#10;     * @param maxY 사용자 지정 최대 Y값 (지정시 nice ticks보다 우선적용)&#10;     * @return 차트 메트릭 객체&#10;     */&#10;    fun computeMetrics(&#10;        size: Size, &#10;        values: List&lt;Float&gt;, &#10;        tickCount: Int = 5, &#10;        chartType: ChartType? = null,&#10;        isMinimal: Boolean = false,&#10;        paddingX: Float = if (isMinimal) 8f else 60f,&#10;        paddingY: Float = if (isMinimal) 8f else 40f,&#10;        minY: Float? = null,&#10;        maxY: Float? = null&#10;    ): ChartMetrics {&#10;        val chartWidth = size.width - paddingX&#10;        val chartHeight = size.height - paddingY&#10;&#10;        val dataMax = values.maxOrNull() ?: 1f&#10;        val dataMin = values.minOrNull() ?: 0f&#10;&#10;        val yTicks = computeNiceTicks(dataMin, dataMax, tickCount, chartType, actualMin = minY, actualMax = maxY)&#10;&#10;        // Y축 범위 계산: 사용자 지정 값이 있으면 우선 사용, 없으면 nice ticks 또는 데이터 범위 사용&#10;        val actualMinY = if (isMinimal) {&#10;            minY ?: dataMin&#10;        } else {&#10;            minY ?: (yTicks.minOrNull() ?: dataMin)&#10;        }&#10;        &#10;        val actualMaxY = if (isMinimal) {&#10;            maxY ?: dataMax&#10;        } else {&#10;            maxY ?: (yTicks.maxOrNull() ?: dataMax)&#10;        }&#10;&#10;        return ChartMetrics(paddingX, paddingY, chartWidth, chartHeight, actualMinY, actualMaxY, yTicks)&#10;    }&#10;&#10;    /**&#10;     * 데이터 포인트를 화면 좌표로 변환합니다.&#10;     *&#10;     * @param data 차트 데이터 포인트 목록&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @return 화면 좌표로 변환된 Offset 목록&#10;     */&#10;    fun mapToCanvasPoints(data: List&lt;ChartPoint&gt;, size: Size, metrics: ChartMetrics): List&lt;Offset&gt; {&#10;        val spacing = metrics.chartWidth / (data.size - 1)&#10;        return data.mapIndexed { i, point -&gt;&#10;            val x = metrics.paddingX + i * spacing&#10;            val y = metrics.chartHeight - ((point.y - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;            Offset(x, y)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartMath/MinimalChartMath.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartMath/MinimalChartMath.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartMath&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;&#10;object MinimalChartMath {&#10;    &#10;    /**&#10;     * 미니멀 범위 바 차트용 단일 바 위치를 계산합니다.&#10;     * &#10;     * @param size 캔버스 크기&#10;     * @param rangePoint 범위 데이터 포인트 (yMin, yMax)&#10;     * @param containerMin 컨테이너의 최소값 (전체 범위 시작)&#10;     * @param containerMax 컨테이너의 최대값 (전체 범위 끝)&#10;     * @param padding 패딩&#10;     * @return 범위 바 정보: (컨테이너 위치, 컨테이너 크기, 범위바 위치, 범위바 크기)&#10;     */&#10;    fun computeMinimalRangeBarPosition(&#10;        size: Size,&#10;        rangePoint: RangeChartPoint,&#10;        containerMin: Float,&#10;        containerMax: Float,&#10;        padding: Float = 8f&#10;    ): Pair&lt;Pair&lt;Offset, Size&gt;, Pair&lt;Offset, Size&gt;&gt; {&#10;        val chartWidth = size.width - (padding * 2)&#10;        val chartHeight = size.height - (padding * 2)&#10;        &#10;        // 텍스트 공간을 예약하는 경우 바 높이를 줄이고 위치를 조정&#10;        val textSpaceHeight = if (reserveTextSpace) 24f else 0f&#10;        val availableBarHeight = chartHeight - textSpaceHeight&#10;        val containerHeight = availableBarHeight * 0.6f // 사용 가능한 높이의 60%&#10;        &#10;        // 전체 컨테이너 바 (배경)&#10;        val containerX = padding&#10;        val containerY = if (reserveTextSpace) {&#10;            padding + textSpaceHeight + (availableBarHeight - containerHeight) / 2f&#10;        } else {&#10;            (size.height - containerHeight) / 2f&#10;        }&#10;        val containerOffset = Offset(containerX, containerY)&#10;        val containerSize = Size(chartWidth, containerHeight)&#10;        &#10;        val containerRange = containerMax - containerMin&#10;        &#10;        // 데이터 범위가 컨테이너 범위를 벗어나지 않도록 클램핑&#10;        val clampedDataMin = rangePoint.yMin.coerceIn(containerMin, containerMax)&#10;        val clampedDataMax = rangePoint.yMax.coerceIn(containerMin, containerMax)&#10;        &#10;        // 정규화된 위치 계산 (0.0 ~ 1.0)&#10;        val startRatio = if (containerRange &gt; 0) {&#10;            (clampedDataMin - containerMin) / containerRange&#10;        } else 0f&#10;        val endRatio = if (containerRange &gt; 0) {&#10;            (clampedDataMax - containerMin) / containerRange&#10;        } else 1f&#10;        &#10;        // 실제 데이터 범위 바&#10;        val rangeBarX = containerX + (chartWidth * startRatio)&#10;        val rangeBarWidth = chartWidth * (endRatio - startRatio)&#10;        val rangeBarOffset = Offset(rangeBarX, containerY)&#10;        val rangeBarSize = Size(rangeBarWidth, containerHeight)&#10;        &#10;        return Pair(&#10;            Pair(containerOffset, containerSize),&#10;            Pair(rangeBarOffset, rangeBarSize)&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartMath&#10;&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;&#10;object MinimalChartMath {&#10;    &#10;    /**&#10;     * 미니멀 범위 바 차트용 단일 바 위치를 계산합니다.&#10;     * &#10;     * @param size 캔버스 크기&#10;     * @param rangePoint 범위 데이터 포인트 (yMin, yMax)&#10;     * @param containerMin 컨테이너의 최소값 (전체 범위 시작)&#10;     * @param containerMax 컨테이너의 최대값 (전체 범위 끝)&#10;     * @param padding 패딩&#10;     * @return 범위 바 정보: (컨테이너 위치, 컨테이너 크기, 범위바 위치, 범위바 크기)&#10;     */&#10;    fun computeMinimalRangeBarPosition(&#10;        size: Size,&#10;        rangePoint: RangeChartPoint,&#10;        containerMin: Float,&#10;        containerMax: Float,&#10;        padding: Float = 8f&#10;    ): Pair&lt;Pair&lt;Offset, Size&gt;, Pair&lt;Offset, Size&gt;&gt; {&#10;        val chartWidth = size.width - (padding * 2)&#10;        val chartHeight = size.height - (padding * 2)&#10;        &#10;        // 텍스트 공간을 예약하는 경우 바 높이를 줄이고 위치를 조정&#10;        val textSpaceHeight = if (reserveTextSpace) 24f else 0f&#10;        val availableBarHeight = chartHeight - textSpaceHeight&#10;        val containerHeight = availableBarHeight * 0.6f // 사용 가능한 높이의 60%&#10;        &#10;        // 전체 컨테이너 바 (배경)&#10;        val containerX = padding&#10;        val containerY = if (reserveTextSpace) {&#10;            padding + textSpaceHeight + (availableBarHeight - containerHeight) / 2f&#10;        } else {&#10;            (size.height - containerHeight) / 2f&#10;        }&#10;        val containerOffset = Offset(containerX, containerY)&#10;        val containerSize = Size(chartWidth, containerHeight)&#10;        &#10;        val containerRange = containerMax - containerMin&#10;        &#10;        // 데이터 범위가 컨테이너 범위를 벗어나지 않도록 클램핑&#10;        val clampedDataMin = rangePoint.yMin.coerceIn(containerMin, containerMax)&#10;        val clampedDataMax = rangePoint.yMax.coerceIn(containerMin, containerMax)&#10;        &#10;        // 정규화된 위치 계산 (0.0 ~ 1.0)&#10;        val startRatio = if (containerRange &gt; 0) {&#10;            (clampedDataMin - containerMin) / containerRange&#10;        } else 0f&#10;        val endRatio = if (containerRange &gt; 0) {&#10;            (clampedDataMax - containerMin) / containerRange&#10;        } else 1f&#10;        &#10;        // 실제 데이터 범위 바&#10;        val rangeBarX = containerX + (chartWidth * startRatio)&#10;        val rangeBarWidth = chartWidth * (endRatio - startRatio)&#10;        val rangeBarOffset = Offset(rangeBarX, containerY)&#10;        val rangeBarSize = Size(rangeBarWidth, containerHeight)&#10;        &#10;        return Pair(&#10;            Pair(containerOffset, containerSize),&#10;            Pair(rangeBarOffset, rangeBarSize)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/MinimalRangeBarChart.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/MinimalRangeBarChart.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;/**&#10; * 미니멀 범위 바 차트 - 위젯이나 스마트워치 등 작은 화면용&#10; * 범위 데이터를 컨테이너 범위 내에서 표시하며, 상단에 범위 텍스트 표시&#10; * &#10; * @param modifier 모디파이어&#10; * @param data 범위 차트 데이터 (yMin, yMax 포함)&#10; * @param containerMin 컨테이너의 최소값 (전체 범위 시작)&#10; * @param containerMax 컨테이너의 최대값 (전체 범위 끝)&#10; * @param containerColor 컨테이너(배경) 바 색상&#10; * @param rangeColor 범위 바 색상&#10; * @param textColor 범위 텍스트 색상&#10; * @param width 차트 너비&#10; * @param height 차트 높이&#10; * @param padding 차트 주변 패딩&#10; * @param showRangeText 범위 텍스트를 표시할지 여부&#10; * @param cornerRadius 바의 모서리 둥글기&#10; */&#10;@Composable&#10;fun MinimalRangeBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: RangeChartPoint,&#10;    containerMin: Float,&#10;    containerMax: Float,&#10;    containerColor: Color = Color.LightGray,&#10;    rangeColor: Color = Color(0xFFFF9500),&#10;    textColor: Color = Color.Black,&#10;    width: Dp = 120.dp,&#10;    height: Dp = 50.dp,&#10;    padding: Float = 8f,&#10;    showRangeText: Boolean = true,&#10;    cornerRadius: Float = 8f&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .then(&#10;                if (width != Dp.Unspecified &amp;&amp; height != Dp.Unspecified) {&#10;                    Modifier.size(width, height)&#10;                } else {&#10;                    Modifier.fillMaxSize()&#10;                }&#10;            )&#10;    ) {&#10;        Canvas(modifier = Modifier.fillMaxSize()) {&#10;            // 범위 바 위치 계산&#10;            val result = ChartMath.Min.computeMinimalRangeBarPosition(&#10;                size = size,&#10;                rangePoint = data,&#10;                containerMin = containerMin,&#10;                containerMax = containerMax,&#10;                padding = padding&#10;            )&#10;            val (containerOffset, containerSize) = result.first&#10;            val (rangeBarOffset, rangeBarSize) = result.second&#10;            &#10;            // 범위 바 그리기&#10;            ChartDraw.Min.drawMinimalRangeBar(&#10;                drawScope = this,&#10;                containerOffset = containerOffset,&#10;                containerSize = containerSize,&#10;                rangeBarOffset = rangeBarOffset,&#10;                rangeBarSize = rangeBarSize,&#10;                containerColor = containerColor,&#10;                rangeColor = rangeColor,&#10;                cornerRadius = cornerRadius&#10;            )&#10;            &#10;            // 범위 텍스트 표시&#10;            if (showRangeText) {&#10;                val rangeText = &quot;${data.yMin.toInt()}-${data.yMax.toInt()}&quot;&#10;                val textPosition = Offset(&#10;                    x = rangeBarOffset.x + (rangeBarSize.width / 2f), // 범위 바의 중앙에 위치&#10;                    y = containerOffset.y - 12f // 바 위쪽에 위치 (여유 공간 증가)&#10;                )&#10;                &#10;                ChartDraw.Min.drawMinimalText(&#10;                    drawScope = this,&#10;                    text = rangeText,&#10;                    position = textPosition,&#10;                    color = textColor,&#10;                    textSize = 16f,&#10;                    alignment = android.graphics.Paint.Align.CENTER&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.RangeChartPoint&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;/**&#10; * 미니멀 범위 바 차트 - 위젯이나 스마트워치 등 작은 화면용&#10; * 범위 데이터를 컨테이너 범위 내에서 표시하며, 상단에 범위 텍스트 표시&#10; * &#10; * @param modifier 모디파이어&#10; * @param data 범위 차트 데이터 (yMin, yMax 포함)&#10; * @param containerMin 컨테이너의 최소값 (전체 범위 시작)&#10; * @param containerMax 컨테이너의 최대값 (전체 범위 끝)&#10; * @param containerColor 컨테이너(배경) 바 색상&#10; * @param rangeColor 범위 바 색상&#10; * @param textColor 범위 텍스트 색상&#10; * @param width 차트 너비&#10; * @param height 차트 높이&#10; * @param padding 차트 주변 패딩&#10; * @param showRangeText 범위 텍스트를 표시할지 여부&#10; * @param cornerRadius 바의 모서리 둥글기&#10; */&#10;@Composable&#10;fun MinimalRangeBarChart(&#10;    modifier: Modifier = Modifier,&#10;    data: RangeChartPoint,&#10;    containerMin: Float,&#10;    containerMax: Float,&#10;    containerColor: Color = Color.LightGray,&#10;    rangeColor: Color = Color(0xFFFF9500),&#10;    textColor: Color = Color.Black,&#10;    width: Dp = 120.dp,&#10;    height: Dp = 50.dp,&#10;    padding: Float = 8f,&#10;    showRangeText: Boolean = true,&#10;    cornerRadius: Float = 8f&#10;) {&#10;    Box(&#10;        modifier = modifier&#10;            .then(&#10;                if (width != Dp.Unspecified &amp;&amp; height != Dp.Unspecified) {&#10;                    Modifier.size(width, height)&#10;                } else {&#10;                    Modifier.fillMaxSize()&#10;                }&#10;            )&#10;    ) {&#10;        Canvas(modifier = Modifier.fillMaxSize()) {&#10;            // 범위 바 위치 계산&#10;            val result = ChartMath.Min.computeMinimalRangeBarPosition(&#10;                size = size,&#10;                rangePoint = data,&#10;                containerMin = containerMin,&#10;                containerMax = containerMax,&#10;                padding = padding&#10;            )&#10;            val (containerOffset, containerSize) = result.first&#10;            val (rangeBarOffset, rangeBarSize) = result.second&#10;            &#10;            // 범위 바 그리기&#10;            ChartDraw.Min.drawMinimalRangeBar(&#10;                drawScope = this,&#10;                containerOffset = containerOffset,&#10;                containerSize = containerSize,&#10;                rangeBarOffset = rangeBarOffset,&#10;                rangeBarSize = rangeBarSize,&#10;                containerColor = containerColor,&#10;                rangeColor = rangeColor,&#10;                cornerRadius = cornerRadius&#10;            )&#10;            &#10;            // 범위 텍스트 표시&#10;            if (showRangeText) {&#10;                val rangeText = &quot;${data.yMin.toInt()}-${data.yMax.toInt()}&quot;&#10;                val textPosition = Offset(&#10;                    x = rangeBarOffset.x + (rangeBarSize.width / 2f), // 범위 바의 중앙에 위치&#10;                    y = containerOffset.y - 12f // 바 위쪽에 위치 (여유 공간 증가)&#10;                )&#10;                &#10;                ChartDraw.Min.drawMinimalText(&#10;                    drawScope = this,&#10;                    text = rangeText,&#10;                    position = textPosition,&#10;                    color = textColor,&#10;                    textSize = 16f,&#10;                    alignment = android.graphics.Paint.Align.CENTER&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/ScatterPlot.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/charts/ScatterPlot.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;@Composable&#10;fun ScatterPlot(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    xLabel: String = &quot;X Axis&quot;,&#10;    yLabel: String = &quot;Y Axis&quot;,&#10;    title: String = &quot;Scatter Plot Example&quot;,&#10;    pointColor: Color = com.hdil.saluschart.ui.theme.ChartColor.Default,&#10;    width: androidx.compose.ui.unit.Dp = 250.dp,&#10;    height: androidx.compose.ui.unit.Dp = 250.dp,&#10;    tooltipTextSize: Float = 32f        // 툴팁 텍스트 크기&#10;&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.x }&#10;    val yValues = data.map { it.y }&#10;&#10;    // 터치한 바의 위치와 값을 저장할 상태 변수&#10;    var touchedBarValue by remember { mutableStateOf&lt;Float?&gt;(null) }&#10;    var touchedPosition by remember { mutableStateOf&lt;Offset?&gt;(null) }&#10;&#10;&#10;    // State variables for points and selection&#10;    var canvasPoints by remember { mutableStateOf(listOf&lt;Offset&gt;()) }&#10;    var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;    var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(text = title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectTapGestures { tapOffset -&gt;&#10;                        // 터치 이벤트 발생 시 처리&#10;                        touchedPosition = tapOffset&#10;                        // 툴팁을 표시하기 위해 상태 초기화 (바를 탭하지 않았을 때)&#10;                        touchedBarValue = null&#10;                    }&#10;                }&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val metrics = ChartMath.computeMetrics(size, yValues)&#10;                val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;                // Store points and canvas size&#10;                canvasPoints = points&#10;                canvasSize = size&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.Line.drawXAxisLabels(drawContext, xLabels.map { it.toString() }, metrics)&#10;                val hitAreas = ChartDraw.Bar.drawBars(&#10;                    drawScope = this,&#10;                    values = yValues,&#10;                    metrics = metrics,&#10;                    color = Color.Transparent,  // 색상은 사용되지 않음&#10;                    barWidthMultiplier = 1.0f,  // 전체 너비 사용&#10;                    isInteractiveBars = true,&#10;                )&#10;&#10;                touchedPosition?.let { position -&gt;&#10;                    hitAreas.forEachIndexed { index, (hitArea, value) -&gt;&#10;                        if (hitArea.contains(position)) {&#10;                            // 터치한 바의 값을 저장하고 최적 위치 계산 후 통합 툴팁 표시&#10;                            touchedBarValue = value&#10;&#10;                            // 포인트 마커 위에 툴팁 위치 계산 (몇 픽셀 위로)&#10;                            val pointPosition = points[index]&#10;                            val optimalPosition = Offset(&#10;                                x = pointPosition.x,&#10;                                y = pointPosition.y - 40f  // 40 픽셀 위로&#10;                            )&#10;&#10;                            // 통합 툴팁 메서드 사용&#10;                            ChartDraw.drawTooltip(&#10;                                drawScope = this,&#10;                                value = value,&#10;                                position = optimalPosition,&#10;                                textSize = tooltipTextSize&#10;                            )&#10;                            return@forEachIndexed  // 첫 번째 매치에서 중단&#10;                        }&#10;                    }&#10;&#10;                    // 터치한 위치에 바가 없으면 툴팁 숨김&#10;                    if (touchedBarValue == null) {&#10;                        touchedPosition = null&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Add PointMarkers for each data point&#10;            canvasPoints.forEachIndexed { index, point -&gt;&#10;                ChartDraw.Scatter.PointMarker(&#10;                    center = point,&#10;                    value = yValues[index].toInt().toString(),&#10;                    isSelected = true  // 항상 기본 색상으로 표시&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.charts&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.unit.dp&#10;import com.hdil.saluschart.core.chart.chartDraw.ChartDraw&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;@Composable&#10;fun ScatterPlot(&#10;    modifier: Modifier = Modifier,&#10;    data: List&lt;ChartPoint&gt;,&#10;    xLabel: String = &quot;X Axis&quot;,&#10;    yLabel: String = &quot;Y Axis&quot;,&#10;    title: String = &quot;Scatter Plot Example&quot;,&#10;    pointColor: Color = com.hdil.saluschart.ui.theme.ChartColor.Default,&#10;    width: androidx.compose.ui.unit.Dp = 250.dp,&#10;    height: androidx.compose.ui.unit.Dp = 250.dp,&#10;    tooltipTextSize: Float = 32f        // 툴팁 텍스트 크기&#10;&#10;) {&#10;    if (data.isEmpty()) return&#10;&#10;    val xLabels = data.map { it.x }&#10;    val yValues = data.map { it.y }&#10;&#10;    // 터치한 바의 위치와 값을 저장할 상태 변수&#10;    var touchedBarValue by remember { mutableStateOf&lt;Float?&gt;(null) }&#10;    var touchedPosition by remember { mutableStateOf&lt;Offset?&gt;(null) }&#10;&#10;&#10;    // State variables for points and selection&#10;    var canvasPoints by remember { mutableStateOf(listOf&lt;Offset&gt;()) }&#10;    var canvasSize by remember { mutableStateOf(Size.Zero) }&#10;    var selectedPointIndex by remember { mutableStateOf&lt;Int?&gt;(null) }&#10;&#10;    Column(modifier = modifier.padding(16.dp)) {&#10;        Text(text = title, style = MaterialTheme.typography.titleMedium)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectTapGestures { tapOffset -&gt;&#10;                        // 터치 이벤트 발생 시 처리&#10;                        touchedPosition = tapOffset&#10;                        // 툴팁을 표시하기 위해 상태 초기화 (바를 탭하지 않았을 때)&#10;                        touchedBarValue = null&#10;                    }&#10;                }&#10;        ) {&#10;            Canvas(modifier = Modifier.fillMaxSize()) {&#10;                val metrics = ChartMath.computeMetrics(size, yValues)&#10;                val points = ChartMath.mapToCanvasPoints(data, size, metrics)&#10;&#10;                // Store points and canvas size&#10;                canvasPoints = points&#10;                canvasSize = size&#10;&#10;                ChartDraw.drawGrid(this, size, metrics)&#10;                ChartDraw.Line.drawXAxisLabels(drawContext, xLabels.map { it.toString() }, metrics)&#10;                val hitAreas = ChartDraw.Bar.drawBars(&#10;                    drawScope = this,&#10;                    values = yValues,&#10;                    metrics = metrics,&#10;                    color = Color.Transparent,  // 색상은 사용되지 않음&#10;                    barWidthMultiplier = 1.0f,  // 전체 너비 사용&#10;                    isInteractiveBars = true,&#10;                )&#10;&#10;                touchedPosition?.let { position -&gt;&#10;                    hitAreas.forEachIndexed { index, (hitArea, value) -&gt;&#10;                        if (hitArea.contains(position)) {&#10;                            // 터치한 바의 값을 저장하고 최적 위치 계산 후 통합 툴팁 표시&#10;                            touchedBarValue = value&#10;&#10;                            // 포인트 마커 위에 툴팁 위치 계산 (몇 픽셀 위로)&#10;                            val pointPosition = points[index]&#10;                            val optimalPosition = Offset(&#10;                                x = pointPosition.x,&#10;                                y = pointPosition.y - 40f  // 40 픽셀 위로&#10;                            )&#10;&#10;                            // 통합 툴팁 메서드 사용&#10;                            ChartDraw.drawTooltip(&#10;                                drawScope = this,&#10;                                value = value,&#10;                                position = optimalPosition,&#10;                                textSize = tooltipTextSize&#10;                            )&#10;                            return@forEachIndexed  // 첫 번째 매치에서 중단&#10;                        }&#10;                    }&#10;&#10;                    // 터치한 위치에 바가 없으면 툴팁 숨김&#10;                    if (touchedBarValue == null) {&#10;                        touchedPosition = null&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Add PointMarkers for each data point&#10;            canvasPoints.forEachIndexed { index, point -&gt;&#10;                ChartDraw.Scatter.PointMarker(&#10;                    center = point,&#10;                    value = yValues[index].toInt().toString(),&#10;                    isSelected = true  // 항상 기본 색상으로 표시&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>