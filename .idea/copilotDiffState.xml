<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/ChartDraw.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/chart/src/main/java/com/hdil/saluschart/core/chart/chartDraw/ChartDraw.kt" />
              <option name="originalContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import android.util.Log&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;object ChartDraw {&#10;&#10;    var Pie = PieChartDraw&#10;    val RangeBar = RangeBarChartDraw&#10;    val Line = LineChartDraw&#10;    val Bar = BarChartDraw&#10;    val Scatter = ScatterPlotDraw&#10;    val Progress = ProgressChartDraw&#10;    val Gauge = GaugeChartDraw&#10;&#10;    /**&#10;     * 눈금 값을 적절한 형식으로 포맷합니다.&#10;     *&#10;     * @param value 눈금 값&#10;     * @return 포맷된 문자열&#10;     */&#10;    fun formatTickLabel(value: Float): String {&#10;        return when {&#10;            value == 0f -&gt; &quot;0&quot;&#10;            value &gt;= 1000000 -&gt; &quot;%.1fM&quot;.format(value / 1000000)&#10;            value &gt;= 1000 -&gt; &quot;%.1fK&quot;.format(value / 1000)&#10;            value % 1 == 0f -&gt; &quot;%.0f&quot;.format(value)&#10;            else -&gt; &quot;%.1f&quot;.format(value)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Y축 그리드와 레이블을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yPosition Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;     */&#10;    fun drawGrid(drawScope: DrawScope, size: Size, metrics: ChartMath.ChartMetrics, yPosition: String = &quot;left&quot;) {&#10;        // Y축 라인의 실제 X 좌표 계산&#10;        val yAxisX = when (yPosition) {&#10;            &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth&#10;            else -&gt; metrics.paddingX&#10;        }&#10;&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            val y = metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // 그리드 라인은 차트 영역 전체에 걸쳐 그리기&#10;            val gridStart = when (yPosition) {&#10;                &quot;right&quot; -&gt; metrics.paddingX // 오른쪽 Y축일 때는 왼쪽부터 시작&#10;                else -&gt; metrics.paddingX // 왼쪽 Y축일 때도 왼쪽부터 시작&#10;            }&#10;            val gridEnd = when (yPosition) {&#10;                &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 Y축까지&#10;                else -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 끝까지&#10;            }&#10;&#10;            drawScope.drawLine(&#10;                color = Color.LightGray,&#10;                start = Offset(gridStart, y),&#10;                end = Offset(gridEnd, y),&#10;                strokeWidth = 1f&#10;            )&#10;            &#10;            val labelText = formatTickLabel(yVal)&#10;&#10;            // Y축 레이블 위치를 yPosition에 따라 결정&#10;            val labelX = when (yPosition) {&#10;                &quot;right&quot; -&gt; yAxisX + 20f // 오른쪽 Y축 라인의 오른쪽에 위치&#10;                else -&gt; 20f // 기본값: 왼쪽 위치&#10;            }&#10;&#10;            // Y축 레이블 정렬을 yPosition에 따라 결정&#10;            val textAlign = when (yPosition) {&#10;                &quot;right&quot; -&gt; android.graphics.Paint.Align.LEFT // 오른쪽 Y축일 때는 왼쪽 정렬&#10;                else -&gt; android.graphics.Paint.Align.RIGHT // 왼쪽 Y축일 때는 오른쪽 정렬&#10;            }&#10;&#10;            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;                labelText,&#10;                labelX,&#10;                y + 10f,&#10;                android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.DKGRAY&#10;                    textSize = 28f&#10;                    textAlign = textAlign&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * X축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     */&#10;    fun drawXAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics) {&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(metrics.paddingX, metrics.chartHeight),&#10;            end = Offset(metrics.paddingX + metrics.chartWidth, metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Y축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yPosition Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;     */&#10;    fun drawYAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics, yPosition: String = &quot;left&quot;) {&#10;        // Y축 라인 위치를 yPosition에 따라 결정&#10;        val axisStartX = when (yPosition) {&#10;            &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 위치&#10;            else -&gt; metrics.paddingX // 기본값: 왼쪽 위치&#10;        }&#10;&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisStartX, 0f),&#10;            end = Offset(axisStartX, metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;// ** 쓰이지 않는 Canvas API를 사용한 코드 **&#10;//&#10;//    /**&#10;//     * 범례를 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록&#10;//     * @param colors 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (null인 경우 제목 없음)&#10;//     * @param baseItemHeight 기본 항목 간 세로 간격 (스케일링 적용됨)&#10;//     */&#10;//    fun drawLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        baseItemHeight: Float = 20f&#10;//    ) {&#10;//        // 차트 크기에 따른 스케일 팩터 계산 (기준: 250x250)&#10;//        val scaleFactor = minOf(chartSize.width, chartSize.height) / 250f&#10;//        val clampedScale = scaleFactor.coerceIn(0.5f, 2.0f)&#10;//&#10;//        val colorBoxSize = (8f * clampedScale).coerceAtLeast(4f)&#10;//        val padding = (4f * clampedScale).coerceAtLeast(2f)&#10;//        val itemHeight = baseItemHeight * clampedScale&#10;//        val titleTextSize = (14f * clampedScale).coerceAtLeast(10f)&#10;//        val labelTextSize = (12f * clampedScale).coerceAtLeast(8f)&#10;//&#10;//        Log.e(&quot;ChartDraw&quot;, &quot;Legend scale factor: $clampedScale, itemHeight: $itemHeight, colorBoxSize: $colorBoxSize, labelTextSize: $labelTextSize&quot;)&#10;//&#10;//        var yOffset = position.y&#10;//&#10;//        // 범례 제목 그리기 (제공된 경우)&#10;//        title?.let {&#10;//            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//                it,&#10;//                position.x,&#10;//                yOffset,&#10;//                android.graphics.Paint().apply {&#10;//                    color = android.graphics.Color.DKGRAY&#10;//                    textSize = titleTextSize&#10;//                    isFakeBoldText = true&#10;//                }&#10;//            )&#10;//            yOffset += itemHeight * 0.8f&#10;//        }&#10;//&#10;//        // 각 범례 항목 그리기&#10;//        labels.forEachIndexed { index, label -&gt;&#10;//            if (index &lt; colors.size) {&#10;//                drawLegendItem(&#10;//                    drawScope,&#10;//                    colors[index],&#10;//                    label,&#10;//                    Offset(position.x, yOffset),&#10;//                    colorBoxSize,&#10;//                    padding,&#10;//                    labelTextSize&#10;//                )&#10;//                yOffset += itemHeight * 0.7f&#10;//            }&#10;//        }&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트의 범례를 그립니다 (통합된 범례 시스템, 스케일링 지원).&#10;//     *&#10;//     * 파이 차트와 스택 바 차트 모두에서 사용할 수 있는 통합된 범례 시스템입니다.&#10;//     * 레이블을 직접 제공하거나 차트 데이터에서 추출할 수 있습니다.&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10;//     * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10;//     * @param colors 각 항목에 사용한 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (기본값: null)&#10;//     * @param itemHeight 항목 간 세로 간격&#10;//     */&#10;//    fun drawChartLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;? = null,&#10;//        chartData: List&lt;ChartPoint&gt;? = null,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        itemHeight: Float = 40f&#10;//    ) {&#10;//        val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;//            point.label ?: &quot;항목 ${i+1}&quot;&#10;//        } ?: emptyList()&#10;//&#10;//        drawLegend(drawScope, legendLabels, colors, position, chartSize, title, itemHeight)&#10;//    }&#10;//&#10;//    /**&#10;//     * 범례의 개별 항목을 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param color 색상&#10;//     * @param label 레이블 텍스트&#10;//     * @param position 항목이 표시될 위치&#10;//     * @param boxSize 색상 상자 크기 (이미 스케일링 적용됨)&#10;//     * @param padding 상자와 텍스트 사이 간격 (이미 스케일링 적용됨)&#10;//     * @param textSize 텍스트 크기 (이미 스케일링 적용됨)&#10;//     */&#10;//    fun drawLegendItem(&#10;//        drawScope: DrawScope,&#10;//        color: Color,&#10;//        label: String,&#10;//        position: Offset,&#10;//        boxSize: Float,&#10;//        padding: Float,&#10;//        textSize: Float = 30f&#10;//    ) {&#10;//        // 색상 상자 그리기&#10;//        drawScope.drawRect(&#10;//            color = color,&#10;//            topLeft = position,&#10;//            size = Size(boxSize, boxSize)&#10;//        )&#10;//&#10;//        // 레이블 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            label,&#10;//            position.x + boxSize + padding,&#10;//            position.y + boxSize,&#10;//            android.graphics.Paint().apply {&#10;//                this.color = android.graphics.Color.DKGRAY&#10;//                this.textSize = textSize&#10;//            }&#10;//        )&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트 툴팁을 그립니다 (모든 차트 타입에서 공통 사용).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param value 표시할 값&#10;//     * @param position 툴팁이 표시될 위치 (미리 계산된 최적 위치)&#10;//     * @param backgroundColor 툴팁 배경 색상&#10;//     * @param textColor 텍스트 색상&#10;//     * @param textSize 툴팁 텍스트 크기 (기본값: 32f)&#10;//     */&#10;//    fun drawTooltip(&#10;//        drawScope: DrawScope,&#10;//        value: Float,&#10;//        position: Offset,&#10;//        backgroundColor: Color = Color(0xE6333333), // 반투명 다크 그레이&#10;//        textColor: Int = android.graphics.Color.WHITE,&#10;//        textSize: Float = 32f&#10;//    ) {&#10;//        val tooltipText = formatTickLabel(value)&#10;//        val textPaint = android.graphics.Paint().apply {&#10;//            color = textColor&#10;//            this.textSize = textSize&#10;//            textAlign = android.graphics.Paint.Align.CENTER&#10;//        }&#10;//&#10;//        // 텍스트 크기 측정&#10;//        val textBounds = android.graphics.Rect()&#10;//        textPaint.getTextBounds(tooltipText, 0, tooltipText.length, textBounds)&#10;//&#10;//        // 툴팁 크기 계산 (패딩 포함)&#10;//        val padding = 16f&#10;//        val tooltipWidth = textBounds.width() + padding * 2&#10;//        val tooltipHeight = textBounds.height() + padding * 2&#10;//&#10;//        // 툴팁이 화면 밖으로 나가지 않도록 위치 조정&#10;//        val tooltipX = position.x.coerceIn(&#10;//            tooltipWidth / 2,&#10;//            drawScope.size.width - tooltipWidth / 2&#10;//        )&#10;//        val tooltipY = position.y.coerceIn(&#10;//            tooltipHeight / 2,&#10;//            drawScope.size.height - tooltipHeight / 2&#10;//        )&#10;//&#10;//        // 배경 그리기&#10;//        drawScope.drawRoundRect(&#10;//            color = backgroundColor,&#10;//            topLeft = Offset(tooltipX - tooltipWidth / 2, tooltipY - tooltipHeight / 2),&#10;//            size = Size(tooltipWidth, tooltipHeight),&#10;//            cornerRadius = androidx.compose.ui.geometry.CornerRadius(4f)&#10;//        )&#10;//&#10;//        // 텍스트 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            tooltipText,&#10;//            tooltipX,&#10;//            tooltipY + textBounds.height() / 2,&#10;//            textPaint&#10;//        )&#10;//    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.hdil.saluschart.core.chart.chartDraw&#10;&#10;import android.util.Log&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.drawscope.DrawScope&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;import com.hdil.saluschart.core.chart.chartMath.ChartMath&#10;&#10;object ChartDraw {&#10;&#10;    var Pie = PieChartDraw&#10;    val RangeBar = RangeBarChartDraw&#10;    val Line = LineChartDraw&#10;    val Bar = BarChartDraw&#10;    val Scatter = ScatterPlotDraw&#10;    val Progress = ProgressChartDraw&#10;    val Gauge = GaugeChartDraw&#10;&#10;    /**&#10;     * 눈금 값을 적절한 형식으로 포맷합니다.&#10;     *&#10;     * @param value 눈금 값&#10;     * @return 포맷된 문자열&#10;     */&#10;    fun formatTickLabel(value: Float): String {&#10;        return when {&#10;            value == 0f -&gt; &quot;0&quot;&#10;            value &gt;= 1000000 -&gt; &quot;%.1fM&quot;.format(value / 1000000)&#10;            value &gt;= 1000 -&gt; &quot;%.1fK&quot;.format(value / 1000)&#10;            value % 1 == 0f -&gt; &quot;%.0f&quot;.format(value)&#10;            else -&gt; &quot;%.1f&quot;.format(value)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Y축 그리드와 레이블을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param size Canvas의 전체 크기&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yPosition Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;     */&#10;    fun drawGrid(drawScope: DrawScope, size: Size, metrics: ChartMath.ChartMetrics, yPosition: String = &quot;left&quot;) {&#10;        // Y축 라인의 실제 X 좌표 계산&#10;        val yAxisX = when (yPosition) {&#10;            &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth&#10;            else -&gt; metrics.paddingX&#10;        }&#10;&#10;        metrics.yTicks.forEach { yVal -&gt;&#10;            val y = metrics.chartHeight - ((yVal - metrics.minY) / (metrics.maxY - metrics.minY)) * metrics.chartHeight&#10;&#10;            // 그리드 라인은 차트 영역 전체에 걸쳐 그리기&#10;            val gridStart = when (yPosition) {&#10;                &quot;right&quot; -&gt; metrics.paddingX // 오른쪽 Y축일 때는 왼쪽부터 시작&#10;                else -&gt; metrics.paddingX // 왼쪽 Y축일 때도 왼쪽부터 시작&#10;            }&#10;            val gridEnd = when (yPosition) {&#10;                &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 Y축까지&#10;                else -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 끝까지&#10;            }&#10;&#10;            drawScope.drawLine(&#10;                color = Color.LightGray,&#10;                start = Offset(gridStart, y),&#10;                end = Offset(gridEnd, y),&#10;                strokeWidth = 1f&#10;            )&#10;            &#10;            val labelText = formatTickLabel(yVal)&#10;&#10;            // Y축 레이블 위치를 yPosition에 따라 결정&#10;            val labelX = when (yPosition) {&#10;                &quot;right&quot; -&gt; yAxisX + 20f // 오른쪽 Y축 라인의 오른쪽에 위치&#10;                else -&gt; 20f // 기본값: 왼쪽 위치&#10;            }&#10;&#10;            // Y축 레이블 정렬을 yPosition에 따라 결정&#10;            val textAlign = when (yPosition) {&#10;                &quot;right&quot; -&gt; android.graphics.Paint.Align.LEFT // 오른쪽 Y축일 때는 왼쪽 정렬&#10;                else -&gt; android.graphics.Paint.Align.RIGHT // 왼쪽 Y축일 때는 오른쪽 정렬&#10;            }&#10;&#10;            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;                labelText,&#10;                labelX,&#10;                y + 10f,&#10;                android.graphics.Paint().apply {&#10;                    color = android.graphics.Color.DKGRAY&#10;                    textSize = 28f&#10;                    textAlign = textAlign&#10;                }&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * X축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     */&#10;    fun drawXAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics) {&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(metrics.paddingX, metrics.chartHeight),&#10;            end = Offset(metrics.paddingX + metrics.chartWidth, metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Y축 라인을 그립니다.&#10;     *&#10;     * @param drawScope 그리기 영역&#10;     * @param metrics 차트 메트릭 정보&#10;     * @param yPosition Y축 위치 (&quot;left&quot; 또는 &quot;right&quot;)&#10;     */&#10;    fun drawYAxis(drawScope: DrawScope, metrics: ChartMath.ChartMetrics, yPosition: String = &quot;left&quot;) {&#10;        // Y축 라인 위치를 yPosition에 따라 결정&#10;        val axisStartX = when (yPosition) {&#10;            &quot;right&quot; -&gt; metrics.paddingX + metrics.chartWidth // 오른쪽 위치&#10;            else -&gt; metrics.paddingX // 기본값: 왼쪽 위치&#10;        }&#10;&#10;        drawScope.drawLine(&#10;            color = Color.Black,&#10;            start = Offset(axisStartX, 0f),&#10;            end = Offset(axisStartX, metrics.chartHeight),&#10;            strokeWidth = 2f&#10;        )&#10;    }&#10;&#10;// ** 쓰이지 않는 Canvas API를 사용한 코드 **&#10;//&#10;//    /**&#10;//     * 범례를 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록&#10;//     * @param colors 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (null인 경우 제목 없음)&#10;//     * @param baseItemHeight 기본 항목 간 세로 간격 (스케일링 적용됨)&#10;//     */&#10;//    fun drawLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        baseItemHeight: Float = 20f&#10;//    ) {&#10;//        // 차트 크기에 따른 스케일 팩터 계산 (기준: 250x250)&#10;//        val scaleFactor = minOf(chartSize.width, chartSize.height) / 250f&#10;//        val clampedScale = scaleFactor.coerceIn(0.5f, 2.0f)&#10;//&#10;//        val colorBoxSize = (8f * clampedScale).coerceAtLeast(4f)&#10;//        val padding = (4f * clampedScale).coerceAtLeast(2f)&#10;//        val itemHeight = baseItemHeight * clampedScale&#10;//        val titleTextSize = (14f * clampedScale).coerceAtLeast(10f)&#10;//        val labelTextSize = (12f * clampedScale).coerceAtLeast(8f)&#10;//&#10;//        Log.e(&quot;ChartDraw&quot;, &quot;Legend scale factor: $clampedScale, itemHeight: $itemHeight, colorBoxSize: $colorBoxSize, labelTextSize: $labelTextSize&quot;)&#10;//&#10;//        var yOffset = position.y&#10;//&#10;//        // 범례 제목 그리기 (제공된 경우)&#10;//        title?.let {&#10;//            drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//                it,&#10;//                position.x,&#10;//                yOffset,&#10;//                android.graphics.Paint().apply {&#10;//                    color = android.graphics.Color.DKGRAY&#10;//                    textSize = titleTextSize&#10;//                    isFakeBoldText = true&#10;//                }&#10;//            )&#10;//            yOffset += itemHeight * 0.8f&#10;//        }&#10;//&#10;//        // 각 범례 항목 그리기&#10;//        labels.forEachIndexed { index, label -&gt;&#10;//            if (index &lt; colors.size) {&#10;//                drawLegendItem(&#10;//                    drawScope,&#10;//                    colors[index],&#10;//                    label,&#10;//                    Offset(position.x, yOffset),&#10;//                    colorBoxSize,&#10;//                    padding,&#10;//                    labelTextSize&#10;//                )&#10;//                yOffset += itemHeight * 0.7f&#10;//            }&#10;//        }&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트의 범례를 그립니다 (통합된 범례 시스템, 스케일링 지원).&#10;//     *&#10;//     * 파이 차트와 스택 바 차트 모두에서 사용할 수 있는 통합된 범례 시스템입니다.&#10;//     * 레이블을 직접 제공하거나 차트 데이터에서 추출할 수 있습니다.&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10;//     * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10;//     * @param colors 각 항목에 사용한 색상 목록&#10;//     * @param position 범례가 표시될 위치 좌표&#10;//     * @param chartSize 차트 전체 크기 (스케일링 계산용)&#10;//     * @param title 범례 제목 (기본값: null)&#10;//     * @param itemHeight 항목 간 세로 간격&#10;//     */&#10;//    fun drawChartLegend(&#10;//        drawScope: DrawScope,&#10;//        labels: List&lt;String&gt;? = null,&#10;//        chartData: List&lt;ChartPoint&gt;? = null,&#10;//        colors: List&lt;Color&gt;,&#10;//        position: Offset,&#10;//        chartSize: androidx.compose.ui.geometry.Size,&#10;//        title: String? = null,&#10;//        itemHeight: Float = 40f&#10;//    ) {&#10;//        val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;//            point.label ?: &quot;항목 ${i+1}&quot;&#10;//        } ?: emptyList()&#10;//&#10;//        drawLegend(drawScope, legendLabels, colors, position, chartSize, title, itemHeight)&#10;//    }&#10;//&#10;//    /**&#10;//     * 범례의 개별 항목을 그립니다 (스케일링 지원).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param color 색상&#10;//     * @param label 레이블 텍스트&#10;//     * @param position 항목이 표시될 위치&#10;//     * @param boxSize 색상 상자 크기 (이미 스케일링 적용됨)&#10;//     * @param padding 상자와 텍스트 사이 간격 (이미 스케일링 적용됨)&#10;//     * @param textSize 텍스트 크기 (이미 스케일링 적용됨)&#10;//     */&#10;//    fun drawLegendItem(&#10;//        drawScope: DrawScope,&#10;//        color: Color,&#10;//        label: String,&#10;//        position: Offset,&#10;//        boxSize: Float,&#10;//        padding: Float,&#10;//        textSize: Float = 30f&#10;//    ) {&#10;//        // 색상 상자 그리기&#10;//        drawScope.drawRect(&#10;//            color = color,&#10;//            topLeft = position,&#10;//            size = Size(boxSize, boxSize)&#10;//        )&#10;//&#10;//        // 레이블 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            label,&#10;//            position.x + boxSize + padding,&#10;//            position.y + boxSize,&#10;//            android.graphics.Paint().apply {&#10;//                this.color = android.graphics.Color.DKGRAY&#10;//                this.textSize = textSize&#10;//            }&#10;//        )&#10;//    }&#10;//&#10;//    /**&#10;//     * 차트 툴팁을 그립니다 (모든 차트 타입에서 공통 사용).&#10;//     *&#10;//     * @param drawScope 그리기 영역&#10;//     * @param value 표시할 값&#10;//     * @param position 툴팁이 표시될 위치 (미리 계산된 최적 위치)&#10;//     * @param backgroundColor 툴팁 배경 색상&#10;//     * @param textColor 텍스트 색상&#10;//     * @param textSize 툴팁 텍스트 크기 (기본값: 32f)&#10;//     */&#10;//    fun drawTooltip(&#10;//        drawScope: DrawScope,&#10;//        value: Float,&#10;//        position: Offset,&#10;//        backgroundColor: Color = Color(0xE6333333), // 반투명 다크 그레이&#10;//        textColor: Int = android.graphics.Color.WHITE,&#10;//        textSize: Float = 32f&#10;//    ) {&#10;//        val tooltipText = formatTickLabel(value)&#10;//        val textPaint = android.graphics.Paint().apply {&#10;//            color = textColor&#10;//            this.textSize = textSize&#10;//            textAlign = android.graphics.Paint.Align.CENTER&#10;//        }&#10;//&#10;//        // 텍스트 크기 측정&#10;//        val textBounds = android.graphics.Rect()&#10;//        textPaint.getTextBounds(tooltipText, 0, tooltipText.length, textBounds)&#10;//&#10;//        // 툴팁 크기 계산 (패딩 포함)&#10;//        val padding = 16f&#10;//        val tooltipWidth = textBounds.width() + padding * 2&#10;//        val tooltipHeight = textBounds.height() + padding * 2&#10;//&#10;//        // 툴팁이 화면 밖으로 나가지 않도록 위치 조정&#10;//        val tooltipX = position.x.coerceIn(&#10;//            tooltipWidth / 2,&#10;//            drawScope.size.width - tooltipWidth / 2&#10;//        )&#10;//        val tooltipY = position.y.coerceIn(&#10;//            tooltipHeight / 2,&#10;//            drawScope.size.height - tooltipHeight / 2&#10;//        )&#10;//&#10;//        // 배경 그리기&#10;//        drawScope.drawRoundRect(&#10;//            color = backgroundColor,&#10;//            topLeft = Offset(tooltipX - tooltipWidth / 2, tooltipY - tooltipHeight / 2),&#10;//            size = Size(tooltipWidth, tooltipHeight),&#10;//            cornerRadius = androidx.compose.ui.geometry.CornerRadius(4f)&#10;//        )&#10;//&#10;//        // 텍스트 그리기&#10;//        drawScope.drawContext.canvas.nativeCanvas.drawText(&#10;//            tooltipText,&#10;//            tooltipX,&#10;//            tooltipY + textBounds.height() / 2,&#10;//            textPaint&#10;//        )&#10;//    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/compose/src/main/java/com/hdil/saluschart/ui/compose/components/Legend.kt" />
              <option name="updatedContent" value="package com.hdil.saluschart.ui.compose.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.hdil.saluschart.core.chart.ChartPoint&#10;&#10;/**&#10; * 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; */&#10;@Composable&#10;fun ChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 각 범례 항목&#10;        legendLabels.forEachIndexed { index, label -&gt;&#10;            if (index &lt; colors.size) {&#10;                LegendItem(&#10;                    color = colors[index],&#10;                    label = label,&#10;                    colorBoxSize = colorBoxSize,&#10;                    textSize = textSize,&#10;                    spacing = spacing&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * 범례의 개별 항목을 Composable로 표시합니다.&#10; *&#10; * @param color 색상&#10; * @param label 레이블 텍스트&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 상자와 텍스트 사이 간격&#10; */&#10;@Composable&#10;fun LegendItem(&#10;    color: Color,&#10;    label: String,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp&#10;) {&#10;    Row(&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 색상 상자&#10;        Box(&#10;            modifier = Modifier&#10;                .size(colorBoxSize)&#10;                .background(&#10;                    color = color,&#10;                    shape = RoundedCornerShape(2.dp)&#10;                )&#10;        )&#10;        &#10;        // 레이블 텍스트&#10;        Text(&#10;            text = label,&#10;            fontSize = textSize,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            style = MaterialTheme.typography.bodySmall&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * 스크롤 가능한 차트 범례를 Composable로 표시합니다.&#10; *&#10; * @param modifier 모디파이어&#10; * @param labels 범례 항목 레이블 목록 (직접 제공된 경우)&#10; * @param chartData 차트 데이터 포인트 목록 (레이블을 추출할 경우)&#10; * @param colors 각 항목에 사용한 색상 목록&#10; * @param title 범례 제목 (기본값: null)&#10; * @param colorBoxSize 색상 상자 크기&#10; * @param textSize 텍스트 크기&#10; * @param spacing 항목 간 간격&#10; * @param maxHeight 최대 높이 (이를 초과하면 스크롤)&#10; */&#10;@Composable&#10;fun ScrollableChartLegend(&#10;    modifier: Modifier = Modifier,&#10;    labels: List&lt;String&gt;? = null,&#10;    chartData: List&lt;ChartPoint&gt;? = null,&#10;    colors: List&lt;Color&gt;,&#10;    title: String? = null,&#10;    colorBoxSize: androidx.compose.ui.unit.Dp = 12.dp,&#10;    textSize: androidx.compose.ui.unit.TextUnit = 12.sp,&#10;    spacing: androidx.compose.ui.unit.Dp = 8.dp,&#10;    maxHeight: androidx.compose.ui.unit.Dp = 200.dp&#10;) {&#10;    val legendLabels = labels ?: chartData?.mapIndexed { i, point -&gt;&#10;        point.label ?: &quot;항목 ${i + 1}&quot;&#10;    } ?: emptyList()&#10;&#10;    Column(&#10;        modifier = modifier,&#10;        verticalArrangement = Arrangement.spacedBy(spacing)&#10;    ) {&#10;        // 범례 제목 (제공된 경우)&#10;        title?.let {&#10;            Text(&#10;                text = it,&#10;                style = MaterialTheme.typography.titleSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = (textSize.value + 2).sp,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;        }&#10;&#10;        // 스크롤 가능한 범례 항목들&#10;        LazyColumn(&#10;            modifier = Modifier.heightIn(max = maxHeight),&#10;            verticalArrangement = Arrangement.spacedBy(spacing)&#10;        ) {&#10;            items(legendLabels.take(colors.size)) { label -&gt;&#10;                val index = legendLabels.indexOf(label)&#10;                if (index &gt;= 0 &amp;&amp; index &lt; colors.size) {&#10;                    LegendItem(&#10;                        color = colors[index],&#10;                        label = label,&#10;                        colorBoxSize = colorBoxSize,&#10;                        textSize = textSize,&#10;                        spacing = spacing&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>